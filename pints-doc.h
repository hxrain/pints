/** @file
 * @brief User documentation
 *
 * This file contains the user documentation.
 * This file does not contain any code.
 */

//#ifdef PINTS_DOC_H
#error "This file should not be included"

/** \defgroup vectors Vector and Mask types */
/** \defgroup maskop Primitives related to masks */
/**
 * \defgroup v1 1 elements vectors
 * \ingroup vectors
 */
/**
 * \defgroup v2 2 elements vectors
 * \ingroup vectors
 */
/**
 * \defgroup v4 4 elements vectors
 * \ingroup vectors
 */
/**
 * \defgroup v8 8 elements vectors
 * \ingroup vectors
 */
/**
 * \defgroup v16 16 elements vectors
 * \ingroup vectors
 */
/**
 * \ingroup v1
 * \brief Type for the manipulation of 1 \c double packed into one single vector.
 * \details Type for the manipulation of 1 \c double packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 1 elements of type \c double  (64 bits)
 *  - 8 bytes
 *  - 64 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v1d {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m1d vector-mask is a bitset of 1 bits,
 *  allowing to do an operation on the ith element of a \c v1d vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m1d mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v1d (8 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m1d {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of 1 \c float packed into one single vector.
 * \details Type for the manipulation of 1 \c float packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 1 elements of type \c float  (32 bits)
 *  - 4 bytes
 *  - 32 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v1f {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m1f vector-mask is a bitset of 1 bits,
 *  allowing to do an operation on the ith element of a \c v1f vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m1f mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v1f (4 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m1f {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of 1 \c int32_t packed into one single vector.
 * \details Type for the manipulation of 1 \c int32_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 1 elements of type \c int32_t  (32 bits)
 *  - 4 bytes
 *  - 32 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v1i {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m1i vector-mask is a bitset of 1 bits,
 *  allowing to do an operation on the ith element of a \c v1i vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m1i mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v1i (4 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m1i {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of 1 \c int64_t packed into one single vector.
 * \details Type for the manipulation of 1 \c int64_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 1 elements of type \c int64_t  (64 bits)
 *  - 8 bytes
 *  - 64 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v1l {};
/**
 * \ingroup v1
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m1l vector-mask is a bitset of 1 bits,
 *  allowing to do an operation on the ith element of a \c v1l vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m1l mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v1l (8 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m1l {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of 2 \c double packed into one single vector.
 * \details Type for the manipulation of 2 \c double packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 2 elements of type \c double  (64 bits)
 *  - 16 bytes
 *  - 128 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v2d {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m2d vector-mask is a bitset of 2 bits,
 *  allowing to do an operation on the ith element of a \c v2d vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m2d mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v2d (16 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m2d {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of 2 \c float packed into one single vector.
 * \details Type for the manipulation of 2 \c float packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 2 elements of type \c float  (32 bits)
 *  - 8 bytes
 *  - 64 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v2f {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m2f vector-mask is a bitset of 2 bits,
 *  allowing to do an operation on the ith element of a \c v2f vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m2f mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v2f (8 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m2f {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of 2 \c int32_t packed into one single vector.
 * \details Type for the manipulation of 2 \c int32_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 2 elements of type \c int32_t  (32 bits)
 *  - 8 bytes
 *  - 64 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v2i {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m2i vector-mask is a bitset of 2 bits,
 *  allowing to do an operation on the ith element of a \c v2i vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m2i mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v2i (8 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m2i {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of 2 \c int64_t packed into one single vector.
 * \details Type for the manipulation of 2 \c int64_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 2 elements of type \c int64_t  (64 bits)
 *  - 16 bytes
 *  - 128 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v2l {};
/**
 * \ingroup v2
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m2l vector-mask is a bitset of 2 bits,
 *  allowing to do an operation on the ith element of a \c v2l vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m2l mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v2l (16 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m2l {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of 4 \c double packed into one single vector.
 * \details Type for the manipulation of 4 \c double packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 4 elements of type \c double  (64 bits)
 *  - 32 bytes
 *  - 256 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v4d {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m4d vector-mask is a bitset of 4 bits,
 *  allowing to do an operation on the ith element of a \c v4d vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m4d mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v4d (32 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m4d {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of 4 \c float packed into one single vector.
 * \details Type for the manipulation of 4 \c float packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 4 elements of type \c float  (32 bits)
 *  - 16 bytes
 *  - 128 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v4f {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m4f vector-mask is a bitset of 4 bits,
 *  allowing to do an operation on the ith element of a \c v4f vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m4f mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v4f (16 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m4f {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of 4 \c int32_t packed into one single vector.
 * \details Type for the manipulation of 4 \c int32_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 4 elements of type \c int32_t  (32 bits)
 *  - 16 bytes
 *  - 128 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v4i {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m4i vector-mask is a bitset of 4 bits,
 *  allowing to do an operation on the ith element of a \c v4i vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m4i mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v4i (16 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m4i {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of 4 \c int64_t packed into one single vector.
 * \details Type for the manipulation of 4 \c int64_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 4 elements of type \c int64_t  (64 bits)
 *  - 32 bytes
 *  - 256 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v4l {};
/**
 * \ingroup v4
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m4l vector-mask is a bitset of 4 bits,
 *  allowing to do an operation on the ith element of a \c v4l vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m4l mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v4l (32 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m4l {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of 8 \c double packed into one single vector.
 * \details Type for the manipulation of 8 \c double packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 8 elements of type \c double  (64 bits)
 *  - 64 bytes
 *  - 512 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v8d {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m8d vector-mask is a bitset of 8 bits,
 *  allowing to do an operation on the ith element of a \c v8d vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m8d mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v8d (64 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m8d {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of 8 \c float packed into one single vector.
 * \details Type for the manipulation of 8 \c float packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 8 elements of type \c float  (32 bits)
 *  - 32 bytes
 *  - 256 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v8f {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m8f vector-mask is a bitset of 8 bits,
 *  allowing to do an operation on the ith element of a \c v8f vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m8f mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v8f (32 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m8f {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of 8 \c int32_t packed into one single vector.
 * \details Type for the manipulation of 8 \c int32_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 8 elements of type \c int32_t  (32 bits)
 *  - 32 bytes
 *  - 256 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v8i {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m8i vector-mask is a bitset of 8 bits,
 *  allowing to do an operation on the ith element of a \c v8i vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m8i mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v8i (32 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m8i {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of 8 \c int64_t packed into one single vector.
 * \details Type for the manipulation of 8 \c int64_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 8 elements of type \c int64_t  (64 bits)
 *  - 64 bytes
 *  - 512 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v8l {};
/**
 * \ingroup v8
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m8l vector-mask is a bitset of 8 bits,
 *  allowing to do an operation on the ith element of a \c v8l vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m8l mask depends also on the target architecture
 *  and can be 1 byte,
 *  or the size of a \c v8l (64 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m8l {};
/**
 * \ingroup v16
 * \brief Type for the manipulation of 16 \c float packed into one single vector.
 * \details Type for the manipulation of 16 \c float packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 16 elements of type \c float  (32 bits)
 *  - 64 bytes
 *  - 512 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v16f {};
/**
 * \ingroup v16
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m16f vector-mask is a bitset of 16 bits,
 *  allowing to do an operation on the ith element of a \c v16f vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m16f mask depends also on the target architecture
 *  and can be 2 bytes,
 *  or the size of a \c v16f (64 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m16f {};
/**
 * \ingroup v16
 * \brief Type for the manipulation of 16 \c int32_t packed into one single vector.
 * \details Type for the manipulation of 16 \c int32_t packed into one single vector.
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 * \details Sizes of this vector:
 *  - 16 elements of type \c int32_t  (32 bits)
 *  - 64 bytes
 *  - 512 bits
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 */
struct v16i {};
/**
 * \ingroup v16
 * \brief Type for the manipulation of vector-masks.
 * \details Type for the manipulation of vector-masks.
 * \details A \c m16i vector-mask is a bitset of 16 bits,
 *  allowing to do an operation on the ith element of a \c v16i vector only if the ith bit of the mask is set
 * \details This structure does not actually exist. Depending on the target architecture, it can be:
 *  - A preprocessor alias
 *  - A typedef
 *  - A struct defined in another way
 *  - A union
 *
 * \attention This definition does not correspond to any actual implementation and should never be used directly.
 *  Use PintS functions instead.
 * \attention The actual implementation depends on the target architecture.
 * \attention the size of a \c m16i mask depends also on the target architecture
 *  and can be 2 bytes,
 *  or the size of a \c v16i (64 bytes), or something else.
 *  Nothing should rely on the size of a mask.
 */
struct m16i {};

/* LOADS */
/** \defgroup load load functions
 * 
 */

/**
 * \ingroup load
 * \related v1d
 * \brief Loads 1 \c double from memory into a \c v1d vector
 * \details Loads 1 \c double (64 bits) from memory into a \c v1d vector.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1d v1d_load(const double *p);
/**
 * \ingroup load
 * \related v1f
 * \brief Loads 1 \c float from memory into a \c v1f vector
 * \details Loads 1 \c float (32 bits) from memory into a \c v1f vector.
 *  \c p must be aligned on a 4-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:31] := MEMORY.bits[p:p+31]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1f v1f_load(const float *p);
/**
 * \ingroup load
 * \related v1i
 * \brief Loads 1 \c int32_t from memory into a \c v1i vector
 * \details Loads 1 \c int32_t (32 bits) from memory into a \c v1i vector.
 *  \c p must be aligned on a 4-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:31] := MEMORY.bits[p:p+31]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1i v1i_load(const int32_t *p);
/**
 * \ingroup load
 * \related v1l
 * \brief Loads 1 \c int64_t from memory into a \c v1l vector
 * \details Loads 1 \c int64_t (64 bits) from memory into a \c v1l vector.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1l v1l_load(const int64_t *p);
/**
 * \ingroup load
 * \related v2d
 * \brief Loads 2 \c double from memory into a \c v2d vector
 * \details Loads 2 \c double (128 bits) from memory into a \c v2d vector.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2d v2d_load(const double *p);
/**
 * \ingroup load
 * \related v2f
 * \brief Loads 2 \c float from memory into a \c v2f vector
 * \details Loads 2 \c float (64 bits) from memory into a \c v2f vector.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2f v2f_load(const float *p);
/**
 * \ingroup load
 * \related v2i
 * \brief Loads 2 \c int32_t from memory into a \c v2i vector
 * \details Loads 2 \c int32_t (64 bits) from memory into a \c v2i vector.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2i v2i_load(const int32_t *p);
/**
 * \ingroup load
 * \related v2l
 * \brief Loads 2 \c int64_t from memory into a \c v2l vector
 * \details Loads 2 \c int64_t (128 bits) from memory into a \c v2l vector.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2l v2l_load(const int64_t *p);
/**
 * \ingroup load
 * \related v4d
 * \brief Loads 4 \c double from memory into a \c v4d vector
 * \details Loads 4 \c double (256 bits) from memory into a \c v4d vector.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4d v4d_load(const double *p);
/**
 * \ingroup load
 * \related v4f
 * \brief Loads 4 \c float from memory into a \c v4f vector
 * \details Loads 4 \c float (128 bits) from memory into a \c v4f vector.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4f v4f_load(const float *p);
/**
 * \ingroup load
 * \related v4i
 * \brief Loads 4 \c int32_t from memory into a \c v4i vector
 * \details Loads 4 \c int32_t (128 bits) from memory into a \c v4i vector.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4i v4i_load(const int32_t *p);
/**
 * \ingroup load
 * \related v4l
 * \brief Loads 4 \c int64_t from memory into a \c v4l vector
 * \details Loads 4 \c int64_t (256 bits) from memory into a \c v4l vector.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4l v4l_load(const int64_t *p);
/**
 * \ingroup load
 * \related v8d
 * \brief Loads 8 \c double from memory into a \c v8d vector
 * \details Loads 8 \c double (512 bits) from memory into a \c v8d vector.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8d v8d_load(const double *p);
/**
 * \ingroup load
 * \related v8f
 * \brief Loads 8 \c float from memory into a \c v8f vector
 * \details Loads 8 \c float (256 bits) from memory into a \c v8f vector.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8f v8f_load(const float *p);
/**
 * \ingroup load
 * \related v8i
 * \brief Loads 8 \c int32_t from memory into a \c v8i vector
 * \details Loads 8 \c int32_t (256 bits) from memory into a \c v8i vector.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8i v8i_load(const int32_t *p);
/**
 * \ingroup load
 * \related v8l
 * \brief Loads 8 \c int64_t from memory into a \c v8l vector
 * \details Loads 8 \c int64_t (512 bits) from memory into a \c v8l vector.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8l v8l_load(const int64_t *p);
/**
 * \ingroup load
 * \related v16f
 * \brief Loads 16 \c float from memory into a \c v16f vector
 * \details Loads 16 \c float (512 bits) from memory into a \c v16f vector.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v16f v16f_load(const float *p);
/**
 * \ingroup load
 * \related v16i
 * \brief Loads 16 \c int32_t from memory into a \c v16i vector
 * \details Loads 16 \c int32_t (512 bits) from memory into a \c v16i vector.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v16i v16i_load(const int32_t *p);

/**
 * \ingroup load
 * \related v1d
 * \brief Loads 1 \c double from memory into a \c v1d vector
 * \details Loads 1 \c double (64 bits) from memory into a \c v1d vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1d v1d_loadu(const double *p);
/**
 * \ingroup load
 * \related v1f
 * \brief Loads 1 \c float from memory into a \c v1f vector
 * \details Loads 1 \c float (32 bits) from memory into a \c v1f vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:31] := MEMORY.bits[p:p+31]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1f v1f_loadu(const float *p);
/**
 * \ingroup load
 * \related v1i
 * \brief Loads 1 \c int32_t from memory into a \c v1i vector
 * \details Loads 1 \c int32_t (32 bits) from memory into a \c v1i vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:31] := MEMORY.bits[p:p+31]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1i v1i_loadu(const int32_t *p);
/**
 * \ingroup load
 * \related v1l
 * \brief Loads 1 \c int64_t from memory into a \c v1l vector
 * \details Loads 1 \c int64_t (64 bits) from memory into a \c v1l vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v1l v1l_loadu(const int64_t *p);
/**
 * \ingroup load
 * \related v2d
 * \brief Loads 2 \c double from memory into a \c v2d vector
 * \details Loads 2 \c double (128 bits) from memory into a \c v2d vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2d v2d_loadu(const double *p);
/**
 * \ingroup load
 * \related v2f
 * \brief Loads 2 \c float from memory into a \c v2f vector
 * \details Loads 2 \c float (64 bits) from memory into a \c v2f vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2f v2f_loadu(const float *p);
/**
 * \ingroup load
 * \related v2i
 * \brief Loads 2 \c int32_t from memory into a \c v2i vector
 * \details Loads 2 \c int32_t (64 bits) from memory into a \c v2i vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:63] := MEMORY.bits[p:p+63]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2i v2i_loadu(const int32_t *p);
/**
 * \ingroup load
 * \related v2l
 * \brief Loads 2 \c int64_t from memory into a \c v2l vector
 * \details Loads 2 \c int64_t (128 bits) from memory into a \c v2l vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v2l v2l_loadu(const int64_t *p);
/**
 * \ingroup load
 * \related v4d
 * \brief Loads 4 \c double from memory into a \c v4d vector
 * \details Loads 4 \c double (256 bits) from memory into a \c v4d vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4d v4d_loadu(const double *p);
/**
 * \ingroup load
 * \related v4f
 * \brief Loads 4 \c float from memory into a \c v4f vector
 * \details Loads 4 \c float (128 bits) from memory into a \c v4f vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4f v4f_loadu(const float *p);
/**
 * \ingroup load
 * \related v4i
 * \brief Loads 4 \c int32_t from memory into a \c v4i vector
 * \details Loads 4 \c int32_t (128 bits) from memory into a \c v4i vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:127] := MEMORY.bits[p:p+127]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4i v4i_loadu(const int32_t *p);
/**
 * \ingroup load
 * \related v4l
 * \brief Loads 4 \c int64_t from memory into a \c v4l vector
 * \details Loads 4 \c int64_t (256 bits) from memory into a \c v4l vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v4l v4l_loadu(const int64_t *p);
/**
 * \ingroup load
 * \related v8d
 * \brief Loads 8 \c double from memory into a \c v8d vector
 * \details Loads 8 \c double (512 bits) from memory into a \c v8d vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8d v8d_loadu(const double *p);
/**
 * \ingroup load
 * \related v8f
 * \brief Loads 8 \c float from memory into a \c v8f vector
 * \details Loads 8 \c float (256 bits) from memory into a \c v8f vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8f v8f_loadu(const float *p);
/**
 * \ingroup load
 * \related v8i
 * \brief Loads 8 \c int32_t from memory into a \c v8i vector
 * \details Loads 8 \c int32_t (256 bits) from memory into a \c v8i vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:255] := MEMORY.bits[p:p+255]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8i v8i_loadu(const int32_t *p);
/**
 * \ingroup load
 * \related v8l
 * \brief Loads 8 \c int64_t from memory into a \c v8l vector
 * \details Loads 8 \c int64_t (512 bits) from memory into a \c v8l vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v8l v8l_loadu(const int64_t *p);
/**
 * \ingroup load
 * \related v16f
 * \brief Loads 16 \c float from memory into a \c v16f vector
 * \details Loads 16 \c float (512 bits) from memory into a \c v16f vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v16f v16f_loadu(const float *p);
/**
 * \ingroup load
 * \related v16i
 * \brief Loads 16 \c int32_t from memory into a \c v16i vector
 * \details Loads 16 \c int32_t (512 bits) from memory into a \c v16i vector.
 *  There is no alignment requirement.
 * \impl
dst.bits[0:511] := MEMORY.bits[p:p+511]
\endimpl
 * \param p the memory address of the data beginning
 * \returns vector loaded
 */
v16i v16i_loadu(const int32_t *p);

/**
 * \ingroup load
 * \related v1d
 * \brief Loads 1 \c double from memory and broadcasts it into a \c v1d vector
 * \details Loads 1 \c double (64 bits) from memory and broadcasts it into a \c v1d vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 0
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c double
 * \returns vector loaded
 */
v1d v1d_load1(const double *p);
/**
 * \ingroup load
 * \related v1f
 * \brief Loads 1 \c float from memory and broadcasts it into a \c v1f vector
 * \details Loads 1 \c float (32 bits) from memory and broadcasts it into a \c v1f vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 0
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c float
 * \returns vector loaded
 */
v1f v1f_load1(const float *p);
/**
 * \ingroup load
 * \related v1i
 * \brief Loads 1 \c int32_t from memory and broadcasts it into a \c v1i vector
 * \details Loads 1 \c int32_t (32 bits) from memory and broadcasts it into a \c v1i vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 0
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c int32_t
 * \returns vector loaded
 */
v1i v1i_load1(const int32_t *p);
/**
 * \ingroup load
 * \related v1l
 * \brief Loads 1 \c int64_t from memory and broadcasts it into a \c v1l vector
 * \details Loads 1 \c int64_t (64 bits) from memory and broadcasts it into a \c v1l vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 0
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c int64_t
 * \returns vector loaded
 */
v1l v1l_load1(const int64_t *p);
/**
 * \ingroup load
 * \related v2d
 * \brief Loads 1 \c double from memory and broadcasts it into a \c v2d vector
 * \details Loads 1 \c double (64 bits) from memory and broadcasts it into a \c v2d vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 1
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c double
 * \returns vector loaded
 */
v2d v2d_load1(const double *p);
/**
 * \ingroup load
 * \related v2f
 * \brief Loads 1 \c float from memory and broadcasts it into a \c v2f vector
 * \details Loads 1 \c float (32 bits) from memory and broadcasts it into a \c v2f vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 1
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c float
 * \returns vector loaded
 */
v2f v2f_load1(const float *p);
/**
 * \ingroup load
 * \related v2i
 * \brief Loads 1 \c int32_t from memory and broadcasts it into a \c v2i vector
 * \details Loads 1 \c int32_t (32 bits) from memory and broadcasts it into a \c v2i vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 1
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c int32_t
 * \returns vector loaded
 */
v2i v2i_load1(const int32_t *p);
/**
 * \ingroup load
 * \related v2l
 * \brief Loads 1 \c int64_t from memory and broadcasts it into a \c v2l vector
 * \details Loads 1 \c int64_t (64 bits) from memory and broadcasts it into a \c v2l vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 1
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c int64_t
 * \returns vector loaded
 */
v2l v2l_load1(const int64_t *p);
/**
 * \ingroup load
 * \related v4d
 * \brief Loads 1 \c double from memory and broadcasts it into a \c v4d vector
 * \details Loads 1 \c double (64 bits) from memory and broadcasts it into a \c v4d vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 3
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c double
 * \returns vector loaded
 */
v4d v4d_load1(const double *p);
/**
 * \ingroup load
 * \related v4f
 * \brief Loads 1 \c float from memory and broadcasts it into a \c v4f vector
 * \details Loads 1 \c float (32 bits) from memory and broadcasts it into a \c v4f vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 3
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c float
 * \returns vector loaded
 */
v4f v4f_load1(const float *p);
/**
 * \ingroup load
 * \related v4i
 * \brief Loads 1 \c int32_t from memory and broadcasts it into a \c v4i vector
 * \details Loads 1 \c int32_t (32 bits) from memory and broadcasts it into a \c v4i vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 3
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c int32_t
 * \returns vector loaded
 */
v4i v4i_load1(const int32_t *p);
/**
 * \ingroup load
 * \related v4l
 * \brief Loads 1 \c int64_t from memory and broadcasts it into a \c v4l vector
 * \details Loads 1 \c int64_t (64 bits) from memory and broadcasts it into a \c v4l vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 3
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c int64_t
 * \returns vector loaded
 */
v4l v4l_load1(const int64_t *p);
/**
 * \ingroup load
 * \related v8d
 * \brief Loads 1 \c double from memory and broadcasts it into a \c v8d vector
 * \details Loads 1 \c double (64 bits) from memory and broadcasts it into a \c v8d vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 7
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c double
 * \returns vector loaded
 */
v8d v8d_load1(const double *p);
/**
 * \ingroup load
 * \related v8f
 * \brief Loads 1 \c float from memory and broadcasts it into a \c v8f vector
 * \details Loads 1 \c float (32 bits) from memory and broadcasts it into a \c v8f vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 7
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c float
 * \returns vector loaded
 */
v8f v8f_load1(const float *p);
/**
 * \ingroup load
 * \related v8i
 * \brief Loads 1 \c int32_t from memory and broadcasts it into a \c v8i vector
 * \details Loads 1 \c int32_t (32 bits) from memory and broadcasts it into a \c v8i vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 7
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c int32_t
 * \returns vector loaded
 */
v8i v8i_load1(const int32_t *p);
/**
 * \ingroup load
 * \related v8l
 * \brief Loads 1 \c int64_t from memory and broadcasts it into a \c v8l vector
 * \details Loads 1 \c int64_t (64 bits) from memory and broadcasts it into a \c v8l vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 7
  i := j * 64 
  dst.bits[i:i+63] := MEMORY.bits[p:p+63]
endfor
\endimpl
 * \param p the memory address of the scalar \c int64_t
 * \returns vector loaded
 */
v8l v8l_load1(const int64_t *p);
/**
 * \ingroup load
 * \related v16f
 * \brief Loads 1 \c float from memory and broadcasts it into a \c v16f vector
 * \details Loads 1 \c float (32 bits) from memory and broadcasts it into a \c v16f vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 15
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c float
 * \returns vector loaded
 */
v16f v16f_load1(const float *p);
/**
 * \ingroup load
 * \related v16i
 * \brief Loads 1 \c int32_t from memory and broadcasts it into a \c v16i vector
 * \details Loads 1 \c int32_t (32 bits) from memory and broadcasts it into a \c v16i vector.
 *  There is no alignment requirement.
 * \impl
for j from 0 to 15
  i := j * 32 
  dst.bits[i:i+31] := MEMORY.bits[p:p+31]
endfor
\endimpl
 * \param p the memory address of the scalar \c int32_t
 * \returns vector loaded
 */
v16i v16i_load1(const int32_t *p);


/* STORES */
/** \defgroup store store functions
 * 
 */

/**
 * \ingroup store
 * \related v1d
 * \brief Stores a \c v1d vector into memory.
 * \details Stores a \c v1d vector (64 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1d_store(double *p, v1d a);
/**
 * \ingroup store
 * \related v1f
 * \brief Stores a \c v1f vector into memory.
 * \details Stores a \c v1f vector (32 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 4-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1f_store(float *p, v1f a);
/**
 * \ingroup store
 * \related v1i
 * \brief Stores a \c v1i vector into memory.
 * \details Stores a \c v1i vector (32 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 4-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1i_store(int32_t *p, v1i a);
/**
 * \ingroup store
 * \related v1l
 * \brief Stores a \c v1l vector into memory.
 * \details Stores a \c v1l vector (64 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1l_store(int64_t *p, v1l a);
/**
 * \ingroup store
 * \related v2d
 * \brief Stores a \c v2d vector into memory.
 * \details Stores a \c v2d vector (128 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2d_store(double *p, v2d a);
/**
 * \ingroup store
 * \related v2f
 * \brief Stores a \c v2f vector into memory.
 * \details Stores a \c v2f vector (64 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2f_store(float *p, v2f a);
/**
 * \ingroup store
 * \related v2i
 * \brief Stores a \c v2i vector into memory.
 * \details Stores a \c v2i vector (64 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 8-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2i_store(int32_t *p, v2i a);
/**
 * \ingroup store
 * \related v2l
 * \brief Stores a \c v2l vector into memory.
 * \details Stores a \c v2l vector (128 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2l_store(int64_t *p, v2l a);
/**
 * \ingroup store
 * \related v4d
 * \brief Stores a \c v4d vector into memory.
 * \details Stores a \c v4d vector (256 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4d_store(double *p, v4d a);
/**
 * \ingroup store
 * \related v4f
 * \brief Stores a \c v4f vector into memory.
 * \details Stores a \c v4f vector (128 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4f_store(float *p, v4f a);
/**
 * \ingroup store
 * \related v4i
 * \brief Stores a \c v4i vector into memory.
 * \details Stores a \c v4i vector (128 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 16-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4i_store(int32_t *p, v4i a);
/**
 * \ingroup store
 * \related v4l
 * \brief Stores a \c v4l vector into memory.
 * \details Stores a \c v4l vector (256 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4l_store(int64_t *p, v4l a);
/**
 * \ingroup store
 * \related v8d
 * \brief Stores a \c v8d vector into memory.
 * \details Stores a \c v8d vector (512 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8d_store(double *p, v8d a);
/**
 * \ingroup store
 * \related v8f
 * \brief Stores a \c v8f vector into memory.
 * \details Stores a \c v8f vector (256 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8f_store(float *p, v8f a);
/**
 * \ingroup store
 * \related v8i
 * \brief Stores a \c v8i vector into memory.
 * \details Stores a \c v8i vector (256 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 32-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8i_store(int32_t *p, v8i a);
/**
 * \ingroup store
 * \related v8l
 * \brief Stores a \c v8l vector into memory.
 * \details Stores a \c v8l vector (512 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8l_store(int64_t *p, v8l a);
/**
 * \ingroup store
 * \related v16f
 * \brief Stores a \c v16f vector into memory.
 * \details Stores a \c v16f vector (512 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v16f_store(float *p, v16f a);
/**
 * \ingroup store
 * \related v16i
 * \brief Stores a \c v16i vector into memory.
 * \details Stores a \c v16i vector (512 bits) into memory starting at the specified address.
 *  \c p must be aligned on a 64-bytes boundary or a general-protection exception may be generated.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v16i_store(int32_t *p, v16i a);

/**
 * \ingroup store
 * \related v1d
 * \brief Stores a \c v1d vector into memory.
 * \details Stores a \c v1d vector (64 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1d_storeu(double *p, v1d a);
/**
 * \ingroup store
 * \related v1f
 * \brief Stores a \c v1f vector into memory.
 * \details Stores a \c v1f vector (32 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1f_storeu(float *p, v1f a);
/**
 * \ingroup store
 * \related v1i
 * \brief Stores a \c v1i vector into memory.
 * \details Stores a \c v1i vector (32 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1i_storeu(int32_t *p, v1i a);
/**
 * \ingroup store
 * \related v1l
 * \brief Stores a \c v1l vector into memory.
 * \details Stores a \c v1l vector (64 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v1l_storeu(int64_t *p, v1l a);
/**
 * \ingroup store
 * \related v2d
 * \brief Stores a \c v2d vector into memory.
 * \details Stores a \c v2d vector (128 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2d_storeu(double *p, v2d a);
/**
 * \ingroup store
 * \related v2f
 * \brief Stores a \c v2f vector into memory.
 * \details Stores a \c v2f vector (64 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2f_storeu(float *p, v2f a);
/**
 * \ingroup store
 * \related v2i
 * \brief Stores a \c v2i vector into memory.
 * \details Stores a \c v2i vector (64 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2i_storeu(int32_t *p, v2i a);
/**
 * \ingroup store
 * \related v2l
 * \brief Stores a \c v2l vector into memory.
 * \details Stores a \c v2l vector (128 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v2l_storeu(int64_t *p, v2l a);
/**
 * \ingroup store
 * \related v4d
 * \brief Stores a \c v4d vector into memory.
 * \details Stores a \c v4d vector (256 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4d_storeu(double *p, v4d a);
/**
 * \ingroup store
 * \related v4f
 * \brief Stores a \c v4f vector into memory.
 * \details Stores a \c v4f vector (128 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4f_storeu(float *p, v4f a);
/**
 * \ingroup store
 * \related v4i
 * \brief Stores a \c v4i vector into memory.
 * \details Stores a \c v4i vector (128 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+127] := a.bits[0:127]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4i_storeu(int32_t *p, v4i a);
/**
 * \ingroup store
 * \related v4l
 * \brief Stores a \c v4l vector into memory.
 * \details Stores a \c v4l vector (256 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v4l_storeu(int64_t *p, v4l a);
/**
 * \ingroup store
 * \related v8d
 * \brief Stores a \c v8d vector into memory.
 * \details Stores a \c v8d vector (512 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8d_storeu(double *p, v8d a);
/**
 * \ingroup store
 * \related v8f
 * \brief Stores a \c v8f vector into memory.
 * \details Stores a \c v8f vector (256 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8f_storeu(float *p, v8f a);
/**
 * \ingroup store
 * \related v8i
 * \brief Stores a \c v8i vector into memory.
 * \details Stores a \c v8i vector (256 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+255] := a.bits[0:255]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8i_storeu(int32_t *p, v8i a);
/**
 * \ingroup store
 * \related v8l
 * \brief Stores a \c v8l vector into memory.
 * \details Stores a \c v8l vector (512 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v8l_storeu(int64_t *p, v8l a);
/**
 * \ingroup store
 * \related v16f
 * \brief Stores a \c v16f vector into memory.
 * \details Stores a \c v16f vector (512 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v16f_storeu(float *p, v16f a);
/**
 * \ingroup store
 * \related v16i
 * \brief Stores a \c v16i vector into memory.
 * \details Stores a \c v16i vector (512 bits) into memory starting at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+511] := a.bits[0:511]
\endimpl
 * \param p the memory address of the data beginning
 * \param a the vector to be stored
 */
void v16i_storeu(int32_t *p, v16i a);

/**
 * \ingroup store
 * \related v1d
 * \brief Stores the first element of a \c v1d vector into memory.
 * \details Stores the first element of a \c v1d vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v1d_store1(double *p, v1d a);
/**
 * \ingroup store
 * \related v1f
 * \brief Stores the first element of a \c v1f vector into memory.
 * \details Stores the first element of a \c v1f vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v1f_store1(float *p, v1f a);
/**
 * \ingroup store
 * \related v1i
 * \brief Stores the first element of a \c v1i vector into memory.
 * \details Stores the first element of a \c v1i vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v1i_store1(int32_t *p, v1i a);
/**
 * \ingroup store
 * \related v1l
 * \brief Stores the first element of a \c v1l vector into memory.
 * \details Stores the first element of a \c v1l vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v1l_store1(int64_t *p, v1l a);
/**
 * \ingroup store
 * \related v2d
 * \brief Stores the first element of a \c v2d vector into memory.
 * \details Stores the first element of a \c v2d vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v2d_store1(double *p, v2d a);
/**
 * \ingroup store
 * \related v2f
 * \brief Stores the first element of a \c v2f vector into memory.
 * \details Stores the first element of a \c v2f vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v2f_store1(float *p, v2f a);
/**
 * \ingroup store
 * \related v2i
 * \brief Stores the first element of a \c v2i vector into memory.
 * \details Stores the first element of a \c v2i vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v2i_store1(int32_t *p, v2i a);
/**
 * \ingroup store
 * \related v2l
 * \brief Stores the first element of a \c v2l vector into memory.
 * \details Stores the first element of a \c v2l vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v2l_store1(int64_t *p, v2l a);
/**
 * \ingroup store
 * \related v4d
 * \brief Stores the first element of a \c v4d vector into memory.
 * \details Stores the first element of a \c v4d vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v4d_store1(double *p, v4d a);
/**
 * \ingroup store
 * \related v4f
 * \brief Stores the first element of a \c v4f vector into memory.
 * \details Stores the first element of a \c v4f vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v4f_store1(float *p, v4f a);
/**
 * \ingroup store
 * \related v4i
 * \brief Stores the first element of a \c v4i vector into memory.
 * \details Stores the first element of a \c v4i vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v4i_store1(int32_t *p, v4i a);
/**
 * \ingroup store
 * \related v4l
 * \brief Stores the first element of a \c v4l vector into memory.
 * \details Stores the first element of a \c v4l vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v4l_store1(int64_t *p, v4l a);
/**
 * \ingroup store
 * \related v8d
 * \brief Stores the first element of a \c v8d vector into memory.
 * \details Stores the first element of a \c v8d vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v8d_store1(double *p, v8d a);
/**
 * \ingroup store
 * \related v8f
 * \brief Stores the first element of a \c v8f vector into memory.
 * \details Stores the first element of a \c v8f vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v8f_store1(float *p, v8f a);
/**
 * \ingroup store
 * \related v8i
 * \brief Stores the first element of a \c v8i vector into memory.
 * \details Stores the first element of a \c v8i vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v8i_store1(int32_t *p, v8i a);
/**
 * \ingroup store
 * \related v8l
 * \brief Stores the first element of a \c v8l vector into memory.
 * \details Stores the first element of a \c v8l vector (64 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+63] := a.bits[0:63]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v8l_store1(int64_t *p, v8l a);
/**
 * \ingroup store
 * \related v16f
 * \brief Stores the first element of a \c v16f vector into memory.
 * \details Stores the first element of a \c v16f vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v16f_store1(float *p, v16f a);
/**
 * \ingroup store
 * \related v16i
 * \brief Stores the first element of a \c v16i vector into memory.
 * \details Stores the first element of a \c v16i vector (32 bits) into memory at the specified address.
 *  There is no alignment requirement.
 * \impl
MEMORY.bits[p:p+31] := a.bits[0:31]
\endimpl
 * \param p the memory address
 * \param a the vector to be stored
 */
void v16i_store1(int32_t *p, v16i a);


/* SETS */
/** \defgroup set set functions
 * 
 */

/**
 * \ingroup set
 * \related v1d
 * \brief Sets the elements of a \c v1d vector.
 * \details Sets the elements of a \c v1d vector.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1d v1d_set(double v0);
/**
 * \ingroup set
 * \related v1f
 * \brief Sets the elements of a \c v1f vector.
 * \details Sets the elements of a \c v1f vector.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1f v1f_set(float v0);
/**
 * \ingroup set
 * \related v1i
 * \brief Sets the elements of a \c v1i vector.
 * \details Sets the elements of a \c v1i vector.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1i v1i_set(int32_t v0);
/**
 * \ingroup set
 * \related v1l
 * \brief Sets the elements of a \c v1l vector.
 * \details Sets the elements of a \c v1l vector.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1l v1l_set(int64_t v0);
/**
 * \ingroup set
 * \related v2d
 * \brief Sets the elements of a \c v2d vector.
 * \details Sets the elements of a \c v2d vector.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \returns the vector
 */
v2d v2d_set(double v0, double v1);
/**
 * \ingroup set
 * \related v2f
 * \brief Sets the elements of a \c v2f vector.
 * \details Sets the elements of a \c v2f vector.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \returns the vector
 */
v2f v2f_set(float v0, float v1);
/**
 * \ingroup set
 * \related v2i
 * \brief Sets the elements of a \c v2i vector.
 * \details Sets the elements of a \c v2i vector.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \returns the vector
 */
v2i v2i_set(int32_t v0, int32_t v1);
/**
 * \ingroup set
 * \related v2l
 * \brief Sets the elements of a \c v2l vector.
 * \details Sets the elements of a \c v2l vector.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \returns the vector
 */
v2l v2l_set(int64_t v0, int64_t v1);
/**
 * \ingroup set
 * \related v4d
 * \brief Sets the elements of a \c v4d vector.
 * \details Sets the elements of a \c v4d vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \returns the vector
 */
v4d v4d_set(double v0, double v1, double v2, double v3);
/**
 * \ingroup set
 * \related v4f
 * \brief Sets the elements of a \c v4f vector.
 * \details Sets the elements of a \c v4f vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \returns the vector
 */
v4f v4f_set(float v0, float v1, float v2, float v3);
/**
 * \ingroup set
 * \related v4i
 * \brief Sets the elements of a \c v4i vector.
 * \details Sets the elements of a \c v4i vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \returns the vector
 */
v4i v4i_set(int32_t v0, int32_t v1, int32_t v2, int32_t v3);
/**
 * \ingroup set
 * \related v4l
 * \brief Sets the elements of a \c v4l vector.
 * \details Sets the elements of a \c v4l vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \returns the vector
 */
v4l v4l_set(int64_t v0, int64_t v1, int64_t v2, int64_t v3);
/**
 * \ingroup set
 * \related v8d
 * \brief Sets the elements of a \c v8d vector.
 * \details Sets the elements of a \c v8d vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \returns the vector
 */
v8d v8d_set(double v0, double v1, double v2, double v3, double v4, double v5, double v6, double v7);
/**
 * \ingroup set
 * \related v8f
 * \brief Sets the elements of a \c v8f vector.
 * \details Sets the elements of a \c v8f vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \returns the vector
 */
v8f v8f_set(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7);
/**
 * \ingroup set
 * \related v8i
 * \brief Sets the elements of a \c v8i vector.
 * \details Sets the elements of a \c v8i vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \returns the vector
 */
v8i v8i_set(int32_t v0, int32_t v1, int32_t v2, int32_t v3, int32_t v4, int32_t v5, int32_t v6, int32_t v7);
/**
 * \ingroup set
 * \related v8l
 * \brief Sets the elements of a \c v8l vector.
 * \details Sets the elements of a \c v8l vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \returns the vector
 */
v8l v8l_set(int64_t v0, int64_t v1, int64_t v2, int64_t v3, int64_t v4, int64_t v5, int64_t v6, int64_t v7);
/**
 * \ingroup set
 * \related v16f
 * \brief Sets the elements of a \c v16f vector.
 * \details Sets the elements of a \c v16f vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
dst[8] := v8
dst[9] := v9
dst[10] := v10
dst[11] := v11
dst[12] := v12
dst[13] := v13
dst[14] := v14
dst[15] := v15
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \param v8 the 9th element of the vector
 * \param v9 the 10th element of the vector
 * \param v10 the 11th element of the vector
 * \param v11 the 12th element of the vector
 * \param v12 the 13th element of the vector
 * \param v13 the 14th element of the vector
 * \param v14 the 15th element of the vector
 * \param v15 the 16th element of the vector
 * \returns the vector
 */
v16f v16f_set(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float v8, float v9, float v10, float v11, float v12, float v13, float v14, float v15);
/**
 * \ingroup set
 * \related v16i
 * \brief Sets the elements of a \c v16i vector.
 * \details Sets the elements of a \c v16i vector.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
dst[8] := v8
dst[9] := v9
dst[10] := v10
dst[11] := v11
dst[12] := v12
dst[13] := v13
dst[14] := v14
dst[15] := v15
\endimpl
 * \param v0 the 1nd element of the vector
 * \param v1 the 2rd element of the vector
 * \param v2 the 3th element of the vector
 * \param v3 the 4th element of the vector
 * \param v4 the 5th element of the vector
 * \param v5 the 6th element of the vector
 * \param v6 the 7th element of the vector
 * \param v7 the 8th element of the vector
 * \param v8 the 9th element of the vector
 * \param v9 the 10th element of the vector
 * \param v10 the 11th element of the vector
 * \param v11 the 12th element of the vector
 * \param v12 the 13th element of the vector
 * \param v13 the 14th element of the vector
 * \param v14 the 15th element of the vector
 * \param v15 the 16th element of the vector
 * \returns the vector
 */
v16i v16i_set(int32_t v0, int32_t v1, int32_t v2, int32_t v3, int32_t v4, int32_t v5, int32_t v6, int32_t v7, int32_t v8, int32_t v9, int32_t v10, int32_t v11, int32_t v12, int32_t v13, int32_t v14, int32_t v15);

/**
 * \ingroup set
 * \related v1d
 * \brief Sets the elements of a \c v1d vector (reverse order).
 * \details Sets the elements of a \c v1d vector in reversed order.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1d v1d_rset(double v0);
/**
 * \ingroup set
 * \related v1f
 * \brief Sets the elements of a \c v1f vector (reverse order).
 * \details Sets the elements of a \c v1f vector in reversed order.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1f v1f_rset(float v0);
/**
 * \ingroup set
 * \related v1i
 * \brief Sets the elements of a \c v1i vector (reverse order).
 * \details Sets the elements of a \c v1i vector in reversed order.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1i v1i_rset(int32_t v0);
/**
 * \ingroup set
 * \related v1l
 * \brief Sets the elements of a \c v1l vector (reverse order).
 * \details Sets the elements of a \c v1l vector in reversed order.
 * \impl
dst[0] := v0
\endimpl
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v1l v1l_rset(int64_t v0);
/**
 * \ingroup set
 * \related v2d
 * \brief Sets the elements of a \c v2d vector (reverse order).
 * \details Sets the elements of a \c v2d vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v2d v2d_rset(double v1, double v0);
/**
 * \ingroup set
 * \related v2f
 * \brief Sets the elements of a \c v2f vector (reverse order).
 * \details Sets the elements of a \c v2f vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v2f v2f_rset(float v1, float v0);
/**
 * \ingroup set
 * \related v2i
 * \brief Sets the elements of a \c v2i vector (reverse order).
 * \details Sets the elements of a \c v2i vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v2i v2i_rset(int32_t v1, int32_t v0);
/**
 * \ingroup set
 * \related v2l
 * \brief Sets the elements of a \c v2l vector (reverse order).
 * \details Sets the elements of a \c v2l vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
\endimpl
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v2l v2l_rset(int64_t v1, int64_t v0);
/**
 * \ingroup set
 * \related v4d
 * \brief Sets the elements of a \c v4d vector (reverse order).
 * \details Sets the elements of a \c v4d vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v4d v4d_rset(double v3, double v2, double v1, double v0);
/**
 * \ingroup set
 * \related v4f
 * \brief Sets the elements of a \c v4f vector (reverse order).
 * \details Sets the elements of a \c v4f vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v4f v4f_rset(float v3, float v2, float v1, float v0);
/**
 * \ingroup set
 * \related v4i
 * \brief Sets the elements of a \c v4i vector (reverse order).
 * \details Sets the elements of a \c v4i vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v4i v4i_rset(int32_t v3, int32_t v2, int32_t v1, int32_t v0);
/**
 * \ingroup set
 * \related v4l
 * \brief Sets the elements of a \c v4l vector (reverse order).
 * \details Sets the elements of a \c v4l vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
\endimpl
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v4l v4l_rset(int64_t v3, int64_t v2, int64_t v1, int64_t v0);
/**
 * \ingroup set
 * \related v8d
 * \brief Sets the elements of a \c v8d vector (reverse order).
 * \details Sets the elements of a \c v8d vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v8d v8d_rset(double v7, double v6, double v5, double v4, double v3, double v2, double v1, double v0);
/**
 * \ingroup set
 * \related v8f
 * \brief Sets the elements of a \c v8f vector (reverse order).
 * \details Sets the elements of a \c v8f vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v8f v8f_rset(float v7, float v6, float v5, float v4, float v3, float v2, float v1, float v0);
/**
 * \ingroup set
 * \related v8i
 * \brief Sets the elements of a \c v8i vector (reverse order).
 * \details Sets the elements of a \c v8i vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v8i v8i_rset(int32_t v7, int32_t v6, int32_t v5, int32_t v4, int32_t v3, int32_t v2, int32_t v1, int32_t v0);
/**
 * \ingroup set
 * \related v8l
 * \brief Sets the elements of a \c v8l vector (reverse order).
 * \details Sets the elements of a \c v8l vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
\endimpl
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v8l v8l_rset(int64_t v7, int64_t v6, int64_t v5, int64_t v4, int64_t v3, int64_t v2, int64_t v1, int64_t v0);
/**
 * \ingroup set
 * \related v16f
 * \brief Sets the elements of a \c v16f vector (reverse order).
 * \details Sets the elements of a \c v16f vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
dst[8] := v8
dst[9] := v9
dst[10] := v10
dst[11] := v11
dst[12] := v12
dst[13] := v13
dst[14] := v14
dst[15] := v15
\endimpl
 * \param v15 the 16th element of the vector
 * \param v14 the 15th element of the vector
 * \param v13 the 14th element of the vector
 * \param v12 the 13th element of the vector
 * \param v11 the 12th element of the vector
 * \param v10 the 11th element of the vector
 * \param v9 the 10th element of the vector
 * \param v8 the 9th element of the vector
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v16f v16f_rset(float v15, float v14, float v13, float v12, float v11, float v10, float v9, float v8, float v7, float v6, float v5, float v4, float v3, float v2, float v1, float v0);
/**
 * \ingroup set
 * \related v16i
 * \brief Sets the elements of a \c v16i vector (reverse order).
 * \details Sets the elements of a \c v16i vector in reversed order.
 * \impl
dst[0] := v0
dst[1] := v1
dst[2] := v2
dst[3] := v3
dst[4] := v4
dst[5] := v5
dst[6] := v6
dst[7] := v7
dst[8] := v8
dst[9] := v9
dst[10] := v10
dst[11] := v11
dst[12] := v12
dst[13] := v13
dst[14] := v14
dst[15] := v15
\endimpl
 * \param v15 the 16th element of the vector
 * \param v14 the 15th element of the vector
 * \param v13 the 14th element of the vector
 * \param v12 the 13th element of the vector
 * \param v11 the 12th element of the vector
 * \param v10 the 11th element of the vector
 * \param v9 the 10th element of the vector
 * \param v8 the 9th element of the vector
 * \param v7 the 8th element of the vector
 * \param v6 the 7th element of the vector
 * \param v5 the 6th element of the vector
 * \param v4 the 5th element of the vector
 * \param v3 the 4th element of the vector
 * \param v2 the 3th element of the vector
 * \param v1 the 2rd element of the vector
 * \param v0 the 1nd element of the vector
 * \returns the vector
 */
v16i v16i_rset(int32_t v15, int32_t v14, int32_t v13, int32_t v12, int32_t v11, int32_t v10, int32_t v9, int32_t v8, int32_t v7, int32_t v6, int32_t v5, int32_t v4, int32_t v3, int32_t v2, int32_t v1, int32_t v0);

/**
 * \ingroup set
 * \related v1d
 * \brief Broadcasts a single value into all elements of a \c v1d vector.
 * \details Broadcasts a single value into all elements of a \c v1d vector.
 * \impl
for i from 0 to 0
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v1d v1d_set1(double v);
/**
 * \ingroup set
 * \related v1f
 * \brief Broadcasts a single value into all elements of a \c v1f vector.
 * \details Broadcasts a single value into all elements of a \c v1f vector.
 * \impl
for i from 0 to 0
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v1f v1f_set1(float v);
/**
 * \ingroup set
 * \related v1i
 * \brief Broadcasts a single value into all elements of a \c v1i vector.
 * \details Broadcasts a single value into all elements of a \c v1i vector.
 * \impl
for i from 0 to 0
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v1i v1i_set1(int32_t v);
/**
 * \ingroup set
 * \related v1l
 * \brief Broadcasts a single value into all elements of a \c v1l vector.
 * \details Broadcasts a single value into all elements of a \c v1l vector.
 * \impl
for i from 0 to 0
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v1l v1l_set1(int64_t v);
/**
 * \ingroup set
 * \related v2d
 * \brief Broadcasts a single value into all elements of a \c v2d vector.
 * \details Broadcasts a single value into all elements of a \c v2d vector.
 * \impl
for i from 0 to 1
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v2d v2d_set1(double v);
/**
 * \ingroup set
 * \related v2f
 * \brief Broadcasts a single value into all elements of a \c v2f vector.
 * \details Broadcasts a single value into all elements of a \c v2f vector.
 * \impl
for i from 0 to 1
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v2f v2f_set1(float v);
/**
 * \ingroup set
 * \related v2i
 * \brief Broadcasts a single value into all elements of a \c v2i vector.
 * \details Broadcasts a single value into all elements of a \c v2i vector.
 * \impl
for i from 0 to 1
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v2i v2i_set1(int32_t v);
/**
 * \ingroup set
 * \related v2l
 * \brief Broadcasts a single value into all elements of a \c v2l vector.
 * \details Broadcasts a single value into all elements of a \c v2l vector.
 * \impl
for i from 0 to 1
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v2l v2l_set1(int64_t v);
/**
 * \ingroup set
 * \related v4d
 * \brief Broadcasts a single value into all elements of a \c v4d vector.
 * \details Broadcasts a single value into all elements of a \c v4d vector.
 * \impl
for i from 0 to 3
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v4d v4d_set1(double v);
/**
 * \ingroup set
 * \related v4f
 * \brief Broadcasts a single value into all elements of a \c v4f vector.
 * \details Broadcasts a single value into all elements of a \c v4f vector.
 * \impl
for i from 0 to 3
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v4f v4f_set1(float v);
/**
 * \ingroup set
 * \related v4i
 * \brief Broadcasts a single value into all elements of a \c v4i vector.
 * \details Broadcasts a single value into all elements of a \c v4i vector.
 * \impl
for i from 0 to 3
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v4i v4i_set1(int32_t v);
/**
 * \ingroup set
 * \related v4l
 * \brief Broadcasts a single value into all elements of a \c v4l vector.
 * \details Broadcasts a single value into all elements of a \c v4l vector.
 * \impl
for i from 0 to 3
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v4l v4l_set1(int64_t v);
/**
 * \ingroup set
 * \related v8d
 * \brief Broadcasts a single value into all elements of a \c v8d vector.
 * \details Broadcasts a single value into all elements of a \c v8d vector.
 * \impl
for i from 0 to 7
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v8d v8d_set1(double v);
/**
 * \ingroup set
 * \related v8f
 * \brief Broadcasts a single value into all elements of a \c v8f vector.
 * \details Broadcasts a single value into all elements of a \c v8f vector.
 * \impl
for i from 0 to 7
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v8f v8f_set1(float v);
/**
 * \ingroup set
 * \related v8i
 * \brief Broadcasts a single value into all elements of a \c v8i vector.
 * \details Broadcasts a single value into all elements of a \c v8i vector.
 * \impl
for i from 0 to 7
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v8i v8i_set1(int32_t v);
/**
 * \ingroup set
 * \related v8l
 * \brief Broadcasts a single value into all elements of a \c v8l vector.
 * \details Broadcasts a single value into all elements of a \c v8l vector.
 * \impl
for i from 0 to 7
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v8l v8l_set1(int64_t v);
/**
 * \ingroup set
 * \related v16f
 * \brief Broadcasts a single value into all elements of a \c v16f vector.
 * \details Broadcasts a single value into all elements of a \c v16f vector.
 * \impl
for i from 0 to 15
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v16f v16f_set1(float v);
/**
 * \ingroup set
 * \related v16i
 * \brief Broadcasts a single value into all elements of a \c v16i vector.
 * \details Broadcasts a single value into all elements of a \c v16i vector.
 * \impl
for i from 0 to 15
  dst[i] := v
endfor
\endimpl
 * \param v scalar to broadcast
 * \returns the vector
 */
v16i v16i_set1(int32_t v);

/* CONSTANTS */
/**
 * \ingroup set
 * \related v1d
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:63] := 0
\endimpl
 * \returns v1d vector with all bits to 0
 */
v1d v1d_zeros();
/**
 * \ingroup set
 * \related v1f
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:31] := 0
\endimpl
 * \returns v1f vector with all bits to 0
 */
v1f v1f_zeros();
/**
 * \ingroup set
 * \related v1i
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:31] := 0
\endimpl
 * \returns v1i vector with all bits to 0
 */
v1i v1i_zeros();
/**
 * \ingroup set
 * \related v1l
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:63] := 0
\endimpl
 * \returns v1l vector with all bits to 0
 */
v1l v1l_zeros();
/**
 * \ingroup set
 * \related v2d
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:127] := 0
\endimpl
 * \returns v2d vector with all bits to 0
 */
v2d v2d_zeros();
/**
 * \ingroup set
 * \related v2f
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:63] := 0
\endimpl
 * \returns v2f vector with all bits to 0
 */
v2f v2f_zeros();
/**
 * \ingroup set
 * \related v2i
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:63] := 0
\endimpl
 * \returns v2i vector with all bits to 0
 */
v2i v2i_zeros();
/**
 * \ingroup set
 * \related v2l
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:127] := 0
\endimpl
 * \returns v2l vector with all bits to 0
 */
v2l v2l_zeros();
/**
 * \ingroup set
 * \related v4d
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:255] := 0
\endimpl
 * \returns v4d vector with all bits to 0
 */
v4d v4d_zeros();
/**
 * \ingroup set
 * \related v4f
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:127] := 0
\endimpl
 * \returns v4f vector with all bits to 0
 */
v4f v4f_zeros();
/**
 * \ingroup set
 * \related v4i
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:127] := 0
\endimpl
 * \returns v4i vector with all bits to 0
 */
v4i v4i_zeros();
/**
 * \ingroup set
 * \related v4l
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:255] := 0
\endimpl
 * \returns v4l vector with all bits to 0
 */
v4l v4l_zeros();
/**
 * \ingroup set
 * \related v8d
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:511] := 0
\endimpl
 * \returns v8d vector with all bits to 0
 */
v8d v8d_zeros();
/**
 * \ingroup set
 * \related v8f
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:255] := 0
\endimpl
 * \returns v8f vector with all bits to 0
 */
v8f v8f_zeros();
/**
 * \ingroup set
 * \related v8i
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:255] := 0
\endimpl
 * \returns v8i vector with all bits to 0
 */
v8i v8i_zeros();
/**
 * \ingroup set
 * \related v8l
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:511] := 0
\endimpl
 * \returns v8l vector with all bits to 0
 */
v8l v8l_zeros();
/**
 * \ingroup set
 * \related v16f
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:511] := 0
\endimpl
 * \returns v16f vector with all bits to 0
 */
v16f v16f_zeros();
/**
 * \ingroup set
 * \related v16i
 * \brief Sets all bits to 0.
 * \details Sets all bits to 0.
 * \impl
dst.bits[0:511] := 0
\endimpl
 * \returns v16i vector with all bits to 0
 */
v16i v16i_zeros();
/**
 * \ingroup set
 * \related v1d
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:63] := 0xFFFFFFFFFFFFFFFF
\endimpl
 * \returns v1d vector with all bits to 1
 */
v1d v1d_ones();
/**
 * \ingroup set
 * \related v1f
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:31] := 0xFFFFFFFF
\endimpl
 * \returns v1f vector with all bits to 1
 */
v1f v1f_ones();
/**
 * \ingroup set
 * \related v1i
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:31] := 0xFFFFFFFF
\endimpl
 * \returns v1i vector with all bits to 1
 */
v1i v1i_ones();
/**
 * \ingroup set
 * \related v1l
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:63] := 0xFFFFFFFFFFFFFFFF
\endimpl
 * \returns v1l vector with all bits to 1
 */
v1l v1l_ones();
/**
 * \ingroup set
 * \related v2d
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:127] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v2d vector with all bits to 1
 */
v2d v2d_ones();
/**
 * \ingroup set
 * \related v2f
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:63] := 0xFFFFFFFFFFFFFFFF
\endimpl
 * \returns v2f vector with all bits to 1
 */
v2f v2f_ones();
/**
 * \ingroup set
 * \related v2i
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:63] := 0xFFFFFFFFFFFFFFFF
\endimpl
 * \returns v2i vector with all bits to 1
 */
v2i v2i_ones();
/**
 * \ingroup set
 * \related v2l
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:127] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v2l vector with all bits to 1
 */
v2l v2l_ones();
/**
 * \ingroup set
 * \related v4d
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:255] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v4d vector with all bits to 1
 */
v4d v4d_ones();
/**
 * \ingroup set
 * \related v4f
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:127] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v4f vector with all bits to 1
 */
v4f v4f_ones();
/**
 * \ingroup set
 * \related v4i
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:127] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v4i vector with all bits to 1
 */
v4i v4i_ones();
/**
 * \ingroup set
 * \related v4l
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:255] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v4l vector with all bits to 1
 */
v4l v4l_ones();
/**
 * \ingroup set
 * \related v8d
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:511] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v8d vector with all bits to 1
 */
v8d v8d_ones();
/**
 * \ingroup set
 * \related v8f
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:255] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v8f vector with all bits to 1
 */
v8f v8f_ones();
/**
 * \ingroup set
 * \related v8i
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:255] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v8i vector with all bits to 1
 */
v8i v8i_ones();
/**
 * \ingroup set
 * \related v8l
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:511] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v8l vector with all bits to 1
 */
v8l v8l_ones();
/**
 * \ingroup set
 * \related v16f
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:511] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v16f vector with all bits to 1
 */
v16f v16f_ones();
/**
 * \ingroup set
 * \related v16i
 * \brief Sets all bits to 1.
 * \details Sets all bits to 1.
 * \impl
dst.bits[0:511] := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\endimpl
 * \returns v16i vector with all bits to 1
 */
v16i v16i_ones();
/**
 * \ingroup set
 * \related v1d
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 0
  dst[i] := double(0)
endfor
\endimpl
 * \returns v1d vector with all elements to 0
 */
v1d v1d_zero();
/**
 * \ingroup set
 * \related v1f
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 0
  dst[i] := float(0)
endfor
\endimpl
 * \returns v1f vector with all elements to 0
 */
v1f v1f_zero();
/**
 * \ingroup set
 * \related v1i
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 0
  dst[i] := int32_t(0)
endfor
\endimpl
 * \returns v1i vector with all elements to 0
 */
v1i v1i_zero();
/**
 * \ingroup set
 * \related v1l
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 0
  dst[i] := int64_t(0)
endfor
\endimpl
 * \returns v1l vector with all elements to 0
 */
v1l v1l_zero();
/**
 * \ingroup set
 * \related v2d
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 1
  dst[i] := double(0)
endfor
\endimpl
 * \returns v2d vector with all elements to 0
 */
v2d v2d_zero();
/**
 * \ingroup set
 * \related v2f
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 1
  dst[i] := float(0)
endfor
\endimpl
 * \returns v2f vector with all elements to 0
 */
v2f v2f_zero();
/**
 * \ingroup set
 * \related v2i
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 1
  dst[i] := int32_t(0)
endfor
\endimpl
 * \returns v2i vector with all elements to 0
 */
v2i v2i_zero();
/**
 * \ingroup set
 * \related v2l
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 1
  dst[i] := int64_t(0)
endfor
\endimpl
 * \returns v2l vector with all elements to 0
 */
v2l v2l_zero();
/**
 * \ingroup set
 * \related v4d
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 3
  dst[i] := double(0)
endfor
\endimpl
 * \returns v4d vector with all elements to 0
 */
v4d v4d_zero();
/**
 * \ingroup set
 * \related v4f
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 3
  dst[i] := float(0)
endfor
\endimpl
 * \returns v4f vector with all elements to 0
 */
v4f v4f_zero();
/**
 * \ingroup set
 * \related v4i
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 3
  dst[i] := int32_t(0)
endfor
\endimpl
 * \returns v4i vector with all elements to 0
 */
v4i v4i_zero();
/**
 * \ingroup set
 * \related v4l
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 3
  dst[i] := int64_t(0)
endfor
\endimpl
 * \returns v4l vector with all elements to 0
 */
v4l v4l_zero();
/**
 * \ingroup set
 * \related v8d
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 7
  dst[i] := double(0)
endfor
\endimpl
 * \returns v8d vector with all elements to 0
 */
v8d v8d_zero();
/**
 * \ingroup set
 * \related v8f
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 7
  dst[i] := float(0)
endfor
\endimpl
 * \returns v8f vector with all elements to 0
 */
v8f v8f_zero();
/**
 * \ingroup set
 * \related v8i
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 7
  dst[i] := int32_t(0)
endfor
\endimpl
 * \returns v8i vector with all elements to 0
 */
v8i v8i_zero();
/**
 * \ingroup set
 * \related v8l
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 7
  dst[i] := int64_t(0)
endfor
\endimpl
 * \returns v8l vector with all elements to 0
 */
v8l v8l_zero();
/**
 * \ingroup set
 * \related v16f
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 15
  dst[i] := float(0)
endfor
\endimpl
 * \returns v16f vector with all elements to 0
 */
v16f v16f_zero();
/**
 * \ingroup set
 * \related v16i
 * \brief Sets all elements to 0.
 * \details Sets all elements to 0.
 * \impl
for i from 0 to 15
  dst[i] := int32_t(0)
endfor
\endimpl
 * \returns v16i vector with all elements to 0
 */
v16i v16i_zero();
/**
 * \ingroup set
 * \related v1d
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 0
  dst[i] := double(1)
endfor
\endimpl
 * \returns v1d vector with all elements to 1
 */
v1d v1d_one();
/**
 * \ingroup set
 * \related v1f
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 0
  dst[i] := float(1)
endfor
\endimpl
 * \returns v1f vector with all elements to 1
 */
v1f v1f_one();
/**
 * \ingroup set
 * \related v1i
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 0
  dst[i] := int32_t(1)
endfor
\endimpl
 * \returns v1i vector with all elements to 1
 */
v1i v1i_one();
/**
 * \ingroup set
 * \related v1l
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 0
  dst[i] := int64_t(1)
endfor
\endimpl
 * \returns v1l vector with all elements to 1
 */
v1l v1l_one();
/**
 * \ingroup set
 * \related v2d
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 1
  dst[i] := double(1)
endfor
\endimpl
 * \returns v2d vector with all elements to 1
 */
v2d v2d_one();
/**
 * \ingroup set
 * \related v2f
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 1
  dst[i] := float(1)
endfor
\endimpl
 * \returns v2f vector with all elements to 1
 */
v2f v2f_one();
/**
 * \ingroup set
 * \related v2i
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 1
  dst[i] := int32_t(1)
endfor
\endimpl
 * \returns v2i vector with all elements to 1
 */
v2i v2i_one();
/**
 * \ingroup set
 * \related v2l
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 1
  dst[i] := int64_t(1)
endfor
\endimpl
 * \returns v2l vector with all elements to 1
 */
v2l v2l_one();
/**
 * \ingroup set
 * \related v4d
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 3
  dst[i] := double(1)
endfor
\endimpl
 * \returns v4d vector with all elements to 1
 */
v4d v4d_one();
/**
 * \ingroup set
 * \related v4f
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 3
  dst[i] := float(1)
endfor
\endimpl
 * \returns v4f vector with all elements to 1
 */
v4f v4f_one();
/**
 * \ingroup set
 * \related v4i
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 3
  dst[i] := int32_t(1)
endfor
\endimpl
 * \returns v4i vector with all elements to 1
 */
v4i v4i_one();
/**
 * \ingroup set
 * \related v4l
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 3
  dst[i] := int64_t(1)
endfor
\endimpl
 * \returns v4l vector with all elements to 1
 */
v4l v4l_one();
/**
 * \ingroup set
 * \related v8d
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 7
  dst[i] := double(1)
endfor
\endimpl
 * \returns v8d vector with all elements to 1
 */
v8d v8d_one();
/**
 * \ingroup set
 * \related v8f
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 7
  dst[i] := float(1)
endfor
\endimpl
 * \returns v8f vector with all elements to 1
 */
v8f v8f_one();
/**
 * \ingroup set
 * \related v8i
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 7
  dst[i] := int32_t(1)
endfor
\endimpl
 * \returns v8i vector with all elements to 1
 */
v8i v8i_one();
/**
 * \ingroup set
 * \related v8l
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 7
  dst[i] := int64_t(1)
endfor
\endimpl
 * \returns v8l vector with all elements to 1
 */
v8l v8l_one();
/**
 * \ingroup set
 * \related v16f
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 15
  dst[i] := float(1)
endfor
\endimpl
 * \returns v16f vector with all elements to 1
 */
v16f v16f_one();
/**
 * \ingroup set
 * \related v16i
 * \brief Sets all elements to 1.
 * \details Sets all elements to 1.
 * \impl
for i from 0 to 15
  dst[i] := int32_t(1)
endfor
\endimpl
 * \returns v16i vector with all elements to 1
 */
v16i v16i_one();


/* COMPARISONS */
/** \defgroup mcmp comparison to mask functions
 * \ingroup maskop
 * 
 */

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1d vectors \c a and \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 0
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_eq(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1f vectors \c a and \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 0
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_eq(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1i vectors \c a and \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 0
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_eq(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1l vectors \c a and \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 0
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_eq(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2d vectors \c a and \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 1
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_eq(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2f vectors \c a and \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 1
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_eq(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2i vectors \c a and \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 1
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_eq(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2l vectors \c a and \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 1
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_eq(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4d vectors \c a and \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 3
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_eq(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4f vectors \c a and \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 3
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_eq(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4i vectors \c a and \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 3
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_eq(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4l vectors \c a and \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 3
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_eq(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8d vectors \c a and \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 7
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_eq(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8f vectors \c a and \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 7
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_eq(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8i vectors \c a and \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 7
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_eq(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8l vectors \c a and \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 7
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_eq(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v16f vectors \c a and \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 15
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_eq(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v16i vectors \c a and \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] == b[i]`.
 * \impl
for i from 0 to 15
  if a[i] == b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_eq(v16i a, v16i b);

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1d vectors \c a and \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 0
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_neq(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1f vectors \c a and \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 0
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_neq(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1i vectors \c a and \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 0
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_neq(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1l vectors \c a and \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 0
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_neq(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2d vectors \c a and \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 1
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_neq(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2f vectors \c a and \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 1
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_neq(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2i vectors \c a and \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 1
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_neq(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2l vectors \c a and \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 1
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_neq(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4d vectors \c a and \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 3
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_neq(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4f vectors \c a and \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 3
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_neq(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4i vectors \c a and \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 3
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_neq(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4l vectors \c a and \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 3
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_neq(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8d vectors \c a and \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 7
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_neq(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8f vectors \c a and \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 7
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_neq(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8i vectors \c a and \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 7
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_neq(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8l vectors \c a and \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 7
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_neq(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v16f vectors \c a and \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 15
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_neq(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v16i vectors \c a and \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] != b[i]`.
 * \impl
for i from 0 to 15
  if a[i] != b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_neq(v16i a, v16i b);

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_gt(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_gt(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_gt(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_gt(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_gt(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_gt(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_gt(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_gt(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_gt(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_gt(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_gt(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_gt(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_gt(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_gt(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_gt(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_gt(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 15
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_gt(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] > b[i]`.
 * \impl
for i from 0 to 15
  if a[i] > b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_gt(v16i a, v16i b);

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_geq(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_geq(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_geq(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_geq(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_geq(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_geq(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_geq(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_geq(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_geq(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_geq(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_geq(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_geq(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_geq(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_geq(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_geq(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_geq(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 15
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_geq(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] >= b[i]`.
 * \impl
for i from 0 to 15
  if a[i] >= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_geq(v16i a, v16i b);

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_lt(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_lt(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_lt(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_lt(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_lt(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_lt(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_lt(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_lt(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_lt(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_lt(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_lt(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_lt(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_lt(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_lt(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_lt(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_lt(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 15
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_lt(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] < b[i]`.
 * \impl
for i from 0 to 15
  if a[i] < b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_lt(v16i a, v16i b);

/**
 * \ingroup mcmp
 * \related v1d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m1d vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
m1d m1d_leq(v1d a, v1d b);
/**
 * \ingroup mcmp
 * \related v1f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m1f vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
m1f m1f_leq(v1f a, v1f b);
/**
 * \ingroup mcmp
 * \related v1i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m1i vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
m1i m1i_leq(v1i a, v1i b);
/**
 * \ingroup mcmp
 * \related v1l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m1l vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 0
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
m1l m1l_leq(v1l a, v1l b);
/**
 * \ingroup mcmp
 * \related v2d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m2d vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
m2d m2d_leq(v2d a, v2d b);
/**
 * \ingroup mcmp
 * \related v2f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m2f vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
m2f m2f_leq(v2f a, v2f b);
/**
 * \ingroup mcmp
 * \related v2i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m2i vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
m2i m2i_leq(v2i a, v2i b);
/**
 * \ingroup mcmp
 * \related v2l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m2l vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 1
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
m2l m2l_leq(v2l a, v2l b);
/**
 * \ingroup mcmp
 * \related v4d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m4d vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
m4d m4d_leq(v4d a, v4d b);
/**
 * \ingroup mcmp
 * \related v4f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m4f vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
m4f m4f_leq(v4f a, v4f b);
/**
 * \ingroup mcmp
 * \related v4i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m4i vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
m4i m4i_leq(v4i a, v4i b);
/**
 * \ingroup mcmp
 * \related v4l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m4l vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 3
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
m4l m4l_leq(v4l a, v4l b);
/**
 * \ingroup mcmp
 * \related v8d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m8d vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
m8d m8d_leq(v8d a, v8d b);
/**
 * \ingroup mcmp
 * \related v8f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m8f vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
m8f m8f_leq(v8f a, v8f b);
/**
 * \ingroup mcmp
 * \related v8i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m8i vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
m8i m8i_leq(v8i a, v8i b);
/**
 * \ingroup mcmp
 * \related v8l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m8l vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 7
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
m8l m8l_leq(v8l a, v8l b);
/**
 * \ingroup mcmp
 * \related v16f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m16f vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 15
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
m16f m16f_leq(v16f a, v16f b);
/**
 * \ingroup mcmp
 * \related v16i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c m16i vector-mask where the ith element is set iif \c `a[i] <= b[i]`.
 * \impl
for i from 0 to 15
  if a[i] <= b[i]
    dst[i] := 1
  else
    dst[i] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
m16i m16i_leq(v16i a, v16i b);


/* LOGIC */
/** \defgroup mlogic logical mask functions
 * \ingroup maskop
 * 
 */

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m1d input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] & b[0]
\endimpl
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise and"ed \c m1d vector-mask
 */
m1d m1d_and(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m1f input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] & b[0]
\endimpl
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise and"ed \c m1f vector-mask
 */
m1f m1f_and(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m1i input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] & b[0]
\endimpl
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise and"ed \c m1i vector-mask
 */
m1i m1i_and(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m1l input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] & b[0]
\endimpl
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise and"ed \c m1l vector-mask
 */
m1l m1l_and(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m2d input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] & b[0:1]
\endimpl
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise and"ed \c m2d vector-mask
 */
m2d m2d_and(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m2f input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] & b[0:1]
\endimpl
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise and"ed \c m2f vector-mask
 */
m2f m2f_and(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m2i input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] & b[0:1]
\endimpl
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise and"ed \c m2i vector-mask
 */
m2i m2i_and(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m2l input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] & b[0:1]
\endimpl
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise and"ed \c m2l vector-mask
 */
m2l m2l_and(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m4d input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] & b[0:3]
\endimpl
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise and"ed \c m4d vector-mask
 */
m4d m4d_and(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m4f input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] & b[0:3]
\endimpl
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise and"ed \c m4f vector-mask
 */
m4f m4f_and(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m4i input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] & b[0:3]
\endimpl
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise and"ed \c m4i vector-mask
 */
m4i m4i_and(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m4l input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] & b[0:3]
\endimpl
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise and"ed \c m4l vector-mask
 */
m4l m4l_and(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m8d input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] & b[0:7]
\endimpl
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise and"ed \c m8d vector-mask
 */
m8d m8d_and(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m8f input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] & b[0:7]
\endimpl
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise and"ed \c m8f vector-mask
 */
m8f m8f_and(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m8i input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] & b[0:7]
\endimpl
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise and"ed \c m8i vector-mask
 */
m8i m8i_and(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m8l input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] & b[0:7]
\endimpl
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise and"ed \c m8l vector-mask
 */
m8l m8l_and(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m16f input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] & b[0:15]
\endimpl
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise and"ed \c m16f vector-mask
 */
m16f m16f_and(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c m16i input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] & b[0:15]
\endimpl
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise and"ed \c m16i vector-mask
 */
m16i m16i_and(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m1d input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] | b[0]
\endimpl
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise or"ed \c m1d vector-mask
 */
m1d m1d_or(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m1f input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] | b[0]
\endimpl
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise or"ed \c m1f vector-mask
 */
m1f m1f_or(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m1i input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] | b[0]
\endimpl
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise or"ed \c m1i vector-mask
 */
m1i m1i_or(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m1l input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] | b[0]
\endimpl
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise or"ed \c m1l vector-mask
 */
m1l m1l_or(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m2d input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] | b[0:1]
\endimpl
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise or"ed \c m2d vector-mask
 */
m2d m2d_or(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m2f input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] | b[0:1]
\endimpl
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise or"ed \c m2f vector-mask
 */
m2f m2f_or(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m2i input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] | b[0:1]
\endimpl
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise or"ed \c m2i vector-mask
 */
m2i m2i_or(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m2l input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] | b[0:1]
\endimpl
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise or"ed \c m2l vector-mask
 */
m2l m2l_or(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m4d input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] | b[0:3]
\endimpl
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise or"ed \c m4d vector-mask
 */
m4d m4d_or(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m4f input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] | b[0:3]
\endimpl
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise or"ed \c m4f vector-mask
 */
m4f m4f_or(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m4i input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] | b[0:3]
\endimpl
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise or"ed \c m4i vector-mask
 */
m4i m4i_or(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m4l input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] | b[0:3]
\endimpl
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise or"ed \c m4l vector-mask
 */
m4l m4l_or(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m8d input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] | b[0:7]
\endimpl
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise or"ed \c m8d vector-mask
 */
m8d m8d_or(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m8f input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] | b[0:7]
\endimpl
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise or"ed \c m8f vector-mask
 */
m8f m8f_or(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m8i input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] | b[0:7]
\endimpl
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise or"ed \c m8i vector-mask
 */
m8i m8i_or(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m8l input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] | b[0:7]
\endimpl
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise or"ed \c m8l vector-mask
 */
m8l m8l_or(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m16f input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] | b[0:15]
\endimpl
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise or"ed \c m16f vector-mask
 */
m16f m16f_or(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c m16i input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] | b[0:15]
\endimpl
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise or"ed \c m16i vector-mask
 */
m16i m16i_or(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m1d input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] ^ b[0]
\endimpl
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise xor"ed \c m1d vector-mask
 */
m1d m1d_xor(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m1f input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] ^ b[0]
\endimpl
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise xor"ed \c m1f vector-mask
 */
m1f m1f_xor(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m1i input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] ^ b[0]
\endimpl
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise xor"ed \c m1i vector-mask
 */
m1i m1i_xor(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m1l input vector-masks \c a and \c b.
 * \impl
dst[0] = a[0] ^ b[0]
\endimpl
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise xor"ed \c m1l vector-mask
 */
m1l m1l_xor(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m2d input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] ^ b[0:1]
\endimpl
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise xor"ed \c m2d vector-mask
 */
m2d m2d_xor(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m2f input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] ^ b[0:1]
\endimpl
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise xor"ed \c m2f vector-mask
 */
m2f m2f_xor(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m2i input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] ^ b[0:1]
\endimpl
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise xor"ed \c m2i vector-mask
 */
m2i m2i_xor(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m2l input vector-masks \c a and \c b.
 * \impl
dst[0:1] = a[0:1] ^ b[0:1]
\endimpl
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise xor"ed \c m2l vector-mask
 */
m2l m2l_xor(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m4d input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] ^ b[0:3]
\endimpl
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise xor"ed \c m4d vector-mask
 */
m4d m4d_xor(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m4f input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] ^ b[0:3]
\endimpl
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise xor"ed \c m4f vector-mask
 */
m4f m4f_xor(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m4i input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] ^ b[0:3]
\endimpl
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise xor"ed \c m4i vector-mask
 */
m4i m4i_xor(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m4l input vector-masks \c a and \c b.
 * \impl
dst[0:3] = a[0:3] ^ b[0:3]
\endimpl
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise xor"ed \c m4l vector-mask
 */
m4l m4l_xor(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m8d input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] ^ b[0:7]
\endimpl
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise xor"ed \c m8d vector-mask
 */
m8d m8d_xor(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m8f input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] ^ b[0:7]
\endimpl
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise xor"ed \c m8f vector-mask
 */
m8f m8f_xor(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m8i input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] ^ b[0:7]
\endimpl
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise xor"ed \c m8i vector-mask
 */
m8i m8i_xor(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m8l input vector-masks \c a and \c b.
 * \impl
dst[0:7] = a[0:7] ^ b[0:7]
\endimpl
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise xor"ed \c m8l vector-mask
 */
m8l m8l_xor(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m16f input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] ^ b[0:15]
\endimpl
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise xor"ed \c m16f vector-mask
 */
m16f m16f_xor(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c m16i input vector-masks \c a and \c b.
 * \impl
dst[0:15] = a[0:15] ^ b[0:15]
\endimpl
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise xor"ed \c m16i vector-mask
 */
m16i m16i_xor(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m1d input vector-mask \c a.
 * \impl
dst[0] = ~a[0]
\endimpl
 * \param a \c m1d input vector-mask
 * \returns "bitwise not"ed \c m1d vector-mask
 */
m1d m1d_not(m1d a);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m1f input vector-mask \c a.
 * \impl
dst[0] = ~a[0]
\endimpl
 * \param a \c m1f input vector-mask
 * \returns "bitwise not"ed \c m1f vector-mask
 */
m1f m1f_not(m1f a);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m1i input vector-mask \c a.
 * \impl
dst[0] = ~a[0]
\endimpl
 * \param a \c m1i input vector-mask
 * \returns "bitwise not"ed \c m1i vector-mask
 */
m1i m1i_not(m1i a);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m1l input vector-mask \c a.
 * \impl
dst[0] = ~a[0]
\endimpl
 * \param a \c m1l input vector-mask
 * \returns "bitwise not"ed \c m1l vector-mask
 */
m1l m1l_not(m1l a);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m2d input vector-mask \c a.
 * \impl
dst[0:1] = ~a[0:1]
\endimpl
 * \param a \c m2d input vector-mask
 * \returns "bitwise not"ed \c m2d vector-mask
 */
m2d m2d_not(m2d a);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m2f input vector-mask \c a.
 * \impl
dst[0:1] = ~a[0:1]
\endimpl
 * \param a \c m2f input vector-mask
 * \returns "bitwise not"ed \c m2f vector-mask
 */
m2f m2f_not(m2f a);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m2i input vector-mask \c a.
 * \impl
dst[0:1] = ~a[0:1]
\endimpl
 * \param a \c m2i input vector-mask
 * \returns "bitwise not"ed \c m2i vector-mask
 */
m2i m2i_not(m2i a);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m2l input vector-mask \c a.
 * \impl
dst[0:1] = ~a[0:1]
\endimpl
 * \param a \c m2l input vector-mask
 * \returns "bitwise not"ed \c m2l vector-mask
 */
m2l m2l_not(m2l a);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m4d input vector-mask \c a.
 * \impl
dst[0:3] = ~a[0:3]
\endimpl
 * \param a \c m4d input vector-mask
 * \returns "bitwise not"ed \c m4d vector-mask
 */
m4d m4d_not(m4d a);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m4f input vector-mask \c a.
 * \impl
dst[0:3] = ~a[0:3]
\endimpl
 * \param a \c m4f input vector-mask
 * \returns "bitwise not"ed \c m4f vector-mask
 */
m4f m4f_not(m4f a);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m4i input vector-mask \c a.
 * \impl
dst[0:3] = ~a[0:3]
\endimpl
 * \param a \c m4i input vector-mask
 * \returns "bitwise not"ed \c m4i vector-mask
 */
m4i m4i_not(m4i a);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m4l input vector-mask \c a.
 * \impl
dst[0:3] = ~a[0:3]
\endimpl
 * \param a \c m4l input vector-mask
 * \returns "bitwise not"ed \c m4l vector-mask
 */
m4l m4l_not(m4l a);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m8d input vector-mask \c a.
 * \impl
dst[0:7] = ~a[0:7]
\endimpl
 * \param a \c m8d input vector-mask
 * \returns "bitwise not"ed \c m8d vector-mask
 */
m8d m8d_not(m8d a);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m8f input vector-mask \c a.
 * \impl
dst[0:7] = ~a[0:7]
\endimpl
 * \param a \c m8f input vector-mask
 * \returns "bitwise not"ed \c m8f vector-mask
 */
m8f m8f_not(m8f a);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m8i input vector-mask \c a.
 * \impl
dst[0:7] = ~a[0:7]
\endimpl
 * \param a \c m8i input vector-mask
 * \returns "bitwise not"ed \c m8i vector-mask
 */
m8i m8i_not(m8i a);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m8l input vector-mask \c a.
 * \impl
dst[0:7] = ~a[0:7]
\endimpl
 * \param a \c m8l input vector-mask
 * \returns "bitwise not"ed \c m8l vector-mask
 */
m8l m8l_not(m8l a);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m16f input vector-mask \c a.
 * \impl
dst[0:15] = ~a[0:15]
\endimpl
 * \param a \c m16f input vector-mask
 * \returns "bitwise not"ed \c m16f vector-mask
 */
m16f m16f_not(m16f a);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c m16i input vector-mask \c a.
 * \impl
dst[0:15] = ~a[0:15]
\endimpl
 * \param a \c m16i input vector-mask
 * \returns "bitwise not"ed \c m16i vector-mask
 */
m16i m16i_not(m16i a);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m1d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1d_not(m1d_and(a, b))`
 * \attention This function should not be confused with m1d_andnot(m1d a, m1d b).
 * \impl
dst[0] = ~(a[0] & b[0])
\endimpl
 * \see m1d_and(m1d a, m1d b)
 * \see m1d_not(m1d a)
 * \see m1d_andnot(m1d a, m1d b)
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise nand"ed \c m1d vector-mask
 */
m1d m1d_nand(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m1f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1f_not(m1f_and(a, b))`
 * \attention This function should not be confused with m1f_andnot(m1f a, m1f b).
 * \impl
dst[0] = ~(a[0] & b[0])
\endimpl
 * \see m1f_and(m1f a, m1f b)
 * \see m1f_not(m1f a)
 * \see m1f_andnot(m1f a, m1f b)
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise nand"ed \c m1f vector-mask
 */
m1f m1f_nand(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m1i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1i_not(m1i_and(a, b))`
 * \attention This function should not be confused with m1i_andnot(m1i a, m1i b).
 * \impl
dst[0] = ~(a[0] & b[0])
\endimpl
 * \see m1i_and(m1i a, m1i b)
 * \see m1i_not(m1i a)
 * \see m1i_andnot(m1i a, m1i b)
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise nand"ed \c m1i vector-mask
 */
m1i m1i_nand(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m1l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1l_not(m1l_and(a, b))`
 * \attention This function should not be confused with m1l_andnot(m1l a, m1l b).
 * \impl
dst[0] = ~(a[0] & b[0])
\endimpl
 * \see m1l_and(m1l a, m1l b)
 * \see m1l_not(m1l a)
 * \see m1l_andnot(m1l a, m1l b)
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise nand"ed \c m1l vector-mask
 */
m1l m1l_nand(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m2d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2d_not(m2d_and(a, b))`
 * \attention This function should not be confused with m2d_andnot(m2d a, m2d b).
 * \impl
dst[0:1] = ~(a[0:1] & b[0:1])
\endimpl
 * \see m2d_and(m2d a, m2d b)
 * \see m2d_not(m2d a)
 * \see m2d_andnot(m2d a, m2d b)
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise nand"ed \c m2d vector-mask
 */
m2d m2d_nand(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m2f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2f_not(m2f_and(a, b))`
 * \attention This function should not be confused with m2f_andnot(m2f a, m2f b).
 * \impl
dst[0:1] = ~(a[0:1] & b[0:1])
\endimpl
 * \see m2f_and(m2f a, m2f b)
 * \see m2f_not(m2f a)
 * \see m2f_andnot(m2f a, m2f b)
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise nand"ed \c m2f vector-mask
 */
m2f m2f_nand(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m2i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2i_not(m2i_and(a, b))`
 * \attention This function should not be confused with m2i_andnot(m2i a, m2i b).
 * \impl
dst[0:1] = ~(a[0:1] & b[0:1])
\endimpl
 * \see m2i_and(m2i a, m2i b)
 * \see m2i_not(m2i a)
 * \see m2i_andnot(m2i a, m2i b)
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise nand"ed \c m2i vector-mask
 */
m2i m2i_nand(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m2l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2l_not(m2l_and(a, b))`
 * \attention This function should not be confused with m2l_andnot(m2l a, m2l b).
 * \impl
dst[0:1] = ~(a[0:1] & b[0:1])
\endimpl
 * \see m2l_and(m2l a, m2l b)
 * \see m2l_not(m2l a)
 * \see m2l_andnot(m2l a, m2l b)
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise nand"ed \c m2l vector-mask
 */
m2l m2l_nand(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m4d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4d_not(m4d_and(a, b))`
 * \attention This function should not be confused with m4d_andnot(m4d a, m4d b).
 * \impl
dst[0:3] = ~(a[0:3] & b[0:3])
\endimpl
 * \see m4d_and(m4d a, m4d b)
 * \see m4d_not(m4d a)
 * \see m4d_andnot(m4d a, m4d b)
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise nand"ed \c m4d vector-mask
 */
m4d m4d_nand(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m4f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4f_not(m4f_and(a, b))`
 * \attention This function should not be confused with m4f_andnot(m4f a, m4f b).
 * \impl
dst[0:3] = ~(a[0:3] & b[0:3])
\endimpl
 * \see m4f_and(m4f a, m4f b)
 * \see m4f_not(m4f a)
 * \see m4f_andnot(m4f a, m4f b)
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise nand"ed \c m4f vector-mask
 */
m4f m4f_nand(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m4i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4i_not(m4i_and(a, b))`
 * \attention This function should not be confused with m4i_andnot(m4i a, m4i b).
 * \impl
dst[0:3] = ~(a[0:3] & b[0:3])
\endimpl
 * \see m4i_and(m4i a, m4i b)
 * \see m4i_not(m4i a)
 * \see m4i_andnot(m4i a, m4i b)
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise nand"ed \c m4i vector-mask
 */
m4i m4i_nand(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m4l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4l_not(m4l_and(a, b))`
 * \attention This function should not be confused with m4l_andnot(m4l a, m4l b).
 * \impl
dst[0:3] = ~(a[0:3] & b[0:3])
\endimpl
 * \see m4l_and(m4l a, m4l b)
 * \see m4l_not(m4l a)
 * \see m4l_andnot(m4l a, m4l b)
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise nand"ed \c m4l vector-mask
 */
m4l m4l_nand(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m8d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8d_not(m8d_and(a, b))`
 * \attention This function should not be confused with m8d_andnot(m8d a, m8d b).
 * \impl
dst[0:7] = ~(a[0:7] & b[0:7])
\endimpl
 * \see m8d_and(m8d a, m8d b)
 * \see m8d_not(m8d a)
 * \see m8d_andnot(m8d a, m8d b)
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise nand"ed \c m8d vector-mask
 */
m8d m8d_nand(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m8f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8f_not(m8f_and(a, b))`
 * \attention This function should not be confused with m8f_andnot(m8f a, m8f b).
 * \impl
dst[0:7] = ~(a[0:7] & b[0:7])
\endimpl
 * \see m8f_and(m8f a, m8f b)
 * \see m8f_not(m8f a)
 * \see m8f_andnot(m8f a, m8f b)
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise nand"ed \c m8f vector-mask
 */
m8f m8f_nand(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m8i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8i_not(m8i_and(a, b))`
 * \attention This function should not be confused with m8i_andnot(m8i a, m8i b).
 * \impl
dst[0:7] = ~(a[0:7] & b[0:7])
\endimpl
 * \see m8i_and(m8i a, m8i b)
 * \see m8i_not(m8i a)
 * \see m8i_andnot(m8i a, m8i b)
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise nand"ed \c m8i vector-mask
 */
m8i m8i_nand(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m8l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8l_not(m8l_and(a, b))`
 * \attention This function should not be confused with m8l_andnot(m8l a, m8l b).
 * \impl
dst[0:7] = ~(a[0:7] & b[0:7])
\endimpl
 * \see m8l_and(m8l a, m8l b)
 * \see m8l_not(m8l a)
 * \see m8l_andnot(m8l a, m8l b)
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise nand"ed \c m8l vector-mask
 */
m8l m8l_nand(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m16f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16f_not(m16f_and(a, b))`
 * \attention This function should not be confused with m16f_andnot(m16f a, m16f b).
 * \impl
dst[0:15] = ~(a[0:15] & b[0:15])
\endimpl
 * \see m16f_and(m16f a, m16f b)
 * \see m16f_not(m16f a)
 * \see m16f_andnot(m16f a, m16f b)
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise nand"ed \c m16f vector-mask
 */
m16f m16f_nand(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c m16i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16i_not(m16i_and(a, b))`
 * \attention This function should not be confused with m16i_andnot(m16i a, m16i b).
 * \impl
dst[0:15] = ~(a[0:15] & b[0:15])
\endimpl
 * \see m16i_and(m16i a, m16i b)
 * \see m16i_not(m16i a)
 * \see m16i_andnot(m16i a, m16i b)
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise nand"ed \c m16i vector-mask
 */
m16i m16i_nand(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m1d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1d_not(m1d_or(a, b))`
 * \attention This function should not be confused with m1d_ornot(m1d a, m1d b).
 * \impl
dst[0] = ~(a[0] | b[0])
\endimpl
 * \see m1d_or(m1d a, m1d b)
 * \see m1d_not(m1d a)
 * \see m1d_ornot(m1d a, m1d b)
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise nor"ed \c m1d vector-mask
 */
m1d m1d_nor(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m1f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1f_not(m1f_or(a, b))`
 * \attention This function should not be confused with m1f_ornot(m1f a, m1f b).
 * \impl
dst[0] = ~(a[0] | b[0])
\endimpl
 * \see m1f_or(m1f a, m1f b)
 * \see m1f_not(m1f a)
 * \see m1f_ornot(m1f a, m1f b)
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise nor"ed \c m1f vector-mask
 */
m1f m1f_nor(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m1i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1i_not(m1i_or(a, b))`
 * \attention This function should not be confused with m1i_ornot(m1i a, m1i b).
 * \impl
dst[0] = ~(a[0] | b[0])
\endimpl
 * \see m1i_or(m1i a, m1i b)
 * \see m1i_not(m1i a)
 * \see m1i_ornot(m1i a, m1i b)
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise nor"ed \c m1i vector-mask
 */
m1i m1i_nor(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m1l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1l_not(m1l_or(a, b))`
 * \attention This function should not be confused with m1l_ornot(m1l a, m1l b).
 * \impl
dst[0] = ~(a[0] | b[0])
\endimpl
 * \see m1l_or(m1l a, m1l b)
 * \see m1l_not(m1l a)
 * \see m1l_ornot(m1l a, m1l b)
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise nor"ed \c m1l vector-mask
 */
m1l m1l_nor(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m2d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2d_not(m2d_or(a, b))`
 * \attention This function should not be confused with m2d_ornot(m2d a, m2d b).
 * \impl
dst[0:1] = ~(a[0:1] | b[0:1])
\endimpl
 * \see m2d_or(m2d a, m2d b)
 * \see m2d_not(m2d a)
 * \see m2d_ornot(m2d a, m2d b)
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise nor"ed \c m2d vector-mask
 */
m2d m2d_nor(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m2f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2f_not(m2f_or(a, b))`
 * \attention This function should not be confused with m2f_ornot(m2f a, m2f b).
 * \impl
dst[0:1] = ~(a[0:1] | b[0:1])
\endimpl
 * \see m2f_or(m2f a, m2f b)
 * \see m2f_not(m2f a)
 * \see m2f_ornot(m2f a, m2f b)
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise nor"ed \c m2f vector-mask
 */
m2f m2f_nor(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m2i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2i_not(m2i_or(a, b))`
 * \attention This function should not be confused with m2i_ornot(m2i a, m2i b).
 * \impl
dst[0:1] = ~(a[0:1] | b[0:1])
\endimpl
 * \see m2i_or(m2i a, m2i b)
 * \see m2i_not(m2i a)
 * \see m2i_ornot(m2i a, m2i b)
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise nor"ed \c m2i vector-mask
 */
m2i m2i_nor(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m2l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2l_not(m2l_or(a, b))`
 * \attention This function should not be confused with m2l_ornot(m2l a, m2l b).
 * \impl
dst[0:1] = ~(a[0:1] | b[0:1])
\endimpl
 * \see m2l_or(m2l a, m2l b)
 * \see m2l_not(m2l a)
 * \see m2l_ornot(m2l a, m2l b)
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise nor"ed \c m2l vector-mask
 */
m2l m2l_nor(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m4d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4d_not(m4d_or(a, b))`
 * \attention This function should not be confused with m4d_ornot(m4d a, m4d b).
 * \impl
dst[0:3] = ~(a[0:3] | b[0:3])
\endimpl
 * \see m4d_or(m4d a, m4d b)
 * \see m4d_not(m4d a)
 * \see m4d_ornot(m4d a, m4d b)
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise nor"ed \c m4d vector-mask
 */
m4d m4d_nor(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m4f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4f_not(m4f_or(a, b))`
 * \attention This function should not be confused with m4f_ornot(m4f a, m4f b).
 * \impl
dst[0:3] = ~(a[0:3] | b[0:3])
\endimpl
 * \see m4f_or(m4f a, m4f b)
 * \see m4f_not(m4f a)
 * \see m4f_ornot(m4f a, m4f b)
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise nor"ed \c m4f vector-mask
 */
m4f m4f_nor(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m4i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4i_not(m4i_or(a, b))`
 * \attention This function should not be confused with m4i_ornot(m4i a, m4i b).
 * \impl
dst[0:3] = ~(a[0:3] | b[0:3])
\endimpl
 * \see m4i_or(m4i a, m4i b)
 * \see m4i_not(m4i a)
 * \see m4i_ornot(m4i a, m4i b)
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise nor"ed \c m4i vector-mask
 */
m4i m4i_nor(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m4l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4l_not(m4l_or(a, b))`
 * \attention This function should not be confused with m4l_ornot(m4l a, m4l b).
 * \impl
dst[0:3] = ~(a[0:3] | b[0:3])
\endimpl
 * \see m4l_or(m4l a, m4l b)
 * \see m4l_not(m4l a)
 * \see m4l_ornot(m4l a, m4l b)
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise nor"ed \c m4l vector-mask
 */
m4l m4l_nor(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m8d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8d_not(m8d_or(a, b))`
 * \attention This function should not be confused with m8d_ornot(m8d a, m8d b).
 * \impl
dst[0:7] = ~(a[0:7] | b[0:7])
\endimpl
 * \see m8d_or(m8d a, m8d b)
 * \see m8d_not(m8d a)
 * \see m8d_ornot(m8d a, m8d b)
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise nor"ed \c m8d vector-mask
 */
m8d m8d_nor(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m8f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8f_not(m8f_or(a, b))`
 * \attention This function should not be confused with m8f_ornot(m8f a, m8f b).
 * \impl
dst[0:7] = ~(a[0:7] | b[0:7])
\endimpl
 * \see m8f_or(m8f a, m8f b)
 * \see m8f_not(m8f a)
 * \see m8f_ornot(m8f a, m8f b)
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise nor"ed \c m8f vector-mask
 */
m8f m8f_nor(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m8i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8i_not(m8i_or(a, b))`
 * \attention This function should not be confused with m8i_ornot(m8i a, m8i b).
 * \impl
dst[0:7] = ~(a[0:7] | b[0:7])
\endimpl
 * \see m8i_or(m8i a, m8i b)
 * \see m8i_not(m8i a)
 * \see m8i_ornot(m8i a, m8i b)
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise nor"ed \c m8i vector-mask
 */
m8i m8i_nor(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m8l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8l_not(m8l_or(a, b))`
 * \attention This function should not be confused with m8l_ornot(m8l a, m8l b).
 * \impl
dst[0:7] = ~(a[0:7] | b[0:7])
\endimpl
 * \see m8l_or(m8l a, m8l b)
 * \see m8l_not(m8l a)
 * \see m8l_ornot(m8l a, m8l b)
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise nor"ed \c m8l vector-mask
 */
m8l m8l_nor(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m16f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16f_not(m16f_or(a, b))`
 * \attention This function should not be confused with m16f_ornot(m16f a, m16f b).
 * \impl
dst[0:15] = ~(a[0:15] | b[0:15])
\endimpl
 * \see m16f_or(m16f a, m16f b)
 * \see m16f_not(m16f a)
 * \see m16f_ornot(m16f a, m16f b)
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise nor"ed \c m16f vector-mask
 */
m16f m16f_nor(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c m16i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16i_not(m16i_or(a, b))`
 * \attention This function should not be confused with m16i_ornot(m16i a, m16i b).
 * \impl
dst[0:15] = ~(a[0:15] | b[0:15])
\endimpl
 * \see m16i_or(m16i a, m16i b)
 * \see m16i_not(m16i a)
 * \see m16i_ornot(m16i a, m16i b)
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise nor"ed \c m16i vector-mask
 */
m16i m16i_nor(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m1d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1d_not(m1d_xor(a, b))`
 * \impl
dst[0] = ~(a[0] ^ b[0])
\endimpl
 * \see m1d_xor(m1d a, m1d b)
 * \see m1d_not(m1d a)
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise nxor"ed \c m1d vector-mask
 */
m1d m1d_nxor(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m1f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1f_not(m1f_xor(a, b))`
 * \impl
dst[0] = ~(a[0] ^ b[0])
\endimpl
 * \see m1f_xor(m1f a, m1f b)
 * \see m1f_not(m1f a)
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise nxor"ed \c m1f vector-mask
 */
m1f m1f_nxor(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m1i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1i_not(m1i_xor(a, b))`
 * \impl
dst[0] = ~(a[0] ^ b[0])
\endimpl
 * \see m1i_xor(m1i a, m1i b)
 * \see m1i_not(m1i a)
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise nxor"ed \c m1i vector-mask
 */
m1i m1i_nxor(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m1l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1l_not(m1l_xor(a, b))`
 * \impl
dst[0] = ~(a[0] ^ b[0])
\endimpl
 * \see m1l_xor(m1l a, m1l b)
 * \see m1l_not(m1l a)
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise nxor"ed \c m1l vector-mask
 */
m1l m1l_nxor(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m2d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2d_not(m2d_xor(a, b))`
 * \impl
dst[0:1] = ~(a[0:1] ^ b[0:1])
\endimpl
 * \see m2d_xor(m2d a, m2d b)
 * \see m2d_not(m2d a)
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise nxor"ed \c m2d vector-mask
 */
m2d m2d_nxor(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m2f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2f_not(m2f_xor(a, b))`
 * \impl
dst[0:1] = ~(a[0:1] ^ b[0:1])
\endimpl
 * \see m2f_xor(m2f a, m2f b)
 * \see m2f_not(m2f a)
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise nxor"ed \c m2f vector-mask
 */
m2f m2f_nxor(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m2i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2i_not(m2i_xor(a, b))`
 * \impl
dst[0:1] = ~(a[0:1] ^ b[0:1])
\endimpl
 * \see m2i_xor(m2i a, m2i b)
 * \see m2i_not(m2i a)
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise nxor"ed \c m2i vector-mask
 */
m2i m2i_nxor(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m2l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2l_not(m2l_xor(a, b))`
 * \impl
dst[0:1] = ~(a[0:1] ^ b[0:1])
\endimpl
 * \see m2l_xor(m2l a, m2l b)
 * \see m2l_not(m2l a)
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise nxor"ed \c m2l vector-mask
 */
m2l m2l_nxor(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m4d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4d_not(m4d_xor(a, b))`
 * \impl
dst[0:3] = ~(a[0:3] ^ b[0:3])
\endimpl
 * \see m4d_xor(m4d a, m4d b)
 * \see m4d_not(m4d a)
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise nxor"ed \c m4d vector-mask
 */
m4d m4d_nxor(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m4f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4f_not(m4f_xor(a, b))`
 * \impl
dst[0:3] = ~(a[0:3] ^ b[0:3])
\endimpl
 * \see m4f_xor(m4f a, m4f b)
 * \see m4f_not(m4f a)
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise nxor"ed \c m4f vector-mask
 */
m4f m4f_nxor(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m4i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4i_not(m4i_xor(a, b))`
 * \impl
dst[0:3] = ~(a[0:3] ^ b[0:3])
\endimpl
 * \see m4i_xor(m4i a, m4i b)
 * \see m4i_not(m4i a)
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise nxor"ed \c m4i vector-mask
 */
m4i m4i_nxor(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m4l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4l_not(m4l_xor(a, b))`
 * \impl
dst[0:3] = ~(a[0:3] ^ b[0:3])
\endimpl
 * \see m4l_xor(m4l a, m4l b)
 * \see m4l_not(m4l a)
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise nxor"ed \c m4l vector-mask
 */
m4l m4l_nxor(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m8d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8d_not(m8d_xor(a, b))`
 * \impl
dst[0:7] = ~(a[0:7] ^ b[0:7])
\endimpl
 * \see m8d_xor(m8d a, m8d b)
 * \see m8d_not(m8d a)
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise nxor"ed \c m8d vector-mask
 */
m8d m8d_nxor(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m8f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8f_not(m8f_xor(a, b))`
 * \impl
dst[0:7] = ~(a[0:7] ^ b[0:7])
\endimpl
 * \see m8f_xor(m8f a, m8f b)
 * \see m8f_not(m8f a)
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise nxor"ed \c m8f vector-mask
 */
m8f m8f_nxor(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m8i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8i_not(m8i_xor(a, b))`
 * \impl
dst[0:7] = ~(a[0:7] ^ b[0:7])
\endimpl
 * \see m8i_xor(m8i a, m8i b)
 * \see m8i_not(m8i a)
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise nxor"ed \c m8i vector-mask
 */
m8i m8i_nxor(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m8l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8l_not(m8l_xor(a, b))`
 * \impl
dst[0:7] = ~(a[0:7] ^ b[0:7])
\endimpl
 * \see m8l_xor(m8l a, m8l b)
 * \see m8l_not(m8l a)
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise nxor"ed \c m8l vector-mask
 */
m8l m8l_nxor(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m16f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16f_not(m16f_xor(a, b))`
 * \impl
dst[0:15] = ~(a[0:15] ^ b[0:15])
\endimpl
 * \see m16f_xor(m16f a, m16f b)
 * \see m16f_not(m16f a)
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise nxor"ed \c m16f vector-mask
 */
m16f m16f_nxor(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c m16i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16i_not(m16i_xor(a, b))`
 * \impl
dst[0:15] = ~(a[0:15] ^ b[0:15])
\endimpl
 * \see m16i_xor(m16i a, m16i b)
 * \see m16i_not(m16i a)
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise nxor"ed \c m16i vector-mask
 */
m16i m16i_nxor(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m1d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1d_and(a, m1d_not(b))`
 * \attention This function should not be confused with m1d_nand(m1d a, m1d b).
 * \impl
dst[0] = a[0] & ~b[0]
\endimpl
 * \see m1d_and(m1d a, m1d b)
 * \see m1d_not(m1d a)
 * \see m1d_nand(m1d a, m1d b)
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise andnot"ed \c m1d vector-mask
 */
m1d m1d_andnot(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m1f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1f_and(a, m1f_not(b))`
 * \attention This function should not be confused with m1f_nand(m1f a, m1f b).
 * \impl
dst[0] = a[0] & ~b[0]
\endimpl
 * \see m1f_and(m1f a, m1f b)
 * \see m1f_not(m1f a)
 * \see m1f_nand(m1f a, m1f b)
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise andnot"ed \c m1f vector-mask
 */
m1f m1f_andnot(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m1i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1i_and(a, m1i_not(b))`
 * \attention This function should not be confused with m1i_nand(m1i a, m1i b).
 * \impl
dst[0] = a[0] & ~b[0]
\endimpl
 * \see m1i_and(m1i a, m1i b)
 * \see m1i_not(m1i a)
 * \see m1i_nand(m1i a, m1i b)
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise andnot"ed \c m1i vector-mask
 */
m1i m1i_andnot(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m1l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1l_and(a, m1l_not(b))`
 * \attention This function should not be confused with m1l_nand(m1l a, m1l b).
 * \impl
dst[0] = a[0] & ~b[0]
\endimpl
 * \see m1l_and(m1l a, m1l b)
 * \see m1l_not(m1l a)
 * \see m1l_nand(m1l a, m1l b)
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise andnot"ed \c m1l vector-mask
 */
m1l m1l_andnot(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m2d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2d_and(a, m2d_not(b))`
 * \attention This function should not be confused with m2d_nand(m2d a, m2d b).
 * \impl
dst[0:1] = a[0:1] & ~b[0:1]
\endimpl
 * \see m2d_and(m2d a, m2d b)
 * \see m2d_not(m2d a)
 * \see m2d_nand(m2d a, m2d b)
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise andnot"ed \c m2d vector-mask
 */
m2d m2d_andnot(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m2f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2f_and(a, m2f_not(b))`
 * \attention This function should not be confused with m2f_nand(m2f a, m2f b).
 * \impl
dst[0:1] = a[0:1] & ~b[0:1]
\endimpl
 * \see m2f_and(m2f a, m2f b)
 * \see m2f_not(m2f a)
 * \see m2f_nand(m2f a, m2f b)
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise andnot"ed \c m2f vector-mask
 */
m2f m2f_andnot(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m2i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2i_and(a, m2i_not(b))`
 * \attention This function should not be confused with m2i_nand(m2i a, m2i b).
 * \impl
dst[0:1] = a[0:1] & ~b[0:1]
\endimpl
 * \see m2i_and(m2i a, m2i b)
 * \see m2i_not(m2i a)
 * \see m2i_nand(m2i a, m2i b)
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise andnot"ed \c m2i vector-mask
 */
m2i m2i_andnot(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m2l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2l_and(a, m2l_not(b))`
 * \attention This function should not be confused with m2l_nand(m2l a, m2l b).
 * \impl
dst[0:1] = a[0:1] & ~b[0:1]
\endimpl
 * \see m2l_and(m2l a, m2l b)
 * \see m2l_not(m2l a)
 * \see m2l_nand(m2l a, m2l b)
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise andnot"ed \c m2l vector-mask
 */
m2l m2l_andnot(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m4d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4d_and(a, m4d_not(b))`
 * \attention This function should not be confused with m4d_nand(m4d a, m4d b).
 * \impl
dst[0:3] = a[0:3] & ~b[0:3]
\endimpl
 * \see m4d_and(m4d a, m4d b)
 * \see m4d_not(m4d a)
 * \see m4d_nand(m4d a, m4d b)
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise andnot"ed \c m4d vector-mask
 */
m4d m4d_andnot(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m4f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4f_and(a, m4f_not(b))`
 * \attention This function should not be confused with m4f_nand(m4f a, m4f b).
 * \impl
dst[0:3] = a[0:3] & ~b[0:3]
\endimpl
 * \see m4f_and(m4f a, m4f b)
 * \see m4f_not(m4f a)
 * \see m4f_nand(m4f a, m4f b)
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise andnot"ed \c m4f vector-mask
 */
m4f m4f_andnot(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m4i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4i_and(a, m4i_not(b))`
 * \attention This function should not be confused with m4i_nand(m4i a, m4i b).
 * \impl
dst[0:3] = a[0:3] & ~b[0:3]
\endimpl
 * \see m4i_and(m4i a, m4i b)
 * \see m4i_not(m4i a)
 * \see m4i_nand(m4i a, m4i b)
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise andnot"ed \c m4i vector-mask
 */
m4i m4i_andnot(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m4l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4l_and(a, m4l_not(b))`
 * \attention This function should not be confused with m4l_nand(m4l a, m4l b).
 * \impl
dst[0:3] = a[0:3] & ~b[0:3]
\endimpl
 * \see m4l_and(m4l a, m4l b)
 * \see m4l_not(m4l a)
 * \see m4l_nand(m4l a, m4l b)
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise andnot"ed \c m4l vector-mask
 */
m4l m4l_andnot(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m8d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8d_and(a, m8d_not(b))`
 * \attention This function should not be confused with m8d_nand(m8d a, m8d b).
 * \impl
dst[0:7] = a[0:7] & ~b[0:7]
\endimpl
 * \see m8d_and(m8d a, m8d b)
 * \see m8d_not(m8d a)
 * \see m8d_nand(m8d a, m8d b)
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise andnot"ed \c m8d vector-mask
 */
m8d m8d_andnot(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m8f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8f_and(a, m8f_not(b))`
 * \attention This function should not be confused with m8f_nand(m8f a, m8f b).
 * \impl
dst[0:7] = a[0:7] & ~b[0:7]
\endimpl
 * \see m8f_and(m8f a, m8f b)
 * \see m8f_not(m8f a)
 * \see m8f_nand(m8f a, m8f b)
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise andnot"ed \c m8f vector-mask
 */
m8f m8f_andnot(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m8i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8i_and(a, m8i_not(b))`
 * \attention This function should not be confused with m8i_nand(m8i a, m8i b).
 * \impl
dst[0:7] = a[0:7] & ~b[0:7]
\endimpl
 * \see m8i_and(m8i a, m8i b)
 * \see m8i_not(m8i a)
 * \see m8i_nand(m8i a, m8i b)
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise andnot"ed \c m8i vector-mask
 */
m8i m8i_andnot(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m8l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8l_and(a, m8l_not(b))`
 * \attention This function should not be confused with m8l_nand(m8l a, m8l b).
 * \impl
dst[0:7] = a[0:7] & ~b[0:7]
\endimpl
 * \see m8l_and(m8l a, m8l b)
 * \see m8l_not(m8l a)
 * \see m8l_nand(m8l a, m8l b)
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise andnot"ed \c m8l vector-mask
 */
m8l m8l_andnot(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m16f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16f_and(a, m16f_not(b))`
 * \attention This function should not be confused with m16f_nand(m16f a, m16f b).
 * \impl
dst[0:15] = a[0:15] & ~b[0:15]
\endimpl
 * \see m16f_and(m16f a, m16f b)
 * \see m16f_not(m16f a)
 * \see m16f_nand(m16f a, m16f b)
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise andnot"ed \c m16f vector-mask
 */
m16f m16f_andnot(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c m16i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16i_and(a, m16i_not(b))`
 * \attention This function should not be confused with m16i_nand(m16i a, m16i b).
 * \impl
dst[0:15] = a[0:15] & ~b[0:15]
\endimpl
 * \see m16i_and(m16i a, m16i b)
 * \see m16i_not(m16i a)
 * \see m16i_nand(m16i a, m16i b)
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise andnot"ed \c m16i vector-mask
 */
m16i m16i_andnot(m16i a, m16i b);

/**
 * \ingroup mlogic
 * \related v1d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m1d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1d_or(a, m1d_not(b))`
 * \attention This function should not be confused with m1d_nor(m1d a, m1d b).
 * \impl
dst[0] = a[0] | ~b[0]
\endimpl
 * \see m1d_or(m1d a, m1d b)
 * \see m1d_not(m1d a)
 * \see m1d_nor(m1d a, m1d b)
 * \param a first \c m1d input vector-mask
 * \param b second \c m1d input vector-mask
 * \returns "bitwise ornot"ed \c m1d vector-mask
 */
m1d m1d_ornot(m1d a, m1d b);
/**
 * \ingroup mlogic
 * \related v1f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m1f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1f_or(a, m1f_not(b))`
 * \attention This function should not be confused with m1f_nor(m1f a, m1f b).
 * \impl
dst[0] = a[0] | ~b[0]
\endimpl
 * \see m1f_or(m1f a, m1f b)
 * \see m1f_not(m1f a)
 * \see m1f_nor(m1f a, m1f b)
 * \param a first \c m1f input vector-mask
 * \param b second \c m1f input vector-mask
 * \returns "bitwise ornot"ed \c m1f vector-mask
 */
m1f m1f_ornot(m1f a, m1f b);
/**
 * \ingroup mlogic
 * \related v1i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m1i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1i_or(a, m1i_not(b))`
 * \attention This function should not be confused with m1i_nor(m1i a, m1i b).
 * \impl
dst[0] = a[0] | ~b[0]
\endimpl
 * \see m1i_or(m1i a, m1i b)
 * \see m1i_not(m1i a)
 * \see m1i_nor(m1i a, m1i b)
 * \param a first \c m1i input vector-mask
 * \param b second \c m1i input vector-mask
 * \returns "bitwise ornot"ed \c m1i vector-mask
 */
m1i m1i_ornot(m1i a, m1i b);
/**
 * \ingroup mlogic
 * \related v1l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m1l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m1l_or(a, m1l_not(b))`
 * \attention This function should not be confused with m1l_nor(m1l a, m1l b).
 * \impl
dst[0] = a[0] | ~b[0]
\endimpl
 * \see m1l_or(m1l a, m1l b)
 * \see m1l_not(m1l a)
 * \see m1l_nor(m1l a, m1l b)
 * \param a first \c m1l input vector-mask
 * \param b second \c m1l input vector-mask
 * \returns "bitwise ornot"ed \c m1l vector-mask
 */
m1l m1l_ornot(m1l a, m1l b);
/**
 * \ingroup mlogic
 * \related v2d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m2d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2d_or(a, m2d_not(b))`
 * \attention This function should not be confused with m2d_nor(m2d a, m2d b).
 * \impl
dst[0:1] = a[0:1] | ~b[0:1]
\endimpl
 * \see m2d_or(m2d a, m2d b)
 * \see m2d_not(m2d a)
 * \see m2d_nor(m2d a, m2d b)
 * \param a first \c m2d input vector-mask
 * \param b second \c m2d input vector-mask
 * \returns "bitwise ornot"ed \c m2d vector-mask
 */
m2d m2d_ornot(m2d a, m2d b);
/**
 * \ingroup mlogic
 * \related v2f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m2f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2f_or(a, m2f_not(b))`
 * \attention This function should not be confused with m2f_nor(m2f a, m2f b).
 * \impl
dst[0:1] = a[0:1] | ~b[0:1]
\endimpl
 * \see m2f_or(m2f a, m2f b)
 * \see m2f_not(m2f a)
 * \see m2f_nor(m2f a, m2f b)
 * \param a first \c m2f input vector-mask
 * \param b second \c m2f input vector-mask
 * \returns "bitwise ornot"ed \c m2f vector-mask
 */
m2f m2f_ornot(m2f a, m2f b);
/**
 * \ingroup mlogic
 * \related v2i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m2i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2i_or(a, m2i_not(b))`
 * \attention This function should not be confused with m2i_nor(m2i a, m2i b).
 * \impl
dst[0:1] = a[0:1] | ~b[0:1]
\endimpl
 * \see m2i_or(m2i a, m2i b)
 * \see m2i_not(m2i a)
 * \see m2i_nor(m2i a, m2i b)
 * \param a first \c m2i input vector-mask
 * \param b second \c m2i input vector-mask
 * \returns "bitwise ornot"ed \c m2i vector-mask
 */
m2i m2i_ornot(m2i a, m2i b);
/**
 * \ingroup mlogic
 * \related v2l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m2l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m2l_or(a, m2l_not(b))`
 * \attention This function should not be confused with m2l_nor(m2l a, m2l b).
 * \impl
dst[0:1] = a[0:1] | ~b[0:1]
\endimpl
 * \see m2l_or(m2l a, m2l b)
 * \see m2l_not(m2l a)
 * \see m2l_nor(m2l a, m2l b)
 * \param a first \c m2l input vector-mask
 * \param b second \c m2l input vector-mask
 * \returns "bitwise ornot"ed \c m2l vector-mask
 */
m2l m2l_ornot(m2l a, m2l b);
/**
 * \ingroup mlogic
 * \related v4d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m4d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4d_or(a, m4d_not(b))`
 * \attention This function should not be confused with m4d_nor(m4d a, m4d b).
 * \impl
dst[0:3] = a[0:3] | ~b[0:3]
\endimpl
 * \see m4d_or(m4d a, m4d b)
 * \see m4d_not(m4d a)
 * \see m4d_nor(m4d a, m4d b)
 * \param a first \c m4d input vector-mask
 * \param b second \c m4d input vector-mask
 * \returns "bitwise ornot"ed \c m4d vector-mask
 */
m4d m4d_ornot(m4d a, m4d b);
/**
 * \ingroup mlogic
 * \related v4f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m4f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4f_or(a, m4f_not(b))`
 * \attention This function should not be confused with m4f_nor(m4f a, m4f b).
 * \impl
dst[0:3] = a[0:3] | ~b[0:3]
\endimpl
 * \see m4f_or(m4f a, m4f b)
 * \see m4f_not(m4f a)
 * \see m4f_nor(m4f a, m4f b)
 * \param a first \c m4f input vector-mask
 * \param b second \c m4f input vector-mask
 * \returns "bitwise ornot"ed \c m4f vector-mask
 */
m4f m4f_ornot(m4f a, m4f b);
/**
 * \ingroup mlogic
 * \related v4i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m4i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4i_or(a, m4i_not(b))`
 * \attention This function should not be confused with m4i_nor(m4i a, m4i b).
 * \impl
dst[0:3] = a[0:3] | ~b[0:3]
\endimpl
 * \see m4i_or(m4i a, m4i b)
 * \see m4i_not(m4i a)
 * \see m4i_nor(m4i a, m4i b)
 * \param a first \c m4i input vector-mask
 * \param b second \c m4i input vector-mask
 * \returns "bitwise ornot"ed \c m4i vector-mask
 */
m4i m4i_ornot(m4i a, m4i b);
/**
 * \ingroup mlogic
 * \related v4l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m4l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m4l_or(a, m4l_not(b))`
 * \attention This function should not be confused with m4l_nor(m4l a, m4l b).
 * \impl
dst[0:3] = a[0:3] | ~b[0:3]
\endimpl
 * \see m4l_or(m4l a, m4l b)
 * \see m4l_not(m4l a)
 * \see m4l_nor(m4l a, m4l b)
 * \param a first \c m4l input vector-mask
 * \param b second \c m4l input vector-mask
 * \returns "bitwise ornot"ed \c m4l vector-mask
 */
m4l m4l_ornot(m4l a, m4l b);
/**
 * \ingroup mlogic
 * \related v8d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m8d input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8d_or(a, m8d_not(b))`
 * \attention This function should not be confused with m8d_nor(m8d a, m8d b).
 * \impl
dst[0:7] = a[0:7] | ~b[0:7]
\endimpl
 * \see m8d_or(m8d a, m8d b)
 * \see m8d_not(m8d a)
 * \see m8d_nor(m8d a, m8d b)
 * \param a first \c m8d input vector-mask
 * \param b second \c m8d input vector-mask
 * \returns "bitwise ornot"ed \c m8d vector-mask
 */
m8d m8d_ornot(m8d a, m8d b);
/**
 * \ingroup mlogic
 * \related v8f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m8f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8f_or(a, m8f_not(b))`
 * \attention This function should not be confused with m8f_nor(m8f a, m8f b).
 * \impl
dst[0:7] = a[0:7] | ~b[0:7]
\endimpl
 * \see m8f_or(m8f a, m8f b)
 * \see m8f_not(m8f a)
 * \see m8f_nor(m8f a, m8f b)
 * \param a first \c m8f input vector-mask
 * \param b second \c m8f input vector-mask
 * \returns "bitwise ornot"ed \c m8f vector-mask
 */
m8f m8f_ornot(m8f a, m8f b);
/**
 * \ingroup mlogic
 * \related v8i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m8i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8i_or(a, m8i_not(b))`
 * \attention This function should not be confused with m8i_nor(m8i a, m8i b).
 * \impl
dst[0:7] = a[0:7] | ~b[0:7]
\endimpl
 * \see m8i_or(m8i a, m8i b)
 * \see m8i_not(m8i a)
 * \see m8i_nor(m8i a, m8i b)
 * \param a first \c m8i input vector-mask
 * \param b second \c m8i input vector-mask
 * \returns "bitwise ornot"ed \c m8i vector-mask
 */
m8i m8i_ornot(m8i a, m8i b);
/**
 * \ingroup mlogic
 * \related v8l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m8l input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m8l_or(a, m8l_not(b))`
 * \attention This function should not be confused with m8l_nor(m8l a, m8l b).
 * \impl
dst[0:7] = a[0:7] | ~b[0:7]
\endimpl
 * \see m8l_or(m8l a, m8l b)
 * \see m8l_not(m8l a)
 * \see m8l_nor(m8l a, m8l b)
 * \param a first \c m8l input vector-mask
 * \param b second \c m8l input vector-mask
 * \returns "bitwise ornot"ed \c m8l vector-mask
 */
m8l m8l_ornot(m8l a, m8l b);
/**
 * \ingroup mlogic
 * \related v16f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m16f input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16f_or(a, m16f_not(b))`
 * \attention This function should not be confused with m16f_nor(m16f a, m16f b).
 * \impl
dst[0:15] = a[0:15] | ~b[0:15]
\endimpl
 * \see m16f_or(m16f a, m16f b)
 * \see m16f_not(m16f a)
 * \see m16f_nor(m16f a, m16f b)
 * \param a first \c m16f input vector-mask
 * \param b second \c m16f input vector-mask
 * \returns "bitwise ornot"ed \c m16f vector-mask
 */
m16f m16f_ornot(m16f a, m16f b);
/**
 * \ingroup mlogic
 * \related v16i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c m16i input vector-masks \c a and \c b.
 *
 * \details Functionally equivalent to: \c `m16i_or(a, m16i_not(b))`
 * \attention This function should not be confused with m16i_nor(m16i a, m16i b).
 * \impl
dst[0:15] = a[0:15] | ~b[0:15]
\endimpl
 * \see m16i_or(m16i a, m16i b)
 * \see m16i_not(m16i a)
 * \see m16i_nor(m16i a, m16i b)
 * \param a first \c m16i input vector-mask
 * \param b second \c m16i input vector-mask
 * \returns "bitwise ornot"ed \c m16i vector-mask
 */
m16i m16i_ornot(m16i a, m16i b);


/* COMPARISONS */
/** \defgroup cmp comparison functions
 * 
 */

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1d vectors \c a and \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_eq(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1f vectors \c a and \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_eq(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1i vectors \c a and \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_eq(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v1l vectors \c a and \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_eq(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2d vectors \c a and \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_eq(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2f vectors \c a and \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_eq(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2i vectors \c a and \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_eq(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v2l vectors \c a and \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_eq(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4d vectors \c a and \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_eq(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4f vectors \c a and \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_eq(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4i vectors \c a and \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_eq(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v4l vectors \c a and \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_eq(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8d vectors \c a and \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_eq(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8f vectors \c a and \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_eq(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8i vectors \c a and \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_eq(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v8l vectors \c a and \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] == b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_eq(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v16f vectors \c a and \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_eq(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares the equality of the two input vectors
 * \details Compares the equality of the \c v16i vectors \c a and \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] == b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] == b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_eq(v16i a, v16i b);

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1d vectors \c a and \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_neq(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1f vectors \c a and \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_neq(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1i vectors \c a and \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_neq(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v1l vectors \c a and \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_neq(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2d vectors \c a and \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_neq(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2f vectors \c a and \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_neq(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2i vectors \c a and \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_neq(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v2l vectors \c a and \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_neq(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4d vectors \c a and \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_neq(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4f vectors \c a and \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_neq(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4i vectors \c a and \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_neq(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v4l vectors \c a and \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_neq(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8d vectors \c a and \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_neq(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8f vectors \c a and \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_neq(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8i vectors \c a and \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_neq(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v8l vectors \c a and \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] != b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_neq(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v16f vectors \c a and \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_neq(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares the inequality of the two input vectors
 * \details Compares the inequality of the \c v16i vectors \c a and \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] != b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] != b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_neq(v16i a, v16i b);

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_gt(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_gt(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_gt(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_gt(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_gt(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_gt(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_gt(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_gt(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_gt(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_gt(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_gt(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_gt(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_gt(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_gt(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_gt(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] > b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_gt(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_gt(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares if elements of \c a are greater than those of \c b.
 * \details Compares if elements of \c a are greater than those of \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] > b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] > b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_gt(v16i a, v16i b);

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_geq(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_geq(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_geq(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_geq(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_geq(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_geq(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_geq(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_geq(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_geq(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_geq(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_geq(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_geq(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_geq(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_geq(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_geq(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] >= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_geq(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_geq(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares if elements of \c a are greater than or equal to those of \c b.
 * \details Compares if elements of \c a are greater than or equal to those of \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] >= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] >= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_geq(v16i a, v16i b);

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_lt(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_lt(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_lt(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_lt(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_lt(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_lt(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_lt(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_lt(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_lt(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_lt(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_lt(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_lt(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_lt(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_lt(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_lt(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] < b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_lt(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_lt(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares if elements of \c a are less than those of \c b.
 * \details Compares if elements of \c a are less than those of \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] < b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] < b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_lt(v16i a, v16i b);

/**
 * \ingroup cmp
 * \related v1d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v1d vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1d_and(v1d, v1d)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns \c v1d vector acting like a mask
 */
v1d v1d_leq(v1d a, v1d b);
/**
 * \ingroup cmp
 * \related v1f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v1f vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1f_and(v1f, v1f)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns \c v1f vector acting like a mask
 */
v1f v1f_leq(v1f a, v1f b);
/**
 * \ingroup cmp
 * \related v1i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v1i vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1i_and(v1i, v1i)
 * \impl
for j from 0 to 0
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns \c v1i vector acting like a mask
 */
v1i v1i_leq(v1i a, v1i b);
/**
 * \ingroup cmp
 * \related v1l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v1l vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v1l_and(v1l, v1l)
 * \impl
for j from 0 to 0
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns \c v1l vector acting like a mask
 */
v1l v1l_leq(v1l a, v1l b);
/**
 * \ingroup cmp
 * \related v2d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v2d vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2d_and(v2d, v2d)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns \c v2d vector acting like a mask
 */
v2d v2d_leq(v2d a, v2d b);
/**
 * \ingroup cmp
 * \related v2f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v2f vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2f_and(v2f, v2f)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns \c v2f vector acting like a mask
 */
v2f v2f_leq(v2f a, v2f b);
/**
 * \ingroup cmp
 * \related v2i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v2i vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2i_and(v2i, v2i)
 * \impl
for j from 0 to 1
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns \c v2i vector acting like a mask
 */
v2i v2i_leq(v2i a, v2i b);
/**
 * \ingroup cmp
 * \related v2l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v2l vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v2l_and(v2l, v2l)
 * \impl
for j from 0 to 1
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns \c v2l vector acting like a mask
 */
v2l v2l_leq(v2l a, v2l b);
/**
 * \ingroup cmp
 * \related v4d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v4d vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4d_and(v4d, v4d)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns \c v4d vector acting like a mask
 */
v4d v4d_leq(v4d a, v4d b);
/**
 * \ingroup cmp
 * \related v4f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v4f vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4f_and(v4f, v4f)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns \c v4f vector acting like a mask
 */
v4f v4f_leq(v4f a, v4f b);
/**
 * \ingroup cmp
 * \related v4i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v4i vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4i_and(v4i, v4i)
 * \impl
for j from 0 to 3
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns \c v4i vector acting like a mask
 */
v4i v4i_leq(v4i a, v4i b);
/**
 * \ingroup cmp
 * \related v4l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v4l vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v4l_and(v4l, v4l)
 * \impl
for j from 0 to 3
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns \c v4l vector acting like a mask
 */
v4l v4l_leq(v4l a, v4l b);
/**
 * \ingroup cmp
 * \related v8d
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v8d vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8d_and(v8d, v8d)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns \c v8d vector acting like a mask
 */
v8d v8d_leq(v8d a, v8d b);
/**
 * \ingroup cmp
 * \related v8f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v8f vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8f_and(v8f, v8f)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns \c v8f vector acting like a mask
 */
v8f v8f_leq(v8f a, v8f b);
/**
 * \ingroup cmp
 * \related v8i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v8i vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8i_and(v8i, v8i)
 * \impl
for j from 0 to 7
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns \c v8i vector acting like a mask
 */
v8i v8i_leq(v8i a, v8i b);
/**
 * \ingroup cmp
 * \related v8l
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v8l vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v8l_and(v8l, v8l)
 * \impl
for j from 0 to 7
  i = j*64
  if a[j] <= b[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns \c v8l vector acting like a mask
 */
v8l v8l_leq(v8l a, v8l b);
/**
 * \ingroup cmp
 * \related v16f
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v16f vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16f_and(v16f, v16f)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns \c v16f vector acting like a mask
 */
v16f v16f_leq(v16f a, v16f b);
/**
 * \ingroup cmp
 * \related v16i
 * \brief Compares if elements of \c a are less than or equal to those of \c b.
 * \details Compares if elements of \c a are less than or equal to those of \c b.
 *  The result is a \c v16i vector where the ith element is all one bits if \c `a[i] <= b[i]` and all zero bits otherwise.
 *  The result vector can then be used as a masked using the logical operations such as v16i_and(v16i, v16i)
 * \impl
for j from 0 to 15
  i = j*32
  if a[j] <= b[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns \c v16i vector acting like a mask
 */
v16i v16i_leq(v16i a, v16i b);

/* LOGIC */
/** \defgroup logic logical functions
 * 
 */

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v1d input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] & b.bits[0:63]
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise and"ed \c v1d vector
 */
v1d v1d_and(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v1f input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] & b.bits[0:31]
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise and"ed \c v1f vector
 */
v1f v1f_and(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v1i input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] & b.bits[0:31]
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise and"ed \c v1i vector
 */
v1i v1i_and(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v1l input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] & b.bits[0:63]
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise and"ed \c v1l vector
 */
v1l v1l_and(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v2d input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] & b.bits[0:127]
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise and"ed \c v2d vector
 */
v2d v2d_and(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v2f input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] & b.bits[0:63]
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise and"ed \c v2f vector
 */
v2f v2f_and(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v2i input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] & b.bits[0:63]
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise and"ed \c v2i vector
 */
v2i v2i_and(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v2l input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] & b.bits[0:127]
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise and"ed \c v2l vector
 */
v2l v2l_and(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v4d input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] & b.bits[0:255]
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise and"ed \c v4d vector
 */
v4d v4d_and(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v4f input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] & b.bits[0:127]
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise and"ed \c v4f vector
 */
v4f v4f_and(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v4i input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] & b.bits[0:127]
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise and"ed \c v4i vector
 */
v4i v4i_and(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v4l input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] & b.bits[0:255]
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise and"ed \c v4l vector
 */
v4l v4l_and(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v8d input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] & b.bits[0:511]
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise and"ed \c v8d vector
 */
v8d v8d_and(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v8f input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] & b.bits[0:255]
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise and"ed \c v8f vector
 */
v8f v8f_and(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v8i input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] & b.bits[0:255]
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise and"ed \c v8i vector
 */
v8i v8i_and(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v8l input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] & b.bits[0:511]
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise and"ed \c v8l vector
 */
v8l v8l_and(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v16f input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] & b.bits[0:511]
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise and"ed \c v16f vector
 */
v16f v16f_and(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise and ( \c `a & b` )
 * \details Performs the bitwise and on the two \c v16i input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] & b.bits[0:511]
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise and"ed \c v16i vector
 */
v16i v16i_and(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v1d input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] | b.bits[0:63]
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise or"ed \c v1d vector
 */
v1d v1d_or(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v1f input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] | b.bits[0:31]
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise or"ed \c v1f vector
 */
v1f v1f_or(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v1i input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] | b.bits[0:31]
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise or"ed \c v1i vector
 */
v1i v1i_or(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v1l input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] | b.bits[0:63]
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise or"ed \c v1l vector
 */
v1l v1l_or(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v2d input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] | b.bits[0:127]
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise or"ed \c v2d vector
 */
v2d v2d_or(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v2f input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] | b.bits[0:63]
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise or"ed \c v2f vector
 */
v2f v2f_or(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v2i input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] | b.bits[0:63]
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise or"ed \c v2i vector
 */
v2i v2i_or(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v2l input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] | b.bits[0:127]
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise or"ed \c v2l vector
 */
v2l v2l_or(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v4d input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] | b.bits[0:255]
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise or"ed \c v4d vector
 */
v4d v4d_or(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v4f input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] | b.bits[0:127]
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise or"ed \c v4f vector
 */
v4f v4f_or(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v4i input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] | b.bits[0:127]
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise or"ed \c v4i vector
 */
v4i v4i_or(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v4l input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] | b.bits[0:255]
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise or"ed \c v4l vector
 */
v4l v4l_or(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v8d input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] | b.bits[0:511]
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise or"ed \c v8d vector
 */
v8d v8d_or(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v8f input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] | b.bits[0:255]
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise or"ed \c v8f vector
 */
v8f v8f_or(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v8i input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] | b.bits[0:255]
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise or"ed \c v8i vector
 */
v8i v8i_or(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v8l input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] | b.bits[0:511]
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise or"ed \c v8l vector
 */
v8l v8l_or(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v16f input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] | b.bits[0:511]
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise or"ed \c v16f vector
 */
v16f v16f_or(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise or ( \c `a | b` )
 * \details Performs the bitwise or on the two \c v16i input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] | b.bits[0:511]
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise or"ed \c v16i vector
 */
v16i v16i_or(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v1d input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] ^ b.bits[0:63]
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise xor"ed \c v1d vector
 */
v1d v1d_xor(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v1f input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] ^ b.bits[0:31]
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise xor"ed \c v1f vector
 */
v1f v1f_xor(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v1i input vectors \c a and \c b.
 * \impl
dst.bits[0:31] = a.bits[0:31] ^ b.bits[0:31]
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise xor"ed \c v1i vector
 */
v1i v1i_xor(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v1l input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] ^ b.bits[0:63]
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise xor"ed \c v1l vector
 */
v1l v1l_xor(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v2d input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] ^ b.bits[0:127]
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise xor"ed \c v2d vector
 */
v2d v2d_xor(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v2f input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] ^ b.bits[0:63]
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise xor"ed \c v2f vector
 */
v2f v2f_xor(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v2i input vectors \c a and \c b.
 * \impl
dst.bits[0:63] = a.bits[0:63] ^ b.bits[0:63]
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise xor"ed \c v2i vector
 */
v2i v2i_xor(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v2l input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] ^ b.bits[0:127]
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise xor"ed \c v2l vector
 */
v2l v2l_xor(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v4d input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] ^ b.bits[0:255]
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise xor"ed \c v4d vector
 */
v4d v4d_xor(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v4f input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] ^ b.bits[0:127]
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise xor"ed \c v4f vector
 */
v4f v4f_xor(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v4i input vectors \c a and \c b.
 * \impl
dst.bits[0:127] = a.bits[0:127] ^ b.bits[0:127]
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise xor"ed \c v4i vector
 */
v4i v4i_xor(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v4l input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] ^ b.bits[0:255]
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise xor"ed \c v4l vector
 */
v4l v4l_xor(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v8d input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] ^ b.bits[0:511]
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise xor"ed \c v8d vector
 */
v8d v8d_xor(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v8f input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] ^ b.bits[0:255]
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise xor"ed \c v8f vector
 */
v8f v8f_xor(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v8i input vectors \c a and \c b.
 * \impl
dst.bits[0:255] = a.bits[0:255] ^ b.bits[0:255]
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise xor"ed \c v8i vector
 */
v8i v8i_xor(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v8l input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] ^ b.bits[0:511]
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise xor"ed \c v8l vector
 */
v8l v8l_xor(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v16f input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] ^ b.bits[0:511]
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise xor"ed \c v16f vector
 */
v16f v16f_xor(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise xor ( \c `a ^ b` )
 * \details Performs the bitwise xor on the two \c v16i input vectors \c a and \c b.
 * \impl
dst.bits[0:511] = a.bits[0:511] ^ b.bits[0:511]
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise xor"ed \c v16i vector
 */
v16i v16i_xor(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v1d input vector \c a.
 * \impl
dst.bits[0:63] = ~a.bits[0:63]
\endimpl
 * \param a \c v1d input vector
 * \returns "bitwise not"ed \c v1d vector
 */
v1d v1d_not(v1d a);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v1f input vector \c a.
 * \impl
dst.bits[0:31] = ~a.bits[0:31]
\endimpl
 * \param a \c v1f input vector
 * \returns "bitwise not"ed \c v1f vector
 */
v1f v1f_not(v1f a);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v1i input vector \c a.
 * \impl
dst.bits[0:31] = ~a.bits[0:31]
\endimpl
 * \param a \c v1i input vector
 * \returns "bitwise not"ed \c v1i vector
 */
v1i v1i_not(v1i a);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v1l input vector \c a.
 * \impl
dst.bits[0:63] = ~a.bits[0:63]
\endimpl
 * \param a \c v1l input vector
 * \returns "bitwise not"ed \c v1l vector
 */
v1l v1l_not(v1l a);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v2d input vector \c a.
 * \impl
dst.bits[0:127] = ~a.bits[0:127]
\endimpl
 * \param a \c v2d input vector
 * \returns "bitwise not"ed \c v2d vector
 */
v2d v2d_not(v2d a);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v2f input vector \c a.
 * \impl
dst.bits[0:63] = ~a.bits[0:63]
\endimpl
 * \param a \c v2f input vector
 * \returns "bitwise not"ed \c v2f vector
 */
v2f v2f_not(v2f a);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v2i input vector \c a.
 * \impl
dst.bits[0:63] = ~a.bits[0:63]
\endimpl
 * \param a \c v2i input vector
 * \returns "bitwise not"ed \c v2i vector
 */
v2i v2i_not(v2i a);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v2l input vector \c a.
 * \impl
dst.bits[0:127] = ~a.bits[0:127]
\endimpl
 * \param a \c v2l input vector
 * \returns "bitwise not"ed \c v2l vector
 */
v2l v2l_not(v2l a);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v4d input vector \c a.
 * \impl
dst.bits[0:255] = ~a.bits[0:255]
\endimpl
 * \param a \c v4d input vector
 * \returns "bitwise not"ed \c v4d vector
 */
v4d v4d_not(v4d a);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v4f input vector \c a.
 * \impl
dst.bits[0:127] = ~a.bits[0:127]
\endimpl
 * \param a \c v4f input vector
 * \returns "bitwise not"ed \c v4f vector
 */
v4f v4f_not(v4f a);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v4i input vector \c a.
 * \impl
dst.bits[0:127] = ~a.bits[0:127]
\endimpl
 * \param a \c v4i input vector
 * \returns "bitwise not"ed \c v4i vector
 */
v4i v4i_not(v4i a);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v4l input vector \c a.
 * \impl
dst.bits[0:255] = ~a.bits[0:255]
\endimpl
 * \param a \c v4l input vector
 * \returns "bitwise not"ed \c v4l vector
 */
v4l v4l_not(v4l a);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v8d input vector \c a.
 * \impl
dst.bits[0:511] = ~a.bits[0:511]
\endimpl
 * \param a \c v8d input vector
 * \returns "bitwise not"ed \c v8d vector
 */
v8d v8d_not(v8d a);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v8f input vector \c a.
 * \impl
dst.bits[0:255] = ~a.bits[0:255]
\endimpl
 * \param a \c v8f input vector
 * \returns "bitwise not"ed \c v8f vector
 */
v8f v8f_not(v8f a);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v8i input vector \c a.
 * \impl
dst.bits[0:255] = ~a.bits[0:255]
\endimpl
 * \param a \c v8i input vector
 * \returns "bitwise not"ed \c v8i vector
 */
v8i v8i_not(v8i a);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v8l input vector \c a.
 * \impl
dst.bits[0:511] = ~a.bits[0:511]
\endimpl
 * \param a \c v8l input vector
 * \returns "bitwise not"ed \c v8l vector
 */
v8l v8l_not(v8l a);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v16f input vector \c a.
 * \impl
dst.bits[0:511] = ~a.bits[0:511]
\endimpl
 * \param a \c v16f input vector
 * \returns "bitwise not"ed \c v16f vector
 */
v16f v16f_not(v16f a);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise not ( \c `~a` )
 * \details Performs the bitwise not on the \c v16i input vector \c a.
 * \impl
dst.bits[0:511] = ~a.bits[0:511]
\endimpl
 * \param a \c v16i input vector
 * \returns "bitwise not"ed \c v16i vector
 */
v16i v16i_not(v16i a);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v1d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1d_not(v1d_and(a, b))`
 * \attention This function should not be confused with v1d_andnot(v1d a, v1d b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] & b.bits[0:63])
\endimpl
 * \see v1d_and(v1d a, v1d b)
 * \see v1d_not(v1d a)
 * \see v1d_andnot(v1d a, v1d b)
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise nand"ed \c v1d vector
 */
v1d v1d_nand(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v1f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1f_not(v1f_and(a, b))`
 * \attention This function should not be confused with v1f_andnot(v1f a, v1f b).
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] & b.bits[0:31])
\endimpl
 * \see v1f_and(v1f a, v1f b)
 * \see v1f_not(v1f a)
 * \see v1f_andnot(v1f a, v1f b)
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise nand"ed \c v1f vector
 */
v1f v1f_nand(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v1i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1i_not(v1i_and(a, b))`
 * \attention This function should not be confused with v1i_andnot(v1i a, v1i b).
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] & b.bits[0:31])
\endimpl
 * \see v1i_and(v1i a, v1i b)
 * \see v1i_not(v1i a)
 * \see v1i_andnot(v1i a, v1i b)
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise nand"ed \c v1i vector
 */
v1i v1i_nand(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v1l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1l_not(v1l_and(a, b))`
 * \attention This function should not be confused with v1l_andnot(v1l a, v1l b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] & b.bits[0:63])
\endimpl
 * \see v1l_and(v1l a, v1l b)
 * \see v1l_not(v1l a)
 * \see v1l_andnot(v1l a, v1l b)
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise nand"ed \c v1l vector
 */
v1l v1l_nand(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v2d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2d_not(v2d_and(a, b))`
 * \attention This function should not be confused with v2d_andnot(v2d a, v2d b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] & b.bits[0:127])
\endimpl
 * \see v2d_and(v2d a, v2d b)
 * \see v2d_not(v2d a)
 * \see v2d_andnot(v2d a, v2d b)
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise nand"ed \c v2d vector
 */
v2d v2d_nand(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v2f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2f_not(v2f_and(a, b))`
 * \attention This function should not be confused with v2f_andnot(v2f a, v2f b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] & b.bits[0:63])
\endimpl
 * \see v2f_and(v2f a, v2f b)
 * \see v2f_not(v2f a)
 * \see v2f_andnot(v2f a, v2f b)
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise nand"ed \c v2f vector
 */
v2f v2f_nand(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v2i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2i_not(v2i_and(a, b))`
 * \attention This function should not be confused with v2i_andnot(v2i a, v2i b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] & b.bits[0:63])
\endimpl
 * \see v2i_and(v2i a, v2i b)
 * \see v2i_not(v2i a)
 * \see v2i_andnot(v2i a, v2i b)
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise nand"ed \c v2i vector
 */
v2i v2i_nand(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v2l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2l_not(v2l_and(a, b))`
 * \attention This function should not be confused with v2l_andnot(v2l a, v2l b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] & b.bits[0:127])
\endimpl
 * \see v2l_and(v2l a, v2l b)
 * \see v2l_not(v2l a)
 * \see v2l_andnot(v2l a, v2l b)
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise nand"ed \c v2l vector
 */
v2l v2l_nand(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v4d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4d_not(v4d_and(a, b))`
 * \attention This function should not be confused with v4d_andnot(v4d a, v4d b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] & b.bits[0:255])
\endimpl
 * \see v4d_and(v4d a, v4d b)
 * \see v4d_not(v4d a)
 * \see v4d_andnot(v4d a, v4d b)
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise nand"ed \c v4d vector
 */
v4d v4d_nand(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v4f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4f_not(v4f_and(a, b))`
 * \attention This function should not be confused with v4f_andnot(v4f a, v4f b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] & b.bits[0:127])
\endimpl
 * \see v4f_and(v4f a, v4f b)
 * \see v4f_not(v4f a)
 * \see v4f_andnot(v4f a, v4f b)
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise nand"ed \c v4f vector
 */
v4f v4f_nand(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v4i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4i_not(v4i_and(a, b))`
 * \attention This function should not be confused with v4i_andnot(v4i a, v4i b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] & b.bits[0:127])
\endimpl
 * \see v4i_and(v4i a, v4i b)
 * \see v4i_not(v4i a)
 * \see v4i_andnot(v4i a, v4i b)
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise nand"ed \c v4i vector
 */
v4i v4i_nand(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v4l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4l_not(v4l_and(a, b))`
 * \attention This function should not be confused with v4l_andnot(v4l a, v4l b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] & b.bits[0:255])
\endimpl
 * \see v4l_and(v4l a, v4l b)
 * \see v4l_not(v4l a)
 * \see v4l_andnot(v4l a, v4l b)
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise nand"ed \c v4l vector
 */
v4l v4l_nand(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v8d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8d_not(v8d_and(a, b))`
 * \attention This function should not be confused with v8d_andnot(v8d a, v8d b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] & b.bits[0:511])
\endimpl
 * \see v8d_and(v8d a, v8d b)
 * \see v8d_not(v8d a)
 * \see v8d_andnot(v8d a, v8d b)
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise nand"ed \c v8d vector
 */
v8d v8d_nand(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v8f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8f_not(v8f_and(a, b))`
 * \attention This function should not be confused with v8f_andnot(v8f a, v8f b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] & b.bits[0:255])
\endimpl
 * \see v8f_and(v8f a, v8f b)
 * \see v8f_not(v8f a)
 * \see v8f_andnot(v8f a, v8f b)
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise nand"ed \c v8f vector
 */
v8f v8f_nand(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v8i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8i_not(v8i_and(a, b))`
 * \attention This function should not be confused with v8i_andnot(v8i a, v8i b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] & b.bits[0:255])
\endimpl
 * \see v8i_and(v8i a, v8i b)
 * \see v8i_not(v8i a)
 * \see v8i_andnot(v8i a, v8i b)
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise nand"ed \c v8i vector
 */
v8i v8i_nand(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v8l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8l_not(v8l_and(a, b))`
 * \attention This function should not be confused with v8l_andnot(v8l a, v8l b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] & b.bits[0:511])
\endimpl
 * \see v8l_and(v8l a, v8l b)
 * \see v8l_not(v8l a)
 * \see v8l_andnot(v8l a, v8l b)
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise nand"ed \c v8l vector
 */
v8l v8l_nand(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v16f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16f_not(v16f_and(a, b))`
 * \attention This function should not be confused with v16f_andnot(v16f a, v16f b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] & b.bits[0:511])
\endimpl
 * \see v16f_and(v16f a, v16f b)
 * \see v16f_not(v16f a)
 * \see v16f_andnot(v16f a, v16f b)
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise nand"ed \c v16f vector
 */
v16f v16f_nand(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise nand ( \c `~(a & b)` )
 * \details Performs the bitwise nand on the two \c v16i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16i_not(v16i_and(a, b))`
 * \attention This function should not be confused with v16i_andnot(v16i a, v16i b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] & b.bits[0:511])
\endimpl
 * \see v16i_and(v16i a, v16i b)
 * \see v16i_not(v16i a)
 * \see v16i_andnot(v16i a, v16i b)
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise nand"ed \c v16i vector
 */
v16i v16i_nand(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v1d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1d_not(v1d_or(a, b))`
 * \attention This function should not be confused with v1d_ornot(v1d a, v1d b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] | b.bits[0:63])
\endimpl
 * \see v1d_or(v1d a, v1d b)
 * \see v1d_not(v1d a)
 * \see v1d_ornot(v1d a, v1d b)
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise nor"ed \c v1d vector
 */
v1d v1d_nor(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v1f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1f_not(v1f_or(a, b))`
 * \attention This function should not be confused with v1f_ornot(v1f a, v1f b).
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] | b.bits[0:31])
\endimpl
 * \see v1f_or(v1f a, v1f b)
 * \see v1f_not(v1f a)
 * \see v1f_ornot(v1f a, v1f b)
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise nor"ed \c v1f vector
 */
v1f v1f_nor(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v1i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1i_not(v1i_or(a, b))`
 * \attention This function should not be confused with v1i_ornot(v1i a, v1i b).
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] | b.bits[0:31])
\endimpl
 * \see v1i_or(v1i a, v1i b)
 * \see v1i_not(v1i a)
 * \see v1i_ornot(v1i a, v1i b)
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise nor"ed \c v1i vector
 */
v1i v1i_nor(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v1l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1l_not(v1l_or(a, b))`
 * \attention This function should not be confused with v1l_ornot(v1l a, v1l b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] | b.bits[0:63])
\endimpl
 * \see v1l_or(v1l a, v1l b)
 * \see v1l_not(v1l a)
 * \see v1l_ornot(v1l a, v1l b)
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise nor"ed \c v1l vector
 */
v1l v1l_nor(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v2d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2d_not(v2d_or(a, b))`
 * \attention This function should not be confused with v2d_ornot(v2d a, v2d b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] | b.bits[0:127])
\endimpl
 * \see v2d_or(v2d a, v2d b)
 * \see v2d_not(v2d a)
 * \see v2d_ornot(v2d a, v2d b)
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise nor"ed \c v2d vector
 */
v2d v2d_nor(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v2f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2f_not(v2f_or(a, b))`
 * \attention This function should not be confused with v2f_ornot(v2f a, v2f b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] | b.bits[0:63])
\endimpl
 * \see v2f_or(v2f a, v2f b)
 * \see v2f_not(v2f a)
 * \see v2f_ornot(v2f a, v2f b)
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise nor"ed \c v2f vector
 */
v2f v2f_nor(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v2i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2i_not(v2i_or(a, b))`
 * \attention This function should not be confused with v2i_ornot(v2i a, v2i b).
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] | b.bits[0:63])
\endimpl
 * \see v2i_or(v2i a, v2i b)
 * \see v2i_not(v2i a)
 * \see v2i_ornot(v2i a, v2i b)
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise nor"ed \c v2i vector
 */
v2i v2i_nor(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v2l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2l_not(v2l_or(a, b))`
 * \attention This function should not be confused with v2l_ornot(v2l a, v2l b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] | b.bits[0:127])
\endimpl
 * \see v2l_or(v2l a, v2l b)
 * \see v2l_not(v2l a)
 * \see v2l_ornot(v2l a, v2l b)
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise nor"ed \c v2l vector
 */
v2l v2l_nor(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v4d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4d_not(v4d_or(a, b))`
 * \attention This function should not be confused with v4d_ornot(v4d a, v4d b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] | b.bits[0:255])
\endimpl
 * \see v4d_or(v4d a, v4d b)
 * \see v4d_not(v4d a)
 * \see v4d_ornot(v4d a, v4d b)
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise nor"ed \c v4d vector
 */
v4d v4d_nor(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v4f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4f_not(v4f_or(a, b))`
 * \attention This function should not be confused with v4f_ornot(v4f a, v4f b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] | b.bits[0:127])
\endimpl
 * \see v4f_or(v4f a, v4f b)
 * \see v4f_not(v4f a)
 * \see v4f_ornot(v4f a, v4f b)
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise nor"ed \c v4f vector
 */
v4f v4f_nor(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v4i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4i_not(v4i_or(a, b))`
 * \attention This function should not be confused with v4i_ornot(v4i a, v4i b).
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] | b.bits[0:127])
\endimpl
 * \see v4i_or(v4i a, v4i b)
 * \see v4i_not(v4i a)
 * \see v4i_ornot(v4i a, v4i b)
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise nor"ed \c v4i vector
 */
v4i v4i_nor(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v4l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4l_not(v4l_or(a, b))`
 * \attention This function should not be confused with v4l_ornot(v4l a, v4l b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] | b.bits[0:255])
\endimpl
 * \see v4l_or(v4l a, v4l b)
 * \see v4l_not(v4l a)
 * \see v4l_ornot(v4l a, v4l b)
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise nor"ed \c v4l vector
 */
v4l v4l_nor(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v8d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8d_not(v8d_or(a, b))`
 * \attention This function should not be confused with v8d_ornot(v8d a, v8d b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] | b.bits[0:511])
\endimpl
 * \see v8d_or(v8d a, v8d b)
 * \see v8d_not(v8d a)
 * \see v8d_ornot(v8d a, v8d b)
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise nor"ed \c v8d vector
 */
v8d v8d_nor(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v8f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8f_not(v8f_or(a, b))`
 * \attention This function should not be confused with v8f_ornot(v8f a, v8f b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] | b.bits[0:255])
\endimpl
 * \see v8f_or(v8f a, v8f b)
 * \see v8f_not(v8f a)
 * \see v8f_ornot(v8f a, v8f b)
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise nor"ed \c v8f vector
 */
v8f v8f_nor(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v8i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8i_not(v8i_or(a, b))`
 * \attention This function should not be confused with v8i_ornot(v8i a, v8i b).
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] | b.bits[0:255])
\endimpl
 * \see v8i_or(v8i a, v8i b)
 * \see v8i_not(v8i a)
 * \see v8i_ornot(v8i a, v8i b)
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise nor"ed \c v8i vector
 */
v8i v8i_nor(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v8l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8l_not(v8l_or(a, b))`
 * \attention This function should not be confused with v8l_ornot(v8l a, v8l b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] | b.bits[0:511])
\endimpl
 * \see v8l_or(v8l a, v8l b)
 * \see v8l_not(v8l a)
 * \see v8l_ornot(v8l a, v8l b)
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise nor"ed \c v8l vector
 */
v8l v8l_nor(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v16f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16f_not(v16f_or(a, b))`
 * \attention This function should not be confused with v16f_ornot(v16f a, v16f b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] | b.bits[0:511])
\endimpl
 * \see v16f_or(v16f a, v16f b)
 * \see v16f_not(v16f a)
 * \see v16f_ornot(v16f a, v16f b)
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise nor"ed \c v16f vector
 */
v16f v16f_nor(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise nor ( \c `~(a | b)` )
 * \details Performs the bitwise nor on the two \c v16i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16i_not(v16i_or(a, b))`
 * \attention This function should not be confused with v16i_ornot(v16i a, v16i b).
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] | b.bits[0:511])
\endimpl
 * \see v16i_or(v16i a, v16i b)
 * \see v16i_not(v16i a)
 * \see v16i_ornot(v16i a, v16i b)
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise nor"ed \c v16i vector
 */
v16i v16i_nor(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v1d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1d_not(v1d_xor(a, b))`
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] ^ b.bits[0:63])
\endimpl
 * \see v1d_xor(v1d a, v1d b)
 * \see v1d_not(v1d a)
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise nxor"ed \c v1d vector
 */
v1d v1d_nxor(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v1f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1f_not(v1f_xor(a, b))`
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] ^ b.bits[0:31])
\endimpl
 * \see v1f_xor(v1f a, v1f b)
 * \see v1f_not(v1f a)
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise nxor"ed \c v1f vector
 */
v1f v1f_nxor(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v1i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1i_not(v1i_xor(a, b))`
 * \impl
dst.bits[0:31] = ~(a.bits[0:31] ^ b.bits[0:31])
\endimpl
 * \see v1i_xor(v1i a, v1i b)
 * \see v1i_not(v1i a)
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise nxor"ed \c v1i vector
 */
v1i v1i_nxor(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v1l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1l_not(v1l_xor(a, b))`
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] ^ b.bits[0:63])
\endimpl
 * \see v1l_xor(v1l a, v1l b)
 * \see v1l_not(v1l a)
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise nxor"ed \c v1l vector
 */
v1l v1l_nxor(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v2d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2d_not(v2d_xor(a, b))`
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] ^ b.bits[0:127])
\endimpl
 * \see v2d_xor(v2d a, v2d b)
 * \see v2d_not(v2d a)
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise nxor"ed \c v2d vector
 */
v2d v2d_nxor(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v2f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2f_not(v2f_xor(a, b))`
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] ^ b.bits[0:63])
\endimpl
 * \see v2f_xor(v2f a, v2f b)
 * \see v2f_not(v2f a)
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise nxor"ed \c v2f vector
 */
v2f v2f_nxor(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v2i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2i_not(v2i_xor(a, b))`
 * \impl
dst.bits[0:63] = ~(a.bits[0:63] ^ b.bits[0:63])
\endimpl
 * \see v2i_xor(v2i a, v2i b)
 * \see v2i_not(v2i a)
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise nxor"ed \c v2i vector
 */
v2i v2i_nxor(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v2l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2l_not(v2l_xor(a, b))`
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] ^ b.bits[0:127])
\endimpl
 * \see v2l_xor(v2l a, v2l b)
 * \see v2l_not(v2l a)
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise nxor"ed \c v2l vector
 */
v2l v2l_nxor(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v4d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4d_not(v4d_xor(a, b))`
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] ^ b.bits[0:255])
\endimpl
 * \see v4d_xor(v4d a, v4d b)
 * \see v4d_not(v4d a)
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise nxor"ed \c v4d vector
 */
v4d v4d_nxor(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v4f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4f_not(v4f_xor(a, b))`
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] ^ b.bits[0:127])
\endimpl
 * \see v4f_xor(v4f a, v4f b)
 * \see v4f_not(v4f a)
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise nxor"ed \c v4f vector
 */
v4f v4f_nxor(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v4i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4i_not(v4i_xor(a, b))`
 * \impl
dst.bits[0:127] = ~(a.bits[0:127] ^ b.bits[0:127])
\endimpl
 * \see v4i_xor(v4i a, v4i b)
 * \see v4i_not(v4i a)
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise nxor"ed \c v4i vector
 */
v4i v4i_nxor(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v4l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4l_not(v4l_xor(a, b))`
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] ^ b.bits[0:255])
\endimpl
 * \see v4l_xor(v4l a, v4l b)
 * \see v4l_not(v4l a)
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise nxor"ed \c v4l vector
 */
v4l v4l_nxor(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v8d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8d_not(v8d_xor(a, b))`
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] ^ b.bits[0:511])
\endimpl
 * \see v8d_xor(v8d a, v8d b)
 * \see v8d_not(v8d a)
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise nxor"ed \c v8d vector
 */
v8d v8d_nxor(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v8f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8f_not(v8f_xor(a, b))`
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] ^ b.bits[0:255])
\endimpl
 * \see v8f_xor(v8f a, v8f b)
 * \see v8f_not(v8f a)
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise nxor"ed \c v8f vector
 */
v8f v8f_nxor(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v8i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8i_not(v8i_xor(a, b))`
 * \impl
dst.bits[0:255] = ~(a.bits[0:255] ^ b.bits[0:255])
\endimpl
 * \see v8i_xor(v8i a, v8i b)
 * \see v8i_not(v8i a)
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise nxor"ed \c v8i vector
 */
v8i v8i_nxor(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v8l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8l_not(v8l_xor(a, b))`
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] ^ b.bits[0:511])
\endimpl
 * \see v8l_xor(v8l a, v8l b)
 * \see v8l_not(v8l a)
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise nxor"ed \c v8l vector
 */
v8l v8l_nxor(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v16f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16f_not(v16f_xor(a, b))`
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] ^ b.bits[0:511])
\endimpl
 * \see v16f_xor(v16f a, v16f b)
 * \see v16f_not(v16f a)
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise nxor"ed \c v16f vector
 */
v16f v16f_nxor(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise nxor ( \c `~(a ^ b)` )
 * \details Performs the bitwise nxor on the two \c v16i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16i_not(v16i_xor(a, b))`
 * \impl
dst.bits[0:511] = ~(a.bits[0:511] ^ b.bits[0:511])
\endimpl
 * \see v16i_xor(v16i a, v16i b)
 * \see v16i_not(v16i a)
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise nxor"ed \c v16i vector
 */
v16i v16i_nxor(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v1d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1d_and(a, v1d_not(b))`
 * \attention This function should not be confused with v1d_nand(v1d a, v1d b).
 * \impl
dst.bits[0:63] = a.bits[0:63] & ~b.bits[0:63]
\endimpl
 * \see v1d_and(v1d a, v1d b)
 * \see v1d_not(v1d a)
 * \see v1d_nand(v1d a, v1d b)
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise andnot"ed \c v1d vector
 */
v1d v1d_andnot(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v1f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1f_and(a, v1f_not(b))`
 * \attention This function should not be confused with v1f_nand(v1f a, v1f b).
 * \impl
dst.bits[0:31] = a.bits[0:31] & ~b.bits[0:31]
\endimpl
 * \see v1f_and(v1f a, v1f b)
 * \see v1f_not(v1f a)
 * \see v1f_nand(v1f a, v1f b)
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise andnot"ed \c v1f vector
 */
v1f v1f_andnot(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v1i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1i_and(a, v1i_not(b))`
 * \attention This function should not be confused with v1i_nand(v1i a, v1i b).
 * \impl
dst.bits[0:31] = a.bits[0:31] & ~b.bits[0:31]
\endimpl
 * \see v1i_and(v1i a, v1i b)
 * \see v1i_not(v1i a)
 * \see v1i_nand(v1i a, v1i b)
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise andnot"ed \c v1i vector
 */
v1i v1i_andnot(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v1l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1l_and(a, v1l_not(b))`
 * \attention This function should not be confused with v1l_nand(v1l a, v1l b).
 * \impl
dst.bits[0:63] = a.bits[0:63] & ~b.bits[0:63]
\endimpl
 * \see v1l_and(v1l a, v1l b)
 * \see v1l_not(v1l a)
 * \see v1l_nand(v1l a, v1l b)
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise andnot"ed \c v1l vector
 */
v1l v1l_andnot(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v2d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2d_and(a, v2d_not(b))`
 * \attention This function should not be confused with v2d_nand(v2d a, v2d b).
 * \impl
dst.bits[0:127] = a.bits[0:127] & ~b.bits[0:127]
\endimpl
 * \see v2d_and(v2d a, v2d b)
 * \see v2d_not(v2d a)
 * \see v2d_nand(v2d a, v2d b)
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise andnot"ed \c v2d vector
 */
v2d v2d_andnot(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v2f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2f_and(a, v2f_not(b))`
 * \attention This function should not be confused with v2f_nand(v2f a, v2f b).
 * \impl
dst.bits[0:63] = a.bits[0:63] & ~b.bits[0:63]
\endimpl
 * \see v2f_and(v2f a, v2f b)
 * \see v2f_not(v2f a)
 * \see v2f_nand(v2f a, v2f b)
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise andnot"ed \c v2f vector
 */
v2f v2f_andnot(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v2i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2i_and(a, v2i_not(b))`
 * \attention This function should not be confused with v2i_nand(v2i a, v2i b).
 * \impl
dst.bits[0:63] = a.bits[0:63] & ~b.bits[0:63]
\endimpl
 * \see v2i_and(v2i a, v2i b)
 * \see v2i_not(v2i a)
 * \see v2i_nand(v2i a, v2i b)
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise andnot"ed \c v2i vector
 */
v2i v2i_andnot(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v2l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2l_and(a, v2l_not(b))`
 * \attention This function should not be confused with v2l_nand(v2l a, v2l b).
 * \impl
dst.bits[0:127] = a.bits[0:127] & ~b.bits[0:127]
\endimpl
 * \see v2l_and(v2l a, v2l b)
 * \see v2l_not(v2l a)
 * \see v2l_nand(v2l a, v2l b)
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise andnot"ed \c v2l vector
 */
v2l v2l_andnot(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v4d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4d_and(a, v4d_not(b))`
 * \attention This function should not be confused with v4d_nand(v4d a, v4d b).
 * \impl
dst.bits[0:255] = a.bits[0:255] & ~b.bits[0:255]
\endimpl
 * \see v4d_and(v4d a, v4d b)
 * \see v4d_not(v4d a)
 * \see v4d_nand(v4d a, v4d b)
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise andnot"ed \c v4d vector
 */
v4d v4d_andnot(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v4f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4f_and(a, v4f_not(b))`
 * \attention This function should not be confused with v4f_nand(v4f a, v4f b).
 * \impl
dst.bits[0:127] = a.bits[0:127] & ~b.bits[0:127]
\endimpl
 * \see v4f_and(v4f a, v4f b)
 * \see v4f_not(v4f a)
 * \see v4f_nand(v4f a, v4f b)
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise andnot"ed \c v4f vector
 */
v4f v4f_andnot(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v4i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4i_and(a, v4i_not(b))`
 * \attention This function should not be confused with v4i_nand(v4i a, v4i b).
 * \impl
dst.bits[0:127] = a.bits[0:127] & ~b.bits[0:127]
\endimpl
 * \see v4i_and(v4i a, v4i b)
 * \see v4i_not(v4i a)
 * \see v4i_nand(v4i a, v4i b)
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise andnot"ed \c v4i vector
 */
v4i v4i_andnot(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v4l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4l_and(a, v4l_not(b))`
 * \attention This function should not be confused with v4l_nand(v4l a, v4l b).
 * \impl
dst.bits[0:255] = a.bits[0:255] & ~b.bits[0:255]
\endimpl
 * \see v4l_and(v4l a, v4l b)
 * \see v4l_not(v4l a)
 * \see v4l_nand(v4l a, v4l b)
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise andnot"ed \c v4l vector
 */
v4l v4l_andnot(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v8d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8d_and(a, v8d_not(b))`
 * \attention This function should not be confused with v8d_nand(v8d a, v8d b).
 * \impl
dst.bits[0:511] = a.bits[0:511] & ~b.bits[0:511]
\endimpl
 * \see v8d_and(v8d a, v8d b)
 * \see v8d_not(v8d a)
 * \see v8d_nand(v8d a, v8d b)
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise andnot"ed \c v8d vector
 */
v8d v8d_andnot(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v8f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8f_and(a, v8f_not(b))`
 * \attention This function should not be confused with v8f_nand(v8f a, v8f b).
 * \impl
dst.bits[0:255] = a.bits[0:255] & ~b.bits[0:255]
\endimpl
 * \see v8f_and(v8f a, v8f b)
 * \see v8f_not(v8f a)
 * \see v8f_nand(v8f a, v8f b)
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise andnot"ed \c v8f vector
 */
v8f v8f_andnot(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v8i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8i_and(a, v8i_not(b))`
 * \attention This function should not be confused with v8i_nand(v8i a, v8i b).
 * \impl
dst.bits[0:255] = a.bits[0:255] & ~b.bits[0:255]
\endimpl
 * \see v8i_and(v8i a, v8i b)
 * \see v8i_not(v8i a)
 * \see v8i_nand(v8i a, v8i b)
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise andnot"ed \c v8i vector
 */
v8i v8i_andnot(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v8l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8l_and(a, v8l_not(b))`
 * \attention This function should not be confused with v8l_nand(v8l a, v8l b).
 * \impl
dst.bits[0:511] = a.bits[0:511] & ~b.bits[0:511]
\endimpl
 * \see v8l_and(v8l a, v8l b)
 * \see v8l_not(v8l a)
 * \see v8l_nand(v8l a, v8l b)
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise andnot"ed \c v8l vector
 */
v8l v8l_andnot(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v16f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16f_and(a, v16f_not(b))`
 * \attention This function should not be confused with v16f_nand(v16f a, v16f b).
 * \impl
dst.bits[0:511] = a.bits[0:511] & ~b.bits[0:511]
\endimpl
 * \see v16f_and(v16f a, v16f b)
 * \see v16f_not(v16f a)
 * \see v16f_nand(v16f a, v16f b)
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise andnot"ed \c v16f vector
 */
v16f v16f_andnot(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise andnot ( \c `a & ~b` )
 * \details Performs the bitwise andnot on the two \c v16i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16i_and(a, v16i_not(b))`
 * \attention This function should not be confused with v16i_nand(v16i a, v16i b).
 * \impl
dst.bits[0:511] = a.bits[0:511] & ~b.bits[0:511]
\endimpl
 * \see v16i_and(v16i a, v16i b)
 * \see v16i_not(v16i a)
 * \see v16i_nand(v16i a, v16i b)
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise andnot"ed \c v16i vector
 */
v16i v16i_andnot(v16i a, v16i b);

/**
 * \ingroup logic
 * \related v1d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v1d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1d_or(a, v1d_not(b))`
 * \attention This function should not be confused with v1d_nor(v1d a, v1d b).
 * \impl
dst.bits[0:63] = a.bits[0:63] | ~b.bits[0:63]
\endimpl
 * \see v1d_or(v1d a, v1d b)
 * \see v1d_not(v1d a)
 * \see v1d_nor(v1d a, v1d b)
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns "bitwise ornot"ed \c v1d vector
 */
v1d v1d_ornot(v1d a, v1d b);
/**
 * \ingroup logic
 * \related v1f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v1f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1f_or(a, v1f_not(b))`
 * \attention This function should not be confused with v1f_nor(v1f a, v1f b).
 * \impl
dst.bits[0:31] = a.bits[0:31] | ~b.bits[0:31]
\endimpl
 * \see v1f_or(v1f a, v1f b)
 * \see v1f_not(v1f a)
 * \see v1f_nor(v1f a, v1f b)
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns "bitwise ornot"ed \c v1f vector
 */
v1f v1f_ornot(v1f a, v1f b);
/**
 * \ingroup logic
 * \related v1i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v1i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1i_or(a, v1i_not(b))`
 * \attention This function should not be confused with v1i_nor(v1i a, v1i b).
 * \impl
dst.bits[0:31] = a.bits[0:31] | ~b.bits[0:31]
\endimpl
 * \see v1i_or(v1i a, v1i b)
 * \see v1i_not(v1i a)
 * \see v1i_nor(v1i a, v1i b)
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns "bitwise ornot"ed \c v1i vector
 */
v1i v1i_ornot(v1i a, v1i b);
/**
 * \ingroup logic
 * \related v1l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v1l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v1l_or(a, v1l_not(b))`
 * \attention This function should not be confused with v1l_nor(v1l a, v1l b).
 * \impl
dst.bits[0:63] = a.bits[0:63] | ~b.bits[0:63]
\endimpl
 * \see v1l_or(v1l a, v1l b)
 * \see v1l_not(v1l a)
 * \see v1l_nor(v1l a, v1l b)
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns "bitwise ornot"ed \c v1l vector
 */
v1l v1l_ornot(v1l a, v1l b);
/**
 * \ingroup logic
 * \related v2d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v2d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2d_or(a, v2d_not(b))`
 * \attention This function should not be confused with v2d_nor(v2d a, v2d b).
 * \impl
dst.bits[0:127] = a.bits[0:127] | ~b.bits[0:127]
\endimpl
 * \see v2d_or(v2d a, v2d b)
 * \see v2d_not(v2d a)
 * \see v2d_nor(v2d a, v2d b)
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns "bitwise ornot"ed \c v2d vector
 */
v2d v2d_ornot(v2d a, v2d b);
/**
 * \ingroup logic
 * \related v2f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v2f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2f_or(a, v2f_not(b))`
 * \attention This function should not be confused with v2f_nor(v2f a, v2f b).
 * \impl
dst.bits[0:63] = a.bits[0:63] | ~b.bits[0:63]
\endimpl
 * \see v2f_or(v2f a, v2f b)
 * \see v2f_not(v2f a)
 * \see v2f_nor(v2f a, v2f b)
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns "bitwise ornot"ed \c v2f vector
 */
v2f v2f_ornot(v2f a, v2f b);
/**
 * \ingroup logic
 * \related v2i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v2i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2i_or(a, v2i_not(b))`
 * \attention This function should not be confused with v2i_nor(v2i a, v2i b).
 * \impl
dst.bits[0:63] = a.bits[0:63] | ~b.bits[0:63]
\endimpl
 * \see v2i_or(v2i a, v2i b)
 * \see v2i_not(v2i a)
 * \see v2i_nor(v2i a, v2i b)
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns "bitwise ornot"ed \c v2i vector
 */
v2i v2i_ornot(v2i a, v2i b);
/**
 * \ingroup logic
 * \related v2l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v2l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v2l_or(a, v2l_not(b))`
 * \attention This function should not be confused with v2l_nor(v2l a, v2l b).
 * \impl
dst.bits[0:127] = a.bits[0:127] | ~b.bits[0:127]
\endimpl
 * \see v2l_or(v2l a, v2l b)
 * \see v2l_not(v2l a)
 * \see v2l_nor(v2l a, v2l b)
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns "bitwise ornot"ed \c v2l vector
 */
v2l v2l_ornot(v2l a, v2l b);
/**
 * \ingroup logic
 * \related v4d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v4d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4d_or(a, v4d_not(b))`
 * \attention This function should not be confused with v4d_nor(v4d a, v4d b).
 * \impl
dst.bits[0:255] = a.bits[0:255] | ~b.bits[0:255]
\endimpl
 * \see v4d_or(v4d a, v4d b)
 * \see v4d_not(v4d a)
 * \see v4d_nor(v4d a, v4d b)
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns "bitwise ornot"ed \c v4d vector
 */
v4d v4d_ornot(v4d a, v4d b);
/**
 * \ingroup logic
 * \related v4f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v4f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4f_or(a, v4f_not(b))`
 * \attention This function should not be confused with v4f_nor(v4f a, v4f b).
 * \impl
dst.bits[0:127] = a.bits[0:127] | ~b.bits[0:127]
\endimpl
 * \see v4f_or(v4f a, v4f b)
 * \see v4f_not(v4f a)
 * \see v4f_nor(v4f a, v4f b)
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns "bitwise ornot"ed \c v4f vector
 */
v4f v4f_ornot(v4f a, v4f b);
/**
 * \ingroup logic
 * \related v4i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v4i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4i_or(a, v4i_not(b))`
 * \attention This function should not be confused with v4i_nor(v4i a, v4i b).
 * \impl
dst.bits[0:127] = a.bits[0:127] | ~b.bits[0:127]
\endimpl
 * \see v4i_or(v4i a, v4i b)
 * \see v4i_not(v4i a)
 * \see v4i_nor(v4i a, v4i b)
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns "bitwise ornot"ed \c v4i vector
 */
v4i v4i_ornot(v4i a, v4i b);
/**
 * \ingroup logic
 * \related v4l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v4l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v4l_or(a, v4l_not(b))`
 * \attention This function should not be confused with v4l_nor(v4l a, v4l b).
 * \impl
dst.bits[0:255] = a.bits[0:255] | ~b.bits[0:255]
\endimpl
 * \see v4l_or(v4l a, v4l b)
 * \see v4l_not(v4l a)
 * \see v4l_nor(v4l a, v4l b)
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns "bitwise ornot"ed \c v4l vector
 */
v4l v4l_ornot(v4l a, v4l b);
/**
 * \ingroup logic
 * \related v8d
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v8d input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8d_or(a, v8d_not(b))`
 * \attention This function should not be confused with v8d_nor(v8d a, v8d b).
 * \impl
dst.bits[0:511] = a.bits[0:511] | ~b.bits[0:511]
\endimpl
 * \see v8d_or(v8d a, v8d b)
 * \see v8d_not(v8d a)
 * \see v8d_nor(v8d a, v8d b)
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns "bitwise ornot"ed \c v8d vector
 */
v8d v8d_ornot(v8d a, v8d b);
/**
 * \ingroup logic
 * \related v8f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v8f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8f_or(a, v8f_not(b))`
 * \attention This function should not be confused with v8f_nor(v8f a, v8f b).
 * \impl
dst.bits[0:255] = a.bits[0:255] | ~b.bits[0:255]
\endimpl
 * \see v8f_or(v8f a, v8f b)
 * \see v8f_not(v8f a)
 * \see v8f_nor(v8f a, v8f b)
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns "bitwise ornot"ed \c v8f vector
 */
v8f v8f_ornot(v8f a, v8f b);
/**
 * \ingroup logic
 * \related v8i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v8i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8i_or(a, v8i_not(b))`
 * \attention This function should not be confused with v8i_nor(v8i a, v8i b).
 * \impl
dst.bits[0:255] = a.bits[0:255] | ~b.bits[0:255]
\endimpl
 * \see v8i_or(v8i a, v8i b)
 * \see v8i_not(v8i a)
 * \see v8i_nor(v8i a, v8i b)
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns "bitwise ornot"ed \c v8i vector
 */
v8i v8i_ornot(v8i a, v8i b);
/**
 * \ingroup logic
 * \related v8l
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v8l input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v8l_or(a, v8l_not(b))`
 * \attention This function should not be confused with v8l_nor(v8l a, v8l b).
 * \impl
dst.bits[0:511] = a.bits[0:511] | ~b.bits[0:511]
\endimpl
 * \see v8l_or(v8l a, v8l b)
 * \see v8l_not(v8l a)
 * \see v8l_nor(v8l a, v8l b)
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns "bitwise ornot"ed \c v8l vector
 */
v8l v8l_ornot(v8l a, v8l b);
/**
 * \ingroup logic
 * \related v16f
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v16f input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16f_or(a, v16f_not(b))`
 * \attention This function should not be confused with v16f_nor(v16f a, v16f b).
 * \impl
dst.bits[0:511] = a.bits[0:511] | ~b.bits[0:511]
\endimpl
 * \see v16f_or(v16f a, v16f b)
 * \see v16f_not(v16f a)
 * \see v16f_nor(v16f a, v16f b)
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns "bitwise ornot"ed \c v16f vector
 */
v16f v16f_ornot(v16f a, v16f b);
/**
 * \ingroup logic
 * \related v16i
 * \brief Bitwise ornot ( \c `a | ~b` )
 * \details Performs the bitwise ornot on the two \c v16i input vectors \c a and \c b.
 *
 * \details Functionally equivalent to: \c `v16i_or(a, v16i_not(b))`
 * \attention This function should not be confused with v16i_nor(v16i a, v16i b).
 * \impl
dst.bits[0:511] = a.bits[0:511] | ~b.bits[0:511]
\endimpl
 * \see v16i_or(v16i a, v16i b)
 * \see v16i_not(v16i a)
 * \see v16i_nor(v16i a, v16i b)
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns "bitwise ornot"ed \c v16i vector
 */
v16i v16i_ornot(v16i a, v16i b);


/* ARITHMETIC AND MATH */
/** \defgroup arith arithmetic functions
 * 
 */

/** \defgroup math math functions
 * 
 */

/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v1d
 * \details Performs the addition element by element of the input two \c v1d vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Sum of \c a and \c b
 */
v1d v1d_add(v1d a, v1d b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v1f
 * \details Performs the addition element by element of the input two \c v1f vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Sum of \c a and \c b
 */
v1f v1f_add(v1f a, v1f b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v1i
 * \details Performs the addition element by element of the input two \c v1i vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Sum of \c a and \c b
 */
v1i v1i_add(v1i a, v1i b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v1l
 * \details Performs the addition element by element of the input two \c v1l vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Sum of \c a and \c b
 */
v1l v1l_add(v1l a, v1l b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v2d
 * \details Performs the addition element by element of the input two \c v2d vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Sum of \c a and \c b
 */
v2d v2d_add(v2d a, v2d b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v2f
 * \details Performs the addition element by element of the input two \c v2f vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Sum of \c a and \c b
 */
v2f v2f_add(v2f a, v2f b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v2i
 * \details Performs the addition element by element of the input two \c v2i vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Sum of \c a and \c b
 */
v2i v2i_add(v2i a, v2i b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v2l
 * \details Performs the addition element by element of the input two \c v2l vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Sum of \c a and \c b
 */
v2l v2l_add(v2l a, v2l b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v4d
 * \details Performs the addition element by element of the input two \c v4d vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Sum of \c a and \c b
 */
v4d v4d_add(v4d a, v4d b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v4f
 * \details Performs the addition element by element of the input two \c v4f vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Sum of \c a and \c b
 */
v4f v4f_add(v4f a, v4f b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v4i
 * \details Performs the addition element by element of the input two \c v4i vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Sum of \c a and \c b
 */
v4i v4i_add(v4i a, v4i b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v4l
 * \details Performs the addition element by element of the input two \c v4l vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Sum of \c a and \c b
 */
v4l v4l_add(v4l a, v4l b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v8d
 * \details Performs the addition element by element of the input two \c v8d vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Sum of \c a and \c b
 */
v8d v8d_add(v8d a, v8d b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v8f
 * \details Performs the addition element by element of the input two \c v8f vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Sum of \c a and \c b
 */
v8f v8f_add(v8f a, v8f b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v8i
 * \details Performs the addition element by element of the input two \c v8i vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Sum of \c a and \c b
 */
v8i v8i_add(v8i a, v8i b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v8l
 * \details Performs the addition element by element of the input two \c v8l vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Sum of \c a and \c b
 */
v8l v8l_add(v8l a, v8l b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v16f
 * \details Performs the addition element by element of the input two \c v16f vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Sum of \c a and \c b
 */
v16f v16f_add(v16f a, v16f b);
/**
 * \brief Elementwise addition ( \c `a + b` )
 * \ingroup arith
 * \related v16i
 * \details Performs the addition element by element of the input two \c v16i vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] + b[i]
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Sum of \c a and \c b
 */
v16i v16i_add(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v1d input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Difference of \c a and \c b
 */
v1d v1d_sub(v1d a, v1d b);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v1f input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Difference of \c a and \c b
 */
v1f v1f_sub(v1f a, v1f b);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v1i input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Difference of \c a and \c b
 */
v1i v1i_sub(v1i a, v1i b);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v1l input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Difference of \c a and \c b
 */
v1l v1l_sub(v1l a, v1l b);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v2d input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Difference of \c a and \c b
 */
v2d v2d_sub(v2d a, v2d b);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v2f input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Difference of \c a and \c b
 */
v2f v2f_sub(v2f a, v2f b);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v2i input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Difference of \c a and \c b
 */
v2i v2i_sub(v2i a, v2i b);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v2l input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Difference of \c a and \c b
 */
v2l v2l_sub(v2l a, v2l b);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v4d input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Difference of \c a and \c b
 */
v4d v4d_sub(v4d a, v4d b);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v4f input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Difference of \c a and \c b
 */
v4f v4f_sub(v4f a, v4f b);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v4i input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Difference of \c a and \c b
 */
v4i v4i_sub(v4i a, v4i b);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v4l input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Difference of \c a and \c b
 */
v4l v4l_sub(v4l a, v4l b);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v8d input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Difference of \c a and \c b
 */
v8d v8d_sub(v8d a, v8d b);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v8f input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Difference of \c a and \c b
 */
v8f v8f_sub(v8f a, v8f b);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v8i input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Difference of \c a and \c b
 */
v8i v8i_sub(v8i a, v8i b);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v8l input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Difference of \c a and \c b
 */
v8l v8l_sub(v8l a, v8l b);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v16f input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Difference of \c a and \c b
 */
v16f v16f_sub(v16f a, v16f b);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise subtraction ( \c `a - b` )
 * \details Performs the subtraction element by element of the two \c v16i input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] - b[i]
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Difference of \c a and \c b
 */
v16i v16i_sub(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v1d input vector \c a.
 * \attention Should not be confused with v1d_not(v1d a)
 * \impl
for i from 0 to 0
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Negation of \c a
 */
v1d v1d_neg(v1d a);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v1f input vector \c a.
 * \attention Should not be confused with v1f_not(v1f a)
 * \impl
for i from 0 to 0
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Negation of \c a
 */
v1f v1f_neg(v1f a);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v1i input vector \c a.
 * \attention Should not be confused with v1i_not(v1i a)
 * \impl
for i from 0 to 0
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Negation of \c a
 */
v1i v1i_neg(v1i a);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v1l input vector \c a.
 * \attention Should not be confused with v1l_not(v1l a)
 * \impl
for i from 0 to 0
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Negation of \c a
 */
v1l v1l_neg(v1l a);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v2d input vector \c a.
 * \attention Should not be confused with v2d_not(v2d a)
 * \impl
for i from 0 to 1
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Negation of \c a
 */
v2d v2d_neg(v2d a);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v2f input vector \c a.
 * \attention Should not be confused with v2f_not(v2f a)
 * \impl
for i from 0 to 1
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Negation of \c a
 */
v2f v2f_neg(v2f a);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v2i input vector \c a.
 * \attention Should not be confused with v2i_not(v2i a)
 * \impl
for i from 0 to 1
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Negation of \c a
 */
v2i v2i_neg(v2i a);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v2l input vector \c a.
 * \attention Should not be confused with v2l_not(v2l a)
 * \impl
for i from 0 to 1
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Negation of \c a
 */
v2l v2l_neg(v2l a);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v4d input vector \c a.
 * \attention Should not be confused with v4d_not(v4d a)
 * \impl
for i from 0 to 3
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Negation of \c a
 */
v4d v4d_neg(v4d a);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v4f input vector \c a.
 * \attention Should not be confused with v4f_not(v4f a)
 * \impl
for i from 0 to 3
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Negation of \c a
 */
v4f v4f_neg(v4f a);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v4i input vector \c a.
 * \attention Should not be confused with v4i_not(v4i a)
 * \impl
for i from 0 to 3
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Negation of \c a
 */
v4i v4i_neg(v4i a);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v4l input vector \c a.
 * \attention Should not be confused with v4l_not(v4l a)
 * \impl
for i from 0 to 3
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Negation of \c a
 */
v4l v4l_neg(v4l a);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v8d input vector \c a.
 * \attention Should not be confused with v8d_not(v8d a)
 * \impl
for i from 0 to 7
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Negation of \c a
 */
v8d v8d_neg(v8d a);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v8f input vector \c a.
 * \attention Should not be confused with v8f_not(v8f a)
 * \impl
for i from 0 to 7
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Negation of \c a
 */
v8f v8f_neg(v8f a);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v8i input vector \c a.
 * \attention Should not be confused with v8i_not(v8i a)
 * \impl
for i from 0 to 7
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Negation of \c a
 */
v8i v8i_neg(v8i a);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v8l input vector \c a.
 * \attention Should not be confused with v8l_not(v8l a)
 * \impl
for i from 0 to 7
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Negation of \c a
 */
v8l v8l_neg(v8l a);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v16f input vector \c a.
 * \attention Should not be confused with v16f_not(v16f a)
 * \impl
for i from 0 to 15
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Negation of \c a
 */
v16f v16f_neg(v16f a);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise negation ( \c `-a` )
 * \details Performs the negation of every element of the \c v16i input vector \c a.
 * \attention Should not be confused with v16i_not(v16i a)
 * \impl
for i from 0 to 15
  dst[i] := -a[i]
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Negation of \c a
 */
v16i v16i_neg(v16i a);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Absolute value of \c a
 */
v1d v1d_min(v1d a, v1d b);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Absolute value of \c a
 */
v1f v1f_min(v1f a, v1f b);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Absolute value of \c a
 */
v1i v1i_min(v1i a, v1i b);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Absolute value of \c a
 */
v1l v1l_min(v1l a, v1l b);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Absolute value of \c a
 */
v2d v2d_min(v2d a, v2d b);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Absolute value of \c a
 */
v2f v2f_min(v2f a, v2f b);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Absolute value of \c a
 */
v2i v2i_min(v2i a, v2i b);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Absolute value of \c a
 */
v2l v2l_min(v2l a, v2l b);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Absolute value of \c a
 */
v4d v4d_min(v4d a, v4d b);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Absolute value of \c a
 */
v4f v4f_min(v4f a, v4f b);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Absolute value of \c a
 */
v4i v4i_min(v4i a, v4i b);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Absolute value of \c a
 */
v4l v4l_min(v4l a, v4l b);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Absolute value of \c a
 */
v8d v8d_min(v8d a, v8d b);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Absolute value of \c a
 */
v8f v8f_min(v8f a, v8f b);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Absolute value of \c a
 */
v8i v8i_min(v8i a, v8i b);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Absolute value of \c a
 */
v8l v8l_min(v8l a, v8l b);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 15
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Absolute value of \c a
 */
v16f v16f_min(v16f a, v16f b);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise min ( \c `a < b ? a : b` )
 * \details Copy the minimum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 15
  if a[i] < b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Absolute value of \c a
 */
v16i v16i_min(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Absolute value of \c a
 */
v1d v1d_max(v1d a, v1d b);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Absolute value of \c a
 */
v1f v1f_max(v1f a, v1f b);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Absolute value of \c a
 */
v1i v1i_max(v1i a, v1i b);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 0
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Absolute value of \c a
 */
v1l v1l_max(v1l a, v1l b);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Absolute value of \c a
 */
v2d v2d_max(v2d a, v2d b);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Absolute value of \c a
 */
v2f v2f_max(v2f a, v2f b);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Absolute value of \c a
 */
v2i v2i_max(v2i a, v2i b);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 1
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Absolute value of \c a
 */
v2l v2l_max(v2l a, v2l b);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Absolute value of \c a
 */
v4d v4d_max(v4d a, v4d b);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Absolute value of \c a
 */
v4f v4f_max(v4f a, v4f b);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Absolute value of \c a
 */
v4i v4i_max(v4i a, v4i b);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 3
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Absolute value of \c a
 */
v4l v4l_max(v4l a, v4l b);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Absolute value of \c a
 */
v8d v8d_max(v8d a, v8d b);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Absolute value of \c a
 */
v8f v8f_max(v8f a, v8f b);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Absolute value of \c a
 */
v8i v8i_max(v8i a, v8i b);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 7
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Absolute value of \c a
 */
v8l v8l_max(v8l a, v8l b);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 15
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Absolute value of \c a
 */
v16f v16f_max(v16f a, v16f b);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise max ( \c `a > b ? a : b` )
 * \details Copy the maximum element of \c a and \c b for every elements.
 * \impl
for i from 0 to 15
  if a[i] > b[i]
    dst[i] := a[i]
  else
    dst[i] := b[i]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Absolute value of \c a
 */
v16i v16i_max(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v1d vector \c a.
 * \impl
for i from 0 to 0
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Absolute value of \c a
 */
v1d v1d_abs(v1d a);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v1f vector \c a.
 * \impl
for i from 0 to 0
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Absolute value of \c a
 */
v1f v1f_abs(v1f a);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v1i vector \c a.
 * \impl
for i from 0 to 0
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Absolute value of \c a
 */
v1i v1i_abs(v1i a);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v1l vector \c a.
 * \impl
for i from 0 to 0
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Absolute value of \c a
 */
v1l v1l_abs(v1l a);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v2d vector \c a.
 * \impl
for i from 0 to 1
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Absolute value of \c a
 */
v2d v2d_abs(v2d a);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v2f vector \c a.
 * \impl
for i from 0 to 1
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Absolute value of \c a
 */
v2f v2f_abs(v2f a);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v2i vector \c a.
 * \impl
for i from 0 to 1
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Absolute value of \c a
 */
v2i v2i_abs(v2i a);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v2l vector \c a.
 * \impl
for i from 0 to 1
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Absolute value of \c a
 */
v2l v2l_abs(v2l a);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v4d vector \c a.
 * \impl
for i from 0 to 3
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Absolute value of \c a
 */
v4d v4d_abs(v4d a);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v4f vector \c a.
 * \impl
for i from 0 to 3
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Absolute value of \c a
 */
v4f v4f_abs(v4f a);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v4i vector \c a.
 * \impl
for i from 0 to 3
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Absolute value of \c a
 */
v4i v4i_abs(v4i a);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v4l vector \c a.
 * \impl
for i from 0 to 3
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Absolute value of \c a
 */
v4l v4l_abs(v4l a);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v8d vector \c a.
 * \impl
for i from 0 to 7
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Absolute value of \c a
 */
v8d v8d_abs(v8d a);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v8f vector \c a.
 * \impl
for i from 0 to 7
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Absolute value of \c a
 */
v8f v8f_abs(v8f a);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v8i vector \c a.
 * \impl
for i from 0 to 7
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Absolute value of \c a
 */
v8i v8i_abs(v8i a);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v8l vector \c a.
 * \impl
for i from 0 to 7
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Absolute value of \c a
 */
v8l v8l_abs(v8l a);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v16f vector \c a.
 * \impl
for i from 0 to 15
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Absolute value of \c a
 */
v16f v16f_abs(v16f a);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise absolute value ( \c `a > 0 ? a : -a` )
 * \details Computes the absolute value of every element of hte \c v16i vector \c a.
 * \impl
for i from 0 to 15
  if a[i] > 0
    dst[i] := a[i]
  else
    dst[i] := -a[i]
  endif
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Absolute value of \c a
 */
v16i v16i_abs(v16i a);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v1d input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Product of \c a and \c b
 */
v1d v1d_mul(v1d a, v1d b);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v1f input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Product of \c a and \c b
 */
v1f v1f_mul(v1f a, v1f b);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v1i input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Product of \c a and \c b
 */
v1i v1i_mul(v1i a, v1i b);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v1l input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Product of \c a and \c b
 */
v1l v1l_mul(v1l a, v1l b);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v2d input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Product of \c a and \c b
 */
v2d v2d_mul(v2d a, v2d b);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v2f input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Product of \c a and \c b
 */
v2f v2f_mul(v2f a, v2f b);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v2i input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Product of \c a and \c b
 */
v2i v2i_mul(v2i a, v2i b);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v2l input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Product of \c a and \c b
 */
v2l v2l_mul(v2l a, v2l b);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v4d input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Product of \c a and \c b
 */
v4d v4d_mul(v4d a, v4d b);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v4f input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Product of \c a and \c b
 */
v4f v4f_mul(v4f a, v4f b);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v4i input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Product of \c a and \c b
 */
v4i v4i_mul(v4i a, v4i b);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v4l input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Product of \c a and \c b
 */
v4l v4l_mul(v4l a, v4l b);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v8d input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Product of \c a and \c b
 */
v8d v8d_mul(v8d a, v8d b);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v8f input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Product of \c a and \c b
 */
v8f v8f_mul(v8f a, v8f b);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v8i input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Product of \c a and \c b
 */
v8i v8i_mul(v8i a, v8i b);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v8l input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Product of \c a and \c b
 */
v8l v8l_mul(v8l a, v8l b);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v16f input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Product of \c a and \c b
 */
v16f v16f_mul(v16f a, v16f b);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise multiplication ( \c `a * b` )
 * \details Performs the multiplication element by element of the two \c v16i input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] * b[i]
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Product of \c a and \c b
 */
v16i v16i_mul(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v1d input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \returns Quotient of \c a and \c b
 */
v1d v1d_div(v1d a, v1d b);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v1f input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \returns Quotient of \c a and \c b
 */
v1f v1f_div(v1f a, v1f b);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v1i input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \returns Quotient of \c a and \c b
 */
v1i v1i_div(v1i a, v1i b);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v1l input vectors \c a and \c b.
 * \impl
for i from 0 to 0
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \returns Quotient of \c a and \c b
 */
v1l v1l_div(v1l a, v1l b);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v2d input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \returns Quotient of \c a and \c b
 */
v2d v2d_div(v2d a, v2d b);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v2f input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \returns Quotient of \c a and \c b
 */
v2f v2f_div(v2f a, v2f b);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v2i input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \returns Quotient of \c a and \c b
 */
v2i v2i_div(v2i a, v2i b);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v2l input vectors \c a and \c b.
 * \impl
for i from 0 to 1
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \returns Quotient of \c a and \c b
 */
v2l v2l_div(v2l a, v2l b);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v4d input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \returns Quotient of \c a and \c b
 */
v4d v4d_div(v4d a, v4d b);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v4f input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \returns Quotient of \c a and \c b
 */
v4f v4f_div(v4f a, v4f b);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v4i input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \returns Quotient of \c a and \c b
 */
v4i v4i_div(v4i a, v4i b);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v4l input vectors \c a and \c b.
 * \impl
for i from 0 to 3
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \returns Quotient of \c a and \c b
 */
v4l v4l_div(v4l a, v4l b);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v8d input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \returns Quotient of \c a and \c b
 */
v8d v8d_div(v8d a, v8d b);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v8f input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \returns Quotient of \c a and \c b
 */
v8f v8f_div(v8f a, v8f b);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v8i input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \returns Quotient of \c a and \c b
 */
v8i v8i_div(v8i a, v8i b);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v8l input vectors \c a and \c b.
 * \impl
for i from 0 to 7
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \returns Quotient of \c a and \c b
 */
v8l v8l_div(v8l a, v8l b);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v16f input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \returns Quotient of \c a and \c b
 */
v16f v16f_div(v16f a, v16f b);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise division ( \c `a / b` )
 * \details Performs the division element by element of the two \c v16i input vectors \c a and \c b.
 * \impl
for i from 0 to 15
  dst[i] := a[i] / b[i]
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \returns Quotient of \c a and \c b
 */
v16i v16i_div(v16i a, v16i b);

/**
 * \ingroup arith
 * \related v1d
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1d input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Reciprocal of \c a
 */
v1d v1d_rcp(v1d a);
/**
 * \ingroup arith
 * \related v1f
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1f input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Reciprocal of \c a
 */
v1f v1f_rcp(v1f a);
/**
 * \ingroup arith
 * \related v1i
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1i input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Reciprocal of \c a
 */
v1i v1i_rcp(v1i a);
/**
 * \ingroup arith
 * \related v1l
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1l input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Reciprocal of \c a
 */
v1l v1l_rcp(v1l a);
/**
 * \ingroup arith
 * \related v2d
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2d input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Reciprocal of \c a
 */
v2d v2d_rcp(v2d a);
/**
 * \ingroup arith
 * \related v2f
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2f input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Reciprocal of \c a
 */
v2f v2f_rcp(v2f a);
/**
 * \ingroup arith
 * \related v2i
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2i input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Reciprocal of \c a
 */
v2i v2i_rcp(v2i a);
/**
 * \ingroup arith
 * \related v2l
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2l input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Reciprocal of \c a
 */
v2l v2l_rcp(v2l a);
/**
 * \ingroup arith
 * \related v4d
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4d input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Reciprocal of \c a
 */
v4d v4d_rcp(v4d a);
/**
 * \ingroup arith
 * \related v4f
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4f input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Reciprocal of \c a
 */
v4f v4f_rcp(v4f a);
/**
 * \ingroup arith
 * \related v4i
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4i input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Reciprocal of \c a
 */
v4i v4i_rcp(v4i a);
/**
 * \ingroup arith
 * \related v4l
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4l input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Reciprocal of \c a
 */
v4l v4l_rcp(v4l a);
/**
 * \ingroup arith
 * \related v8d
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8d input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Reciprocal of \c a
 */
v8d v8d_rcp(v8d a);
/**
 * \ingroup arith
 * \related v8f
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8f input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Reciprocal of \c a
 */
v8f v8f_rcp(v8f a);
/**
 * \ingroup arith
 * \related v8i
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8i input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Reciprocal of \c a
 */
v8i v8i_rcp(v8i a);
/**
 * \ingroup arith
 * \related v8l
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8l input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Reciprocal of \c a
 */
v8l v8l_rcp(v8l a);
/**
 * \ingroup arith
 * \related v16f
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v16f input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Reciprocal of \c a
 */
v16f v16f_rcp(v16f a);
/**
 * \ingroup arith
 * \related v16i
 * \brief Elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v16i input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := 1 / a[i]
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Reciprocal of \c a
 */
v16i v16i_rcp(v16i a);

/**
 * \ingroup arith
 * \related v1d
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1d input vector \c a.
 *  This function may be faster and less accurate than v1d_rcp(v1d a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Reciprocal of \c a
 */
v1d v1d_frcp(v1d a);
/**
 * \ingroup arith
 * \related v1f
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1f input vector \c a.
 *  This function may be faster and less accurate than v1f_rcp(v1f a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Reciprocal of \c a
 */
v1f v1f_frcp(v1f a);
/**
 * \ingroup arith
 * \related v1i
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1i input vector \c a.
 *  This function may be faster and less accurate than v1i_rcp(v1i a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Reciprocal of \c a
 */
v1i v1i_frcp(v1i a);
/**
 * \ingroup arith
 * \related v1l
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v1l input vector \c a.
 *  This function may be faster and less accurate than v1l_rcp(v1l a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Reciprocal of \c a
 */
v1l v1l_frcp(v1l a);
/**
 * \ingroup arith
 * \related v2d
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2d input vector \c a.
 *  This function may be faster and less accurate than v2d_rcp(v2d a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Reciprocal of \c a
 */
v2d v2d_frcp(v2d a);
/**
 * \ingroup arith
 * \related v2f
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2f input vector \c a.
 *  This function may be faster and less accurate than v2f_rcp(v2f a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Reciprocal of \c a
 */
v2f v2f_frcp(v2f a);
/**
 * \ingroup arith
 * \related v2i
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2i input vector \c a.
 *  This function may be faster and less accurate than v2i_rcp(v2i a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Reciprocal of \c a
 */
v2i v2i_frcp(v2i a);
/**
 * \ingroup arith
 * \related v2l
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v2l input vector \c a.
 *  This function may be faster and less accurate than v2l_rcp(v2l a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Reciprocal of \c a
 */
v2l v2l_frcp(v2l a);
/**
 * \ingroup arith
 * \related v4d
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4d input vector \c a.
 *  This function may be faster and less accurate than v4d_rcp(v4d a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Reciprocal of \c a
 */
v4d v4d_frcp(v4d a);
/**
 * \ingroup arith
 * \related v4f
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4f input vector \c a.
 *  This function may be faster and less accurate than v4f_rcp(v4f a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Reciprocal of \c a
 */
v4f v4f_frcp(v4f a);
/**
 * \ingroup arith
 * \related v4i
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4i input vector \c a.
 *  This function may be faster and less accurate than v4i_rcp(v4i a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Reciprocal of \c a
 */
v4i v4i_frcp(v4i a);
/**
 * \ingroup arith
 * \related v4l
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v4l input vector \c a.
 *  This function may be faster and less accurate than v4l_rcp(v4l a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Reciprocal of \c a
 */
v4l v4l_frcp(v4l a);
/**
 * \ingroup arith
 * \related v8d
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8d input vector \c a.
 *  This function may be faster and less accurate than v8d_rcp(v8d a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Reciprocal of \c a
 */
v8d v8d_frcp(v8d a);
/**
 * \ingroup arith
 * \related v8f
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8f input vector \c a.
 *  This function may be faster and less accurate than v8f_rcp(v8f a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Reciprocal of \c a
 */
v8f v8f_frcp(v8f a);
/**
 * \ingroup arith
 * \related v8i
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8i input vector \c a.
 *  This function may be faster and less accurate than v8i_rcp(v8i a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Reciprocal of \c a
 */
v8i v8i_frcp(v8i a);
/**
 * \ingroup arith
 * \related v8l
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v8l input vector \c a.
 *  This function may be faster and less accurate than v8l_rcp(v8l a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Reciprocal of \c a
 */
v8l v8l_frcp(v8l a);
/**
 * \ingroup arith
 * \related v16f
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v16f input vector \c a.
 *  This function may be faster and less accurate than v16f_rcp(v16f a)
 * \impl
for i from 0 to 15
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Reciprocal of \c a
 */
v16f v16f_frcp(v16f a);
/**
 * \ingroup arith
 * \related v16i
 * \brief Fast elementwise reciprocal ( \c `1 / a` )
 * \details Computes the reciprocal of every element of the \c v16i input vector \c a.
 *  This function may be faster and less accurate than v16i_rcp(v16i a)
 * \impl
for i from 0 to 15
  dst[i] := FAST_COMPUTE(1 / a[i])
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Reciprocal of \c a
 */
v16i v16i_frcp(v16i a);

/**
 * \ingroup math
 * \related v1d
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v1d input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Square root of \c a
 */
v1d v1d_sqrt(v1d a);
/**
 * \ingroup math
 * \related v1f
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v1f input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Square root of \c a
 */
v1f v1f_sqrt(v1f a);
/**
 * \ingroup math
 * \related v1i
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v1i input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Square root of \c a
 */
v1i v1i_sqrt(v1i a);
/**
 * \ingroup math
 * \related v1l
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v1l input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Square root of \c a
 */
v1l v1l_sqrt(v1l a);
/**
 * \ingroup math
 * \related v2d
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v2d input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Square root of \c a
 */
v2d v2d_sqrt(v2d a);
/**
 * \ingroup math
 * \related v2f
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v2f input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Square root of \c a
 */
v2f v2f_sqrt(v2f a);
/**
 * \ingroup math
 * \related v2i
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v2i input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Square root of \c a
 */
v2i v2i_sqrt(v2i a);
/**
 * \ingroup math
 * \related v2l
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v2l input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Square root of \c a
 */
v2l v2l_sqrt(v2l a);
/**
 * \ingroup math
 * \related v4d
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v4d input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Square root of \c a
 */
v4d v4d_sqrt(v4d a);
/**
 * \ingroup math
 * \related v4f
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v4f input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Square root of \c a
 */
v4f v4f_sqrt(v4f a);
/**
 * \ingroup math
 * \related v4i
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v4i input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Square root of \c a
 */
v4i v4i_sqrt(v4i a);
/**
 * \ingroup math
 * \related v4l
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v4l input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Square root of \c a
 */
v4l v4l_sqrt(v4l a);
/**
 * \ingroup math
 * \related v8d
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v8d input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Square root of \c a
 */
v8d v8d_sqrt(v8d a);
/**
 * \ingroup math
 * \related v8f
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v8f input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Square root of \c a
 */
v8f v8f_sqrt(v8f a);
/**
 * \ingroup math
 * \related v8i
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v8i input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Square root of \c a
 */
v8i v8i_sqrt(v8i a);
/**
 * \ingroup math
 * \related v8l
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v8l input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Square root of \c a
 */
v8l v8l_sqrt(v8l a);
/**
 * \ingroup math
 * \related v16f
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v16f input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Square root of \c a
 */
v16f v16f_sqrt(v16f a);
/**
 * \ingroup math
 * \related v16i
 * \brief Elementwise square root ( \c `sqrt(a)` )
 * \details Computes the square root of every element of the \c v16i input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := SQRT(a[i])
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Square root of \c a
 */
v16i v16i_sqrt(v16i a);

/**
 * \ingroup math
 * \related v1d
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1d input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Square root reciprocal of \c a
 */
v1d v1d_rsqrt(v1d a);
/**
 * \ingroup math
 * \related v1f
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1f input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Square root reciprocal of \c a
 */
v1f v1f_rsqrt(v1f a);
/**
 * \ingroup math
 * \related v1i
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1i input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Square root reciprocal of \c a
 */
v1i v1i_rsqrt(v1i a);
/**
 * \ingroup math
 * \related v1l
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1l input vector \c a.
 * \impl
for i from 0 to 0
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Square root reciprocal of \c a
 */
v1l v1l_rsqrt(v1l a);
/**
 * \ingroup math
 * \related v2d
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2d input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Square root reciprocal of \c a
 */
v2d v2d_rsqrt(v2d a);
/**
 * \ingroup math
 * \related v2f
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2f input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Square root reciprocal of \c a
 */
v2f v2f_rsqrt(v2f a);
/**
 * \ingroup math
 * \related v2i
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2i input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Square root reciprocal of \c a
 */
v2i v2i_rsqrt(v2i a);
/**
 * \ingroup math
 * \related v2l
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2l input vector \c a.
 * \impl
for i from 0 to 1
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Square root reciprocal of \c a
 */
v2l v2l_rsqrt(v2l a);
/**
 * \ingroup math
 * \related v4d
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4d input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Square root reciprocal of \c a
 */
v4d v4d_rsqrt(v4d a);
/**
 * \ingroup math
 * \related v4f
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4f input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Square root reciprocal of \c a
 */
v4f v4f_rsqrt(v4f a);
/**
 * \ingroup math
 * \related v4i
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4i input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Square root reciprocal of \c a
 */
v4i v4i_rsqrt(v4i a);
/**
 * \ingroup math
 * \related v4l
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4l input vector \c a.
 * \impl
for i from 0 to 3
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Square root reciprocal of \c a
 */
v4l v4l_rsqrt(v4l a);
/**
 * \ingroup math
 * \related v8d
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8d input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Square root reciprocal of \c a
 */
v8d v8d_rsqrt(v8d a);
/**
 * \ingroup math
 * \related v8f
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8f input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Square root reciprocal of \c a
 */
v8f v8f_rsqrt(v8f a);
/**
 * \ingroup math
 * \related v8i
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8i input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Square root reciprocal of \c a
 */
v8i v8i_rsqrt(v8i a);
/**
 * \ingroup math
 * \related v8l
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8l input vector \c a.
 * \impl
for i from 0 to 7
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Square root reciprocal of \c a
 */
v8l v8l_rsqrt(v8l a);
/**
 * \ingroup math
 * \related v16f
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v16f input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Square root reciprocal of \c a
 */
v16f v16f_rsqrt(v16f a);
/**
 * \ingroup math
 * \related v16i
 * \brief Elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v16i input vector \c a.
 * \impl
for i from 0 to 15
  dst[i] := 1 / SQRT(a[i])
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Square root reciprocal of \c a
 */
v16i v16i_rsqrt(v16i a);

/**
 * \ingroup math
 * \related v1d
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1d input vector \c a.
 *  This function may be faster and less accurate than v1d_rsqrt(v1d a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v1d input vector
 * \returns Square root reciprocal of \c a
 */
v1d v1d_frsqrt(v1d a);
/**
 * \ingroup math
 * \related v1f
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1f input vector \c a.
 *  This function may be faster and less accurate than v1f_rsqrt(v1f a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v1f input vector
 * \returns Square root reciprocal of \c a
 */
v1f v1f_frsqrt(v1f a);
/**
 * \ingroup math
 * \related v1i
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1i input vector \c a.
 *  This function may be faster and less accurate than v1i_rsqrt(v1i a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v1i input vector
 * \returns Square root reciprocal of \c a
 */
v1i v1i_frsqrt(v1i a);
/**
 * \ingroup math
 * \related v1l
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v1l input vector \c a.
 *  This function may be faster and less accurate than v1l_rsqrt(v1l a)
 * \impl
for i from 0 to 0
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v1l input vector
 * \returns Square root reciprocal of \c a
 */
v1l v1l_frsqrt(v1l a);
/**
 * \ingroup math
 * \related v2d
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2d input vector \c a.
 *  This function may be faster and less accurate than v2d_rsqrt(v2d a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v2d input vector
 * \returns Square root reciprocal of \c a
 */
v2d v2d_frsqrt(v2d a);
/**
 * \ingroup math
 * \related v2f
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2f input vector \c a.
 *  This function may be faster and less accurate than v2f_rsqrt(v2f a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v2f input vector
 * \returns Square root reciprocal of \c a
 */
v2f v2f_frsqrt(v2f a);
/**
 * \ingroup math
 * \related v2i
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2i input vector \c a.
 *  This function may be faster and less accurate than v2i_rsqrt(v2i a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v2i input vector
 * \returns Square root reciprocal of \c a
 */
v2i v2i_frsqrt(v2i a);
/**
 * \ingroup math
 * \related v2l
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v2l input vector \c a.
 *  This function may be faster and less accurate than v2l_rsqrt(v2l a)
 * \impl
for i from 0 to 1
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v2l input vector
 * \returns Square root reciprocal of \c a
 */
v2l v2l_frsqrt(v2l a);
/**
 * \ingroup math
 * \related v4d
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4d input vector \c a.
 *  This function may be faster and less accurate than v4d_rsqrt(v4d a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v4d input vector
 * \returns Square root reciprocal of \c a
 */
v4d v4d_frsqrt(v4d a);
/**
 * \ingroup math
 * \related v4f
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4f input vector \c a.
 *  This function may be faster and less accurate than v4f_rsqrt(v4f a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v4f input vector
 * \returns Square root reciprocal of \c a
 */
v4f v4f_frsqrt(v4f a);
/**
 * \ingroup math
 * \related v4i
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4i input vector \c a.
 *  This function may be faster and less accurate than v4i_rsqrt(v4i a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v4i input vector
 * \returns Square root reciprocal of \c a
 */
v4i v4i_frsqrt(v4i a);
/**
 * \ingroup math
 * \related v4l
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v4l input vector \c a.
 *  This function may be faster and less accurate than v4l_rsqrt(v4l a)
 * \impl
for i from 0 to 3
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v4l input vector
 * \returns Square root reciprocal of \c a
 */
v4l v4l_frsqrt(v4l a);
/**
 * \ingroup math
 * \related v8d
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8d input vector \c a.
 *  This function may be faster and less accurate than v8d_rsqrt(v8d a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v8d input vector
 * \returns Square root reciprocal of \c a
 */
v8d v8d_frsqrt(v8d a);
/**
 * \ingroup math
 * \related v8f
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8f input vector \c a.
 *  This function may be faster and less accurate than v8f_rsqrt(v8f a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v8f input vector
 * \returns Square root reciprocal of \c a
 */
v8f v8f_frsqrt(v8f a);
/**
 * \ingroup math
 * \related v8i
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8i input vector \c a.
 *  This function may be faster and less accurate than v8i_rsqrt(v8i a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v8i input vector
 * \returns Square root reciprocal of \c a
 */
v8i v8i_frsqrt(v8i a);
/**
 * \ingroup math
 * \related v8l
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v8l input vector \c a.
 *  This function may be faster and less accurate than v8l_rsqrt(v8l a)
 * \impl
for i from 0 to 7
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v8l input vector
 * \returns Square root reciprocal of \c a
 */
v8l v8l_frsqrt(v8l a);
/**
 * \ingroup math
 * \related v16f
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v16f input vector \c a.
 *  This function may be faster and less accurate than v16f_rsqrt(v16f a)
 * \impl
for i from 0 to 15
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v16f input vector
 * \returns Square root reciprocal of \c a
 */
v16f v16f_frsqrt(v16f a);
/**
 * \ingroup math
 * \related v16i
 * \brief Fast elementwise square root reciprocal ( \c `1 / sqrt(a)` )
 * \details Computes the reciprocal of the square root of every element of the \c v16i input vector \c a.
 *  This function may be faster and less accurate than v16i_rsqrt(v16i a)
 * \impl
for i from 0 to 15
  dst[i] := FAST_COMPUTE(1 / SQRT(a[i]))
endfor
\endimpl
 * \param a \c v16i input vector
 * \returns Square root reciprocal of \c a
 */
v16i v16i_frsqrt(v16i a);

/* Fused Multiply-Add */
/**
 * \ingroup arith
 * \related v1d
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v1d input vectors \c a and \c b,
 *  then adds the result to the last \c v1d input vector \c acc.
 * \details Functionally equivalent to: \c `v1d_add(v1d_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v1d v1d_fmadd(v1d a, v1d b, v1d acc);
/**
 * \ingroup arith
 * \related v1f
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v1f input vectors \c a and \c b,
 *  then adds the result to the last \c v1f input vector \c acc.
 * \details Functionally equivalent to: \c `v1f_add(v1f_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v1f v1f_fmadd(v1f a, v1f b, v1f acc);
/**
 * \ingroup arith
 * \related v1i
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v1i input vectors \c a and \c b,
 *  then adds the result to the last \c v1i input vector \c acc.
 * \details Functionally equivalent to: \c `v1i_add(v1i_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v1i v1i_fmadd(v1i a, v1i b, v1i acc);
/**
 * \ingroup arith
 * \related v1l
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v1l input vectors \c a and \c b,
 *  then adds the result to the last \c v1l input vector \c acc.
 * \details Functionally equivalent to: \c `v1l_add(v1l_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v1l v1l_fmadd(v1l a, v1l b, v1l acc);
/**
 * \ingroup arith
 * \related v2d
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v2d input vectors \c a and \c b,
 *  then adds the result to the last \c v2d input vector \c acc.
 * \details Functionally equivalent to: \c `v2d_add(v2d_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v2d v2d_fmadd(v2d a, v2d b, v2d acc);
/**
 * \ingroup arith
 * \related v2f
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v2f input vectors \c a and \c b,
 *  then adds the result to the last \c v2f input vector \c acc.
 * \details Functionally equivalent to: \c `v2f_add(v2f_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v2f v2f_fmadd(v2f a, v2f b, v2f acc);
/**
 * \ingroup arith
 * \related v2i
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v2i input vectors \c a and \c b,
 *  then adds the result to the last \c v2i input vector \c acc.
 * \details Functionally equivalent to: \c `v2i_add(v2i_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v2i v2i_fmadd(v2i a, v2i b, v2i acc);
/**
 * \ingroup arith
 * \related v2l
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v2l input vectors \c a and \c b,
 *  then adds the result to the last \c v2l input vector \c acc.
 * \details Functionally equivalent to: \c `v2l_add(v2l_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v2l v2l_fmadd(v2l a, v2l b, v2l acc);
/**
 * \ingroup arith
 * \related v4d
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v4d input vectors \c a and \c b,
 *  then adds the result to the last \c v4d input vector \c acc.
 * \details Functionally equivalent to: \c `v4d_add(v4d_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v4d v4d_fmadd(v4d a, v4d b, v4d acc);
/**
 * \ingroup arith
 * \related v4f
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v4f input vectors \c a and \c b,
 *  then adds the result to the last \c v4f input vector \c acc.
 * \details Functionally equivalent to: \c `v4f_add(v4f_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v4f v4f_fmadd(v4f a, v4f b, v4f acc);
/**
 * \ingroup arith
 * \related v4i
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v4i input vectors \c a and \c b,
 *  then adds the result to the last \c v4i input vector \c acc.
 * \details Functionally equivalent to: \c `v4i_add(v4i_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v4i v4i_fmadd(v4i a, v4i b, v4i acc);
/**
 * \ingroup arith
 * \related v4l
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v4l input vectors \c a and \c b,
 *  then adds the result to the last \c v4l input vector \c acc.
 * \details Functionally equivalent to: \c `v4l_add(v4l_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v4l v4l_fmadd(v4l a, v4l b, v4l acc);
/**
 * \ingroup arith
 * \related v8d
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v8d input vectors \c a and \c b,
 *  then adds the result to the last \c v8d input vector \c acc.
 * \details Functionally equivalent to: \c `v8d_add(v8d_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v8d v8d_fmadd(v8d a, v8d b, v8d acc);
/**
 * \ingroup arith
 * \related v8f
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v8f input vectors \c a and \c b,
 *  then adds the result to the last \c v8f input vector \c acc.
 * \details Functionally equivalent to: \c `v8f_add(v8f_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v8f v8f_fmadd(v8f a, v8f b, v8f acc);
/**
 * \ingroup arith
 * \related v8i
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v8i input vectors \c a and \c b,
 *  then adds the result to the last \c v8i input vector \c acc.
 * \details Functionally equivalent to: \c `v8i_add(v8i_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v8i v8i_fmadd(v8i a, v8i b, v8i acc);
/**
 * \ingroup arith
 * \related v8l
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v8l input vectors \c a and \c b,
 *  then adds the result to the last \c v8l input vector \c acc.
 * \details Functionally equivalent to: \c `v8l_add(v8l_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v8l v8l_fmadd(v8l a, v8l b, v8l acc);
/**
 * \ingroup arith
 * \related v16f
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v16f input vectors \c a and \c b,
 *  then adds the result to the last \c v16f input vector \c acc.
 * \details Functionally equivalent to: \c `v16f_add(v16f_mul(a, b), acc)`
 * \impl
for i from 0 to 15
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v16f v16f_fmadd(v16f a, v16f b, v16f acc);
/**
 * \ingroup arith
 * \related v16i
 * \brief Fused Multiply-Add ( \c `(a * b) + acc` )
 * \details Performs the multiplication of the \c v16i input vectors \c a and \c b,
 *  then adds the result to the last \c v16i input vector \c acc.
 * \details Functionally equivalent to: \c `v16i_add(v16i_mul(a, b), acc)`
 * \impl
for i from 0 to 15
  dst[i] := (a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) + acc`
 */
v16i v16i_fmadd(v16i a, v16i b, v16i acc);

/**
 * \ingroup arith
 * \related v1d
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v1d input vectors \c a and \c b,
 *  then subtracts the last \c v1d input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v1d_sub(v1d_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v1d v1d_fmsub(v1d a, v1d b, v1d acc);
/**
 * \ingroup arith
 * \related v1f
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v1f input vectors \c a and \c b,
 *  then subtracts the last \c v1f input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v1f_sub(v1f_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v1f v1f_fmsub(v1f a, v1f b, v1f acc);
/**
 * \ingroup arith
 * \related v1i
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v1i input vectors \c a and \c b,
 *  then subtracts the last \c v1i input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v1i_sub(v1i_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v1i v1i_fmsub(v1i a, v1i b, v1i acc);
/**
 * \ingroup arith
 * \related v1l
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v1l input vectors \c a and \c b,
 *  then subtracts the last \c v1l input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v1l_sub(v1l_mul(a, b), acc)`
 * \impl
for i from 0 to 0
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v1l v1l_fmsub(v1l a, v1l b, v1l acc);
/**
 * \ingroup arith
 * \related v2d
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v2d input vectors \c a and \c b,
 *  then subtracts the last \c v2d input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v2d_sub(v2d_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v2d v2d_fmsub(v2d a, v2d b, v2d acc);
/**
 * \ingroup arith
 * \related v2f
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v2f input vectors \c a and \c b,
 *  then subtracts the last \c v2f input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v2f_sub(v2f_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v2f v2f_fmsub(v2f a, v2f b, v2f acc);
/**
 * \ingroup arith
 * \related v2i
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v2i input vectors \c a and \c b,
 *  then subtracts the last \c v2i input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v2i_sub(v2i_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v2i v2i_fmsub(v2i a, v2i b, v2i acc);
/**
 * \ingroup arith
 * \related v2l
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v2l input vectors \c a and \c b,
 *  then subtracts the last \c v2l input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v2l_sub(v2l_mul(a, b), acc)`
 * \impl
for i from 0 to 1
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v2l v2l_fmsub(v2l a, v2l b, v2l acc);
/**
 * \ingroup arith
 * \related v4d
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v4d input vectors \c a and \c b,
 *  then subtracts the last \c v4d input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v4d_sub(v4d_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v4d v4d_fmsub(v4d a, v4d b, v4d acc);
/**
 * \ingroup arith
 * \related v4f
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v4f input vectors \c a and \c b,
 *  then subtracts the last \c v4f input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v4f_sub(v4f_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v4f v4f_fmsub(v4f a, v4f b, v4f acc);
/**
 * \ingroup arith
 * \related v4i
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v4i input vectors \c a and \c b,
 *  then subtracts the last \c v4i input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v4i_sub(v4i_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v4i v4i_fmsub(v4i a, v4i b, v4i acc);
/**
 * \ingroup arith
 * \related v4l
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v4l input vectors \c a and \c b,
 *  then subtracts the last \c v4l input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v4l_sub(v4l_mul(a, b), acc)`
 * \impl
for i from 0 to 3
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v4l v4l_fmsub(v4l a, v4l b, v4l acc);
/**
 * \ingroup arith
 * \related v8d
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v8d input vectors \c a and \c b,
 *  then subtracts the last \c v8d input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v8d_sub(v8d_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v8d v8d_fmsub(v8d a, v8d b, v8d acc);
/**
 * \ingroup arith
 * \related v8f
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v8f input vectors \c a and \c b,
 *  then subtracts the last \c v8f input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v8f_sub(v8f_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v8f v8f_fmsub(v8f a, v8f b, v8f acc);
/**
 * \ingroup arith
 * \related v8i
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v8i input vectors \c a and \c b,
 *  then subtracts the last \c v8i input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v8i_sub(v8i_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v8i v8i_fmsub(v8i a, v8i b, v8i acc);
/**
 * \ingroup arith
 * \related v8l
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v8l input vectors \c a and \c b,
 *  then subtracts the last \c v8l input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v8l_sub(v8l_mul(a, b), acc)`
 * \impl
for i from 0 to 7
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v8l v8l_fmsub(v8l a, v8l b, v8l acc);
/**
 * \ingroup arith
 * \related v16f
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v16f input vectors \c a and \c b,
 *  then subtracts the last \c v16f input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v16f_sub(v16f_mul(a, b), acc)`
 * \impl
for i from 0 to 15
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v16f v16f_fmsub(v16f a, v16f b, v16f acc);
/**
 * \ingroup arith
 * \related v16i
 * \brief Fused Multiply-Sub ( \c `(a * b) - acc` )
 * \details Performs the multiplication of the \c v16i input vectors \c a and \c b,
 *  then subtracts the last \c v16i input vector \c acc from the previous result.
 * \details Functionally equivalent to: \c `v16i_sub(v16i_mul(a, b), acc)`
 * \impl
for i from 0 to 15
  dst[i] := (a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `(a * b) - acc`
 */
v16i v16i_fmsub(v16i a, v16i b, v16i acc);

/**
 * \ingroup arith
 * \related v1d
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v1d input vectors \c a and \c b,
 *  then subtracts the result from the last \c v1d input vector \c acc.
 * \details Functionally equivalent to: \c `v1d_sub(acc, v1d_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v1d v1d_fnmadd(v1d a, v1d b, v1d acc);
/**
 * \ingroup arith
 * \related v1f
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v1f input vectors \c a and \c b,
 *  then subtracts the result from the last \c v1f input vector \c acc.
 * \details Functionally equivalent to: \c `v1f_sub(acc, v1f_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v1f v1f_fnmadd(v1f a, v1f b, v1f acc);
/**
 * \ingroup arith
 * \related v1i
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v1i input vectors \c a and \c b,
 *  then subtracts the result from the last \c v1i input vector \c acc.
 * \details Functionally equivalent to: \c `v1i_sub(acc, v1i_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v1i v1i_fnmadd(v1i a, v1i b, v1i acc);
/**
 * \ingroup arith
 * \related v1l
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v1l input vectors \c a and \c b,
 *  then subtracts the result from the last \c v1l input vector \c acc.
 * \details Functionally equivalent to: \c `v1l_sub(acc, v1l_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v1l v1l_fnmadd(v1l a, v1l b, v1l acc);
/**
 * \ingroup arith
 * \related v2d
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v2d input vectors \c a and \c b,
 *  then subtracts the result from the last \c v2d input vector \c acc.
 * \details Functionally equivalent to: \c `v2d_sub(acc, v2d_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v2d v2d_fnmadd(v2d a, v2d b, v2d acc);
/**
 * \ingroup arith
 * \related v2f
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v2f input vectors \c a and \c b,
 *  then subtracts the result from the last \c v2f input vector \c acc.
 * \details Functionally equivalent to: \c `v2f_sub(acc, v2f_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v2f v2f_fnmadd(v2f a, v2f b, v2f acc);
/**
 * \ingroup arith
 * \related v2i
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v2i input vectors \c a and \c b,
 *  then subtracts the result from the last \c v2i input vector \c acc.
 * \details Functionally equivalent to: \c `v2i_sub(acc, v2i_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v2i v2i_fnmadd(v2i a, v2i b, v2i acc);
/**
 * \ingroup arith
 * \related v2l
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v2l input vectors \c a and \c b,
 *  then subtracts the result from the last \c v2l input vector \c acc.
 * \details Functionally equivalent to: \c `v2l_sub(acc, v2l_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v2l v2l_fnmadd(v2l a, v2l b, v2l acc);
/**
 * \ingroup arith
 * \related v4d
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v4d input vectors \c a and \c b,
 *  then subtracts the result from the last \c v4d input vector \c acc.
 * \details Functionally equivalent to: \c `v4d_sub(acc, v4d_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v4d v4d_fnmadd(v4d a, v4d b, v4d acc);
/**
 * \ingroup arith
 * \related v4f
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v4f input vectors \c a and \c b,
 *  then subtracts the result from the last \c v4f input vector \c acc.
 * \details Functionally equivalent to: \c `v4f_sub(acc, v4f_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v4f v4f_fnmadd(v4f a, v4f b, v4f acc);
/**
 * \ingroup arith
 * \related v4i
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v4i input vectors \c a and \c b,
 *  then subtracts the result from the last \c v4i input vector \c acc.
 * \details Functionally equivalent to: \c `v4i_sub(acc, v4i_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v4i v4i_fnmadd(v4i a, v4i b, v4i acc);
/**
 * \ingroup arith
 * \related v4l
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v4l input vectors \c a and \c b,
 *  then subtracts the result from the last \c v4l input vector \c acc.
 * \details Functionally equivalent to: \c `v4l_sub(acc, v4l_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v4l v4l_fnmadd(v4l a, v4l b, v4l acc);
/**
 * \ingroup arith
 * \related v8d
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v8d input vectors \c a and \c b,
 *  then subtracts the result from the last \c v8d input vector \c acc.
 * \details Functionally equivalent to: \c `v8d_sub(acc, v8d_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v8d v8d_fnmadd(v8d a, v8d b, v8d acc);
/**
 * \ingroup arith
 * \related v8f
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v8f input vectors \c a and \c b,
 *  then subtracts the result from the last \c v8f input vector \c acc.
 * \details Functionally equivalent to: \c `v8f_sub(acc, v8f_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v8f v8f_fnmadd(v8f a, v8f b, v8f acc);
/**
 * \ingroup arith
 * \related v8i
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v8i input vectors \c a and \c b,
 *  then subtracts the result from the last \c v8i input vector \c acc.
 * \details Functionally equivalent to: \c `v8i_sub(acc, v8i_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v8i v8i_fnmadd(v8i a, v8i b, v8i acc);
/**
 * \ingroup arith
 * \related v8l
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v8l input vectors \c a and \c b,
 *  then subtracts the result from the last \c v8l input vector \c acc.
 * \details Functionally equivalent to: \c `v8l_sub(acc, v8l_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v8l v8l_fnmadd(v8l a, v8l b, v8l acc);
/**
 * \ingroup arith
 * \related v16f
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v16f input vectors \c a and \c b,
 *  then subtracts the result from the last \c v16f input vector \c acc.
 * \details Functionally equivalent to: \c `v16f_sub(acc, v16f_mul(a, b))`
 * \impl
for i from 0 to 15
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v16f v16f_fnmadd(v16f a, v16f b, v16f acc);
/**
 * \ingroup arith
 * \related v16i
 * \brief Fused Multiply-Add ( \c `-(a * b) + acc` )
 * \details Performs the multiplication of the \c v16i input vectors \c a and \c b,
 *  then subtracts the result from the last \c v16i input vector \c acc.
 * \details Functionally equivalent to: \c `v16i_sub(acc, v16i_mul(a, b))`
 * \impl
for i from 0 to 15
  dst[i] := -(a[i] * b[i]) + acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) + acc`
 */
v16i v16i_fnmadd(v16i a, v16i b, v16i acc);

/**
 * \ingroup arith
 * \related v1d
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v1d input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v1d input vector \c acc.
 * \details Functionally equivalent to: \c `v1d_sub(v1d_neg(acc), v1d_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v1d v1d_fnmsub(v1d a, v1d b, v1d acc);
/**
 * \ingroup arith
 * \related v1f
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v1f input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v1f input vector \c acc.
 * \details Functionally equivalent to: \c `v1f_sub(v1f_neg(acc), v1f_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v1f v1f_fnmsub(v1f a, v1f b, v1f acc);
/**
 * \ingroup arith
 * \related v1i
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v1i input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v1i input vector \c acc.
 * \details Functionally equivalent to: \c `v1i_sub(v1i_neg(acc), v1i_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v1i v1i_fnmsub(v1i a, v1i b, v1i acc);
/**
 * \ingroup arith
 * \related v1l
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v1l input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v1l input vector \c acc.
 * \details Functionally equivalent to: \c `v1l_sub(v1l_neg(acc), v1l_mul(a, b))`
 * \impl
for i from 0 to 0
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v1l v1l_fnmsub(v1l a, v1l b, v1l acc);
/**
 * \ingroup arith
 * \related v2d
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v2d input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v2d input vector \c acc.
 * \details Functionally equivalent to: \c `v2d_sub(v2d_neg(acc), v2d_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v2d v2d_fnmsub(v2d a, v2d b, v2d acc);
/**
 * \ingroup arith
 * \related v2f
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v2f input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v2f input vector \c acc.
 * \details Functionally equivalent to: \c `v2f_sub(v2f_neg(acc), v2f_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v2f v2f_fnmsub(v2f a, v2f b, v2f acc);
/**
 * \ingroup arith
 * \related v2i
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v2i input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v2i input vector \c acc.
 * \details Functionally equivalent to: \c `v2i_sub(v2i_neg(acc), v2i_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v2i v2i_fnmsub(v2i a, v2i b, v2i acc);
/**
 * \ingroup arith
 * \related v2l
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v2l input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v2l input vector \c acc.
 * \details Functionally equivalent to: \c `v2l_sub(v2l_neg(acc), v2l_mul(a, b))`
 * \impl
for i from 0 to 1
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v2l v2l_fnmsub(v2l a, v2l b, v2l acc);
/**
 * \ingroup arith
 * \related v4d
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v4d input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v4d input vector \c acc.
 * \details Functionally equivalent to: \c `v4d_sub(v4d_neg(acc), v4d_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v4d v4d_fnmsub(v4d a, v4d b, v4d acc);
/**
 * \ingroup arith
 * \related v4f
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v4f input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v4f input vector \c acc.
 * \details Functionally equivalent to: \c `v4f_sub(v4f_neg(acc), v4f_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v4f v4f_fnmsub(v4f a, v4f b, v4f acc);
/**
 * \ingroup arith
 * \related v4i
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v4i input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v4i input vector \c acc.
 * \details Functionally equivalent to: \c `v4i_sub(v4i_neg(acc), v4i_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v4i v4i_fnmsub(v4i a, v4i b, v4i acc);
/**
 * \ingroup arith
 * \related v4l
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v4l input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v4l input vector \c acc.
 * \details Functionally equivalent to: \c `v4l_sub(v4l_neg(acc), v4l_mul(a, b))`
 * \impl
for i from 0 to 3
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v4l v4l_fnmsub(v4l a, v4l b, v4l acc);
/**
 * \ingroup arith
 * \related v8d
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v8d input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v8d input vector \c acc.
 * \details Functionally equivalent to: \c `v8d_sub(v8d_neg(acc), v8d_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v8d v8d_fnmsub(v8d a, v8d b, v8d acc);
/**
 * \ingroup arith
 * \related v8f
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v8f input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v8f input vector \c acc.
 * \details Functionally equivalent to: \c `v8f_sub(v8f_neg(acc), v8f_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v8f v8f_fnmsub(v8f a, v8f b, v8f acc);
/**
 * \ingroup arith
 * \related v8i
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v8i input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v8i input vector \c acc.
 * \details Functionally equivalent to: \c `v8i_sub(v8i_neg(acc), v8i_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v8i v8i_fnmsub(v8i a, v8i b, v8i acc);
/**
 * \ingroup arith
 * \related v8l
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v8l input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v8l input vector \c acc.
 * \details Functionally equivalent to: \c `v8l_sub(v8l_neg(acc), v8l_mul(a, b))`
 * \impl
for i from 0 to 7
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v8l v8l_fnmsub(v8l a, v8l b, v8l acc);
/**
 * \ingroup arith
 * \related v16f
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v16f input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v16f input vector \c acc.
 * \details Functionally equivalent to: \c `v16f_sub(v16f_neg(acc), v16f_mul(a, b))`
 * \impl
for i from 0 to 15
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v16f v16f_fnmsub(v16f a, v16f b, v16f acc);
/**
 * \ingroup arith
 * \related v16i
 * \brief Fused Multiply-Add ( \c `-(a * b) - acc` )
 * \details Performs the multiplication of the \c v16i input vectors \c a and \c b,
 *  then subtracts the result from the negation of the last \c v16i input vector \c acc.
 * \details Functionally equivalent to: \c `v16i_sub(v16i_neg(acc), v16i_mul(a, b))`
 * \impl
for i from 0 to 15
  dst[i] := -(a[i] * b[i]) - acc[i]
endfor
\endimpl
 * \param a first factor
 * \param b second factor
 * \param acc accumulator
 * \returns result of \c `-(a * b) - acc`
 */
v16i v16i_fnmsub(v16i a, v16i b, v16i acc);

/* MERGES */
/** \defgroup merge merge functions
 * 
 */

/**
 * \ingroup merge
 * \related v2d
 * \brief Merges 2 \c v1d vectors together.
 * \details Merges 2 \c v1d vectors together into one \c v2d vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v2d v2d_merge2_v1d(v1d a0, v1d a1);
/**
 * \ingroup merge
 * \related v2f
 * \brief Merges 2 \c v1f vectors together.
 * \details Merges 2 \c v1f vectors together into one \c v2f vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v2f v2f_merge2_v1f(v1f a0, v1f a1);
/**
 * \ingroup merge
 * \related v2i
 * \brief Merges 2 \c v1i vectors together.
 * \details Merges 2 \c v1i vectors together into one \c v2i vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v2i v2i_merge2_v1i(v1i a0, v1i a1);
/**
 * \ingroup merge
 * \related v2l
 * \brief Merges 2 \c v1l vectors together.
 * \details Merges 2 \c v1l vectors together into one \c v2l vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v2l v2l_merge2_v1l(v1l a0, v1l a1);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 2 \c v2d vectors together.
 * \details Merges 2 \c v2d vectors together into one \c v4d vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v4d v4d_merge2_v2d(v2d a0, v2d a1);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 2 \c v2f vectors together.
 * \details Merges 2 \c v2f vectors together into one \c v4f vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v4f v4f_merge2_v2f(v2f a0, v2f a1);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 2 \c v2i vectors together.
 * \details Merges 2 \c v2i vectors together into one \c v4i vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v4i v4i_merge2_v2i(v2i a0, v2i a1);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 2 \c v2l vectors together.
 * \details Merges 2 \c v2l vectors together into one \c v4l vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v4l v4l_merge2_v2l(v2l a0, v2l a1);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 2 \c v4d vectors together.
 * \details Merges 2 \c v4d vectors together into one \c v8d vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v8d v8d_merge2_v4d(v4d a0, v4d a1);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 2 \c v4f vectors together.
 * \details Merges 2 \c v4f vectors together into one \c v8f vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v8f v8f_merge2_v4f(v4f a0, v4f a1);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 2 \c v4i vectors together.
 * \details Merges 2 \c v4i vectors together into one \c v8i vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v8i v8i_merge2_v4i(v4i a0, v4i a1);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 2 \c v4l vectors together.
 * \details Merges 2 \c v4l vectors together into one \c v8l vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v8l v8l_merge2_v4l(v4l a0, v4l a1);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 2 \c v8f vectors together.
 * \details Merges 2 \c v8f vectors together into one \c v16f vector.
 * \impl
dst[0:7] := a0[0:7]
dst[8:15] := a1[0:7]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v16f v16f_merge2_v8f(v8f a0, v8f a1);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 2 \c v8i vectors together.
 * \details Merges 2 \c v8i vectors together into one \c v16i vector.
 * \impl
dst[0:7] := a0[0:7]
dst[8:15] := a1[0:7]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \returns merged vector
 */
v16i v16i_merge2_v8i(v8i a0, v8i a1);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 4 \c v1d vectors together.
 * \details Merges 4 \c v1d vectors together into one \c v4d vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v4d v4d_merge4_v1d(v1d a0, v1d a1, v1d a2, v1d a3);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 4 \c v1f vectors together.
 * \details Merges 4 \c v1f vectors together into one \c v4f vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v4f v4f_merge4_v1f(v1f a0, v1f a1, v1f a2, v1f a3);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 4 \c v1i vectors together.
 * \details Merges 4 \c v1i vectors together into one \c v4i vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v4i v4i_merge4_v1i(v1i a0, v1i a1, v1i a2, v1i a3);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 4 \c v1l vectors together.
 * \details Merges 4 \c v1l vectors together into one \c v4l vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v4l v4l_merge4_v1l(v1l a0, v1l a1, v1l a2, v1l a3);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 4 \c v2d vectors together.
 * \details Merges 4 \c v2d vectors together into one \c v8d vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v8d v8d_merge4_v2d(v2d a0, v2d a1, v2d a2, v2d a3);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 4 \c v2f vectors together.
 * \details Merges 4 \c v2f vectors together into one \c v8f vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v8f v8f_merge4_v2f(v2f a0, v2f a1, v2f a2, v2f a3);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 4 \c v2i vectors together.
 * \details Merges 4 \c v2i vectors together into one \c v8i vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v8i v8i_merge4_v2i(v2i a0, v2i a1, v2i a2, v2i a3);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 4 \c v2l vectors together.
 * \details Merges 4 \c v2l vectors together into one \c v8l vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v8l v8l_merge4_v2l(v2l a0, v2l a1, v2l a2, v2l a3);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 4 \c v4f vectors together.
 * \details Merges 4 \c v4f vectors together into one \c v16f vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
dst[8:11] := a2[0:3]
dst[12:15] := a3[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v16f v16f_merge4_v4f(v4f a0, v4f a1, v4f a2, v4f a3);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 4 \c v4i vectors together.
 * \details Merges 4 \c v4i vectors together into one \c v16i vector.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
dst[8:11] := a2[0:3]
dst[12:15] := a3[0:3]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \returns merged vector
 */
v16i v16i_merge4_v4i(v4i a0, v4i a1, v4i a2, v4i a3);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 8 \c v1d vectors together.
 * \details Merges 8 \c v1d vectors together into one \c v8d vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v8d v8d_merge8_v1d(v1d a0, v1d a1, v1d a2, v1d a3, v1d a4, v1d a5, v1d a6, v1d a7);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 8 \c v1f vectors together.
 * \details Merges 8 \c v1f vectors together into one \c v8f vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v8f v8f_merge8_v1f(v1f a0, v1f a1, v1f a2, v1f a3, v1f a4, v1f a5, v1f a6, v1f a7);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 8 \c v1i vectors together.
 * \details Merges 8 \c v1i vectors together into one \c v8i vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v8i v8i_merge8_v1i(v1i a0, v1i a1, v1i a2, v1i a3, v1i a4, v1i a5, v1i a6, v1i a7);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 8 \c v1l vectors together.
 * \details Merges 8 \c v1l vectors together into one \c v8l vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v8l v8l_merge8_v1l(v1l a0, v1l a1, v1l a2, v1l a3, v1l a4, v1l a5, v1l a6, v1l a7);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 8 \c v2f vectors together.
 * \details Merges 8 \c v2f vectors together into one \c v16f vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
dst[8:9] := a4[0:1]
dst[10:11] := a5[0:1]
dst[12:13] := a6[0:1]
dst[14:15] := a7[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v16f v16f_merge8_v2f(v2f a0, v2f a1, v2f a2, v2f a3, v2f a4, v2f a5, v2f a6, v2f a7);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 8 \c v2i vectors together.
 * \details Merges 8 \c v2i vectors together into one \c v16i vector.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
dst[8:9] := a4[0:1]
dst[10:11] := a5[0:1]
dst[12:13] := a6[0:1]
dst[14:15] := a7[0:1]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \returns merged vector
 */
v16i v16i_merge8_v2i(v2i a0, v2i a1, v2i a2, v2i a3, v2i a4, v2i a5, v2i a6, v2i a7);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 16 \c v1f vectors together.
 * \details Merges 16 \c v1f vectors together into one \c v16f vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
dst[8] := a8[0]
dst[9] := a9[0]
dst[10] := a10[0]
dst[11] := a11[0]
dst[12] := a12[0]
dst[13] := a13[0]
dst[14] := a14[0]
dst[15] := a15[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \param a8 9th part of the result vector
 * \param a9 10th part of the result vector
 * \param a10 11th part of the result vector
 * \param a11 12th part of the result vector
 * \param a12 13th part of the result vector
 * \param a13 14th part of the result vector
 * \param a14 15th part of the result vector
 * \param a15 16th part of the result vector
 * \returns merged vector
 */
v16f v16f_merge16_v1f(v1f a0, v1f a1, v1f a2, v1f a3, v1f a4, v1f a5, v1f a6, v1f a7, v1f a8, v1f a9, v1f a10, v1f a11, v1f a12, v1f a13, v1f a14, v1f a15);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 16 \c v1i vectors together.
 * \details Merges 16 \c v1i vectors together into one \c v16i vector.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
dst[8] := a8[0]
dst[9] := a9[0]
dst[10] := a10[0]
dst[11] := a11[0]
dst[12] := a12[0]
dst[13] := a13[0]
dst[14] := a14[0]
dst[15] := a15[0]
\endimpl
 * \param a0 1nd part of the result vector
 * \param a1 2rd part of the result vector
 * \param a2 3th part of the result vector
 * \param a3 4th part of the result vector
 * \param a4 5th part of the result vector
 * \param a5 6th part of the result vector
 * \param a6 7th part of the result vector
 * \param a7 8th part of the result vector
 * \param a8 9th part of the result vector
 * \param a9 10th part of the result vector
 * \param a10 11th part of the result vector
 * \param a11 12th part of the result vector
 * \param a12 13th part of the result vector
 * \param a13 14th part of the result vector
 * \param a14 15th part of the result vector
 * \param a15 16th part of the result vector
 * \returns merged vector
 */
v16i v16i_merge16_v1i(v1i a0, v1i a1, v1i a2, v1i a3, v1i a4, v1i a5, v1i a6, v1i a7, v1i a8, v1i a9, v1i a10, v1i a11, v1i a12, v1i a13, v1i a14, v1i a15);

/**
 * \ingroup merge
 * \related v2d
 * \brief Merges 2 \c v1d vectors together (reverse order).
 * \details Merges 2 \c v1d vectors together into one \c v2d vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \see v2d_merge2_v1d(v1d a0, v1d a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v2d v2d_rmerge2_v1d(v1d a1, v1d a0);
/**
 * \ingroup merge
 * \related v2f
 * \brief Merges 2 \c v1f vectors together (reverse order).
 * \details Merges 2 \c v1f vectors together into one \c v2f vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \see v2f_merge2_v1f(v1f a0, v1f a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v2f v2f_rmerge2_v1f(v1f a1, v1f a0);
/**
 * \ingroup merge
 * \related v2i
 * \brief Merges 2 \c v1i vectors together (reverse order).
 * \details Merges 2 \c v1i vectors together into one \c v2i vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \see v2i_merge2_v1i(v1i a0, v1i a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v2i v2i_rmerge2_v1i(v1i a1, v1i a0);
/**
 * \ingroup merge
 * \related v2l
 * \brief Merges 2 \c v1l vectors together (reverse order).
 * \details Merges 2 \c v1l vectors together into one \c v2l vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
\endimpl
 * \see v2l_merge2_v1l(v1l a0, v1l a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v2l v2l_rmerge2_v1l(v1l a1, v1l a0);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 2 \c v2d vectors together (reverse order).
 * \details Merges 2 \c v2d vectors together into one \c v4d vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \see v4d_merge2_v2d(v2d a0, v2d a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4d v4d_rmerge2_v2d(v2d a1, v2d a0);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 2 \c v2f vectors together (reverse order).
 * \details Merges 2 \c v2f vectors together into one \c v4f vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \see v4f_merge2_v2f(v2f a0, v2f a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4f v4f_rmerge2_v2f(v2f a1, v2f a0);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 2 \c v2i vectors together (reverse order).
 * \details Merges 2 \c v2i vectors together into one \c v4i vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \see v4i_merge2_v2i(v2i a0, v2i a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4i v4i_rmerge2_v2i(v2i a1, v2i a0);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 2 \c v2l vectors together (reverse order).
 * \details Merges 2 \c v2l vectors together into one \c v4l vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
\endimpl
 * \see v4l_merge2_v2l(v2l a0, v2l a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4l v4l_rmerge2_v2l(v2l a1, v2l a0);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 2 \c v4d vectors together (reverse order).
 * \details Merges 2 \c v4d vectors together into one \c v8d vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \see v8d_merge2_v4d(v4d a0, v4d a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8d v8d_rmerge2_v4d(v4d a1, v4d a0);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 2 \c v4f vectors together (reverse order).
 * \details Merges 2 \c v4f vectors together into one \c v8f vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \see v8f_merge2_v4f(v4f a0, v4f a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8f v8f_rmerge2_v4f(v4f a1, v4f a0);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 2 \c v4i vectors together (reverse order).
 * \details Merges 2 \c v4i vectors together into one \c v8i vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \see v8i_merge2_v4i(v4i a0, v4i a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8i v8i_rmerge2_v4i(v4i a1, v4i a0);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 2 \c v4l vectors together (reverse order).
 * \details Merges 2 \c v4l vectors together into one \c v8l vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
\endimpl
 * \see v8l_merge2_v4l(v4l a0, v4l a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8l v8l_rmerge2_v4l(v4l a1, v4l a0);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 2 \c v8f vectors together (reverse order).
 * \details Merges 2 \c v8f vectors together into one \c v16f vector in reversed order.
 * \impl
dst[0:7] := a0[0:7]
dst[8:15] := a1[0:7]
\endimpl
 * \see v16f_merge2_v8f(v8f a0, v8f a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16f v16f_rmerge2_v8f(v8f a1, v8f a0);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 2 \c v8i vectors together (reverse order).
 * \details Merges 2 \c v8i vectors together into one \c v16i vector in reversed order.
 * \impl
dst[0:7] := a0[0:7]
dst[8:15] := a1[0:7]
\endimpl
 * \see v16i_merge2_v8i(v8i a0, v8i a1)
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16i v16i_rmerge2_v8i(v8i a1, v8i a0);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 4 \c v1d vectors together (reverse order).
 * \details Merges 4 \c v1d vectors together into one \c v4d vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \see v4d_merge4_v1d(v1d a0, v1d a1, v1d a2, v1d a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4d v4d_rmerge4_v1d(v1d a3, v1d a2, v1d a1, v1d a0);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 4 \c v1f vectors together (reverse order).
 * \details Merges 4 \c v1f vectors together into one \c v4f vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \see v4f_merge4_v1f(v1f a0, v1f a1, v1f a2, v1f a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4f v4f_rmerge4_v1f(v1f a3, v1f a2, v1f a1, v1f a0);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 4 \c v1i vectors together (reverse order).
 * \details Merges 4 \c v1i vectors together into one \c v4i vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \see v4i_merge4_v1i(v1i a0, v1i a1, v1i a2, v1i a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4i v4i_rmerge4_v1i(v1i a3, v1i a2, v1i a1, v1i a0);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 4 \c v1l vectors together (reverse order).
 * \details Merges 4 \c v1l vectors together into one \c v4l vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
\endimpl
 * \see v4l_merge4_v1l(v1l a0, v1l a1, v1l a2, v1l a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v4l v4l_rmerge4_v1l(v1l a3, v1l a2, v1l a1, v1l a0);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 4 \c v2d vectors together (reverse order).
 * \details Merges 4 \c v2d vectors together into one \c v8d vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \see v8d_merge4_v2d(v2d a0, v2d a1, v2d a2, v2d a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8d v8d_rmerge4_v2d(v2d a3, v2d a2, v2d a1, v2d a0);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 4 \c v2f vectors together (reverse order).
 * \details Merges 4 \c v2f vectors together into one \c v8f vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \see v8f_merge4_v2f(v2f a0, v2f a1, v2f a2, v2f a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8f v8f_rmerge4_v2f(v2f a3, v2f a2, v2f a1, v2f a0);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 4 \c v2i vectors together (reverse order).
 * \details Merges 4 \c v2i vectors together into one \c v8i vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \see v8i_merge4_v2i(v2i a0, v2i a1, v2i a2, v2i a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8i v8i_rmerge4_v2i(v2i a3, v2i a2, v2i a1, v2i a0);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 4 \c v2l vectors together (reverse order).
 * \details Merges 4 \c v2l vectors together into one \c v8l vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
\endimpl
 * \see v8l_merge4_v2l(v2l a0, v2l a1, v2l a2, v2l a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8l v8l_rmerge4_v2l(v2l a3, v2l a2, v2l a1, v2l a0);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 4 \c v4f vectors together (reverse order).
 * \details Merges 4 \c v4f vectors together into one \c v16f vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
dst[8:11] := a2[0:3]
dst[12:15] := a3[0:3]
\endimpl
 * \see v16f_merge4_v4f(v4f a0, v4f a1, v4f a2, v4f a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16f v16f_rmerge4_v4f(v4f a3, v4f a2, v4f a1, v4f a0);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 4 \c v4i vectors together (reverse order).
 * \details Merges 4 \c v4i vectors together into one \c v16i vector in reversed order.
 * \impl
dst[0:3] := a0[0:3]
dst[4:7] := a1[0:3]
dst[8:11] := a2[0:3]
dst[12:15] := a3[0:3]
\endimpl
 * \see v16i_merge4_v4i(v4i a0, v4i a1, v4i a2, v4i a3)
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16i v16i_rmerge4_v4i(v4i a3, v4i a2, v4i a1, v4i a0);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 8 \c v1d vectors together (reverse order).
 * \details Merges 8 \c v1d vectors together into one \c v8d vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \see v8d_merge8_v1d(v1d a0, v1d a1, v1d a2, v1d a3, v1d a4, v1d a5, v1d a6, v1d a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8d v8d_rmerge8_v1d(v1d a7, v1d a6, v1d a5, v1d a4, v1d a3, v1d a2, v1d a1, v1d a0);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 8 \c v1f vectors together (reverse order).
 * \details Merges 8 \c v1f vectors together into one \c v8f vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \see v8f_merge8_v1f(v1f a0, v1f a1, v1f a2, v1f a3, v1f a4, v1f a5, v1f a6, v1f a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8f v8f_rmerge8_v1f(v1f a7, v1f a6, v1f a5, v1f a4, v1f a3, v1f a2, v1f a1, v1f a0);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 8 \c v1i vectors together (reverse order).
 * \details Merges 8 \c v1i vectors together into one \c v8i vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \see v8i_merge8_v1i(v1i a0, v1i a1, v1i a2, v1i a3, v1i a4, v1i a5, v1i a6, v1i a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8i v8i_rmerge8_v1i(v1i a7, v1i a6, v1i a5, v1i a4, v1i a3, v1i a2, v1i a1, v1i a0);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 8 \c v1l vectors together (reverse order).
 * \details Merges 8 \c v1l vectors together into one \c v8l vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
\endimpl
 * \see v8l_merge8_v1l(v1l a0, v1l a1, v1l a2, v1l a3, v1l a4, v1l a5, v1l a6, v1l a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v8l v8l_rmerge8_v1l(v1l a7, v1l a6, v1l a5, v1l a4, v1l a3, v1l a2, v1l a1, v1l a0);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 8 \c v2f vectors together (reverse order).
 * \details Merges 8 \c v2f vectors together into one \c v16f vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
dst[8:9] := a4[0:1]
dst[10:11] := a5[0:1]
dst[12:13] := a6[0:1]
dst[14:15] := a7[0:1]
\endimpl
 * \see v16f_merge8_v2f(v2f a0, v2f a1, v2f a2, v2f a3, v2f a4, v2f a5, v2f a6, v2f a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16f v16f_rmerge8_v2f(v2f a7, v2f a6, v2f a5, v2f a4, v2f a3, v2f a2, v2f a1, v2f a0);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 8 \c v2i vectors together (reverse order).
 * \details Merges 8 \c v2i vectors together into one \c v16i vector in reversed order.
 * \impl
dst[0:1] := a0[0:1]
dst[2:3] := a1[0:1]
dst[4:5] := a2[0:1]
dst[6:7] := a3[0:1]
dst[8:9] := a4[0:1]
dst[10:11] := a5[0:1]
dst[12:13] := a6[0:1]
dst[14:15] := a7[0:1]
\endimpl
 * \see v16i_merge8_v2i(v2i a0, v2i a1, v2i a2, v2i a3, v2i a4, v2i a5, v2i a6, v2i a7)
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16i v16i_rmerge8_v2i(v2i a7, v2i a6, v2i a5, v2i a4, v2i a3, v2i a2, v2i a1, v2i a0);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 16 \c v1f vectors together (reverse order).
 * \details Merges 16 \c v1f vectors together into one \c v16f vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
dst[8] := a8[0]
dst[9] := a9[0]
dst[10] := a10[0]
dst[11] := a11[0]
dst[12] := a12[0]
dst[13] := a13[0]
dst[14] := a14[0]
dst[15] := a15[0]
\endimpl
 * \see v16f_merge16_v1f(v1f a0, v1f a1, v1f a2, v1f a3, v1f a4, v1f a5, v1f a6, v1f a7, v1f a8, v1f a9, v1f a10, v1f a11, v1f a12, v1f a13, v1f a14, v1f a15)
 * \param a15 16th part of the result vector
 * \param a14 15th part of the result vector
 * \param a13 14th part of the result vector
 * \param a12 13th part of the result vector
 * \param a11 12th part of the result vector
 * \param a10 11th part of the result vector
 * \param a9 10th part of the result vector
 * \param a8 9th part of the result vector
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16f v16f_rmerge16_v1f(v1f a15, v1f a14, v1f a13, v1f a12, v1f a11, v1f a10, v1f a9, v1f a8, v1f a7, v1f a6, v1f a5, v1f a4, v1f a3, v1f a2, v1f a1, v1f a0);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 16 \c v1i vectors together (reverse order).
 * \details Merges 16 \c v1i vectors together into one \c v16i vector in reversed order.
 * \impl
dst[0] := a0[0]
dst[1] := a1[0]
dst[2] := a2[0]
dst[3] := a3[0]
dst[4] := a4[0]
dst[5] := a5[0]
dst[6] := a6[0]
dst[7] := a7[0]
dst[8] := a8[0]
dst[9] := a9[0]
dst[10] := a10[0]
dst[11] := a11[0]
dst[12] := a12[0]
dst[13] := a13[0]
dst[14] := a14[0]
dst[15] := a15[0]
\endimpl
 * \see v16i_merge16_v1i(v1i a0, v1i a1, v1i a2, v1i a3, v1i a4, v1i a5, v1i a6, v1i a7, v1i a8, v1i a9, v1i a10, v1i a11, v1i a12, v1i a13, v1i a14, v1i a15)
 * \param a15 16th part of the result vector
 * \param a14 15th part of the result vector
 * \param a13 14th part of the result vector
 * \param a12 13th part of the result vector
 * \param a11 12th part of the result vector
 * \param a10 11th part of the result vector
 * \param a9 10th part of the result vector
 * \param a8 9th part of the result vector
 * \param a7 8th part of the result vector
 * \param a6 7th part of the result vector
 * \param a5 6th part of the result vector
 * \param a4 5th part of the result vector
 * \param a3 4th part of the result vector
 * \param a2 3th part of the result vector
 * \param a1 2rd part of the result vector
 * \param a0 1nd part of the result vector
 * \returns merged vector
 */
v16i v16i_rmerge16_v1i(v1i a15, v1i a14, v1i a13, v1i a12, v1i a11, v1i a10, v1i a9, v1i a8, v1i a7, v1i a6, v1i a5, v1i a4, v1i a3, v1i a2, v1i a1, v1i a0);

/**
 * \ingroup merge
 * \related v2d
 * \brief Merges 2 \c v1d vectors together.
 * \details Merges 2 \c v1d vectors together into one \c v2d vector.
 *  Alias of v2d_merge2_v1d(v1d a0, v1d a1)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v2d v2d_merge_v1d(v1d low, v1d high);
/**
 * \ingroup merge
 * \related v2f
 * \brief Merges 2 \c v1f vectors together.
 * \details Merges 2 \c v1f vectors together into one \c v2f vector.
 *  Alias of v2f_merge2_v1f(v1f a0, v1f a1)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v2f v2f_merge_v1f(v1f low, v1f high);
/**
 * \ingroup merge
 * \related v2i
 * \brief Merges 2 \c v1i vectors together.
 * \details Merges 2 \c v1i vectors together into one \c v2i vector.
 *  Alias of v2i_merge2_v1i(v1i a0, v1i a1)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v2i v2i_merge_v1i(v1i low, v1i high);
/**
 * \ingroup merge
 * \related v2l
 * \brief Merges 2 \c v1l vectors together.
 * \details Merges 2 \c v1l vectors together into one \c v2l vector.
 *  Alias of v2l_merge2_v1l(v1l a0, v1l a1)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v2l v2l_merge_v1l(v1l low, v1l high);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 2 \c v2d vectors together.
 * \details Merges 2 \c v2d vectors together into one \c v4d vector.
 *  Alias of v4d_merge2_v2d(v2d a0, v2d a1)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v4d v4d_merge_v2d(v2d low, v2d high);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 2 \c v2f vectors together.
 * \details Merges 2 \c v2f vectors together into one \c v4f vector.
 *  Alias of v4f_merge2_v2f(v2f a0, v2f a1)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v4f v4f_merge_v2f(v2f low, v2f high);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 2 \c v2i vectors together.
 * \details Merges 2 \c v2i vectors together into one \c v4i vector.
 *  Alias of v4i_merge2_v2i(v2i a0, v2i a1)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v4i v4i_merge_v2i(v2i low, v2i high);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 2 \c v2l vectors together.
 * \details Merges 2 \c v2l vectors together into one \c v4l vector.
 *  Alias of v4l_merge2_v2l(v2l a0, v2l a1)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v4l v4l_merge_v2l(v2l low, v2l high);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 2 \c v4d vectors together.
 * \details Merges 2 \c v4d vectors together into one \c v8d vector.
 *  Alias of v8d_merge2_v4d(v4d a0, v4d a1)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v8d v8d_merge_v4d(v4d low, v4d high);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 2 \c v4f vectors together.
 * \details Merges 2 \c v4f vectors together into one \c v8f vector.
 *  Alias of v8f_merge2_v4f(v4f a0, v4f a1)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v8f v8f_merge_v4f(v4f low, v4f high);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 2 \c v4i vectors together.
 * \details Merges 2 \c v4i vectors together into one \c v8i vector.
 *  Alias of v8i_merge2_v4i(v4i a0, v4i a1)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v8i v8i_merge_v4i(v4i low, v4i high);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 2 \c v4l vectors together.
 * \details Merges 2 \c v4l vectors together into one \c v8l vector.
 *  Alias of v8l_merge2_v4l(v4l a0, v4l a1)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v8l v8l_merge_v4l(v4l low, v4l high);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 2 \c v8f vectors together.
 * \details Merges 2 \c v8f vectors together into one \c v16f vector.
 *  Alias of v16f_merge2_v8f(v8f a0, v8f a1)
 * \impl
dst[0:7] := low[0:7]
dst[8:15] := high[0:7]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v16f v16f_merge_v8f(v8f low, v8f high);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 2 \c v8i vectors together.
 * \details Merges 2 \c v8i vectors together into one \c v16i vector.
 *  Alias of v16i_merge2_v8i(v8i a0, v8i a1)
 * \impl
dst[0:7] := low[0:7]
dst[8:15] := high[0:7]
\endimpl
 * \param low low part of the result vector
 * \param high high part of the result vector
 * \returns merged vector
 */
v16i v16i_merge_v8i(v8i low, v8i high);

/**
 * \ingroup merge
 * \related v2d
 * \brief Merges 2 \c v1d vectors together (reversed order).
 * \details Merges 2 \c v1d vectors together into one \c v2d vector in reversed order.
 *  Alias of v2d_rmerge2_v1d(v1d a1, v1d a0)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \see v2d_merge_v1d(v1d low, v1d high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v2d v2d_rmerge_v1d(v1d high, v1d low);
/**
 * \ingroup merge
 * \related v2f
 * \brief Merges 2 \c v1f vectors together (reversed order).
 * \details Merges 2 \c v1f vectors together into one \c v2f vector in reversed order.
 *  Alias of v2f_rmerge2_v1f(v1f a1, v1f a0)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \see v2f_merge_v1f(v1f low, v1f high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v2f v2f_rmerge_v1f(v1f high, v1f low);
/**
 * \ingroup merge
 * \related v2i
 * \brief Merges 2 \c v1i vectors together (reversed order).
 * \details Merges 2 \c v1i vectors together into one \c v2i vector in reversed order.
 *  Alias of v2i_rmerge2_v1i(v1i a1, v1i a0)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \see v2i_merge_v1i(v1i low, v1i high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v2i v2i_rmerge_v1i(v1i high, v1i low);
/**
 * \ingroup merge
 * \related v2l
 * \brief Merges 2 \c v1l vectors together (reversed order).
 * \details Merges 2 \c v1l vectors together into one \c v2l vector in reversed order.
 *  Alias of v2l_rmerge2_v1l(v1l a1, v1l a0)
 * \impl
dst[0] := low[0]
dst[1] := high[0]
\endimpl
 * \see v2l_merge_v1l(v1l low, v1l high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v2l v2l_rmerge_v1l(v1l high, v1l low);
/**
 * \ingroup merge
 * \related v4d
 * \brief Merges 2 \c v2d vectors together (reversed order).
 * \details Merges 2 \c v2d vectors together into one \c v4d vector in reversed order.
 *  Alias of v4d_rmerge2_v2d(v2d a1, v2d a0)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \see v4d_merge_v2d(v2d low, v2d high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v4d v4d_rmerge_v2d(v2d high, v2d low);
/**
 * \ingroup merge
 * \related v4f
 * \brief Merges 2 \c v2f vectors together (reversed order).
 * \details Merges 2 \c v2f vectors together into one \c v4f vector in reversed order.
 *  Alias of v4f_rmerge2_v2f(v2f a1, v2f a0)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \see v4f_merge_v2f(v2f low, v2f high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v4f v4f_rmerge_v2f(v2f high, v2f low);
/**
 * \ingroup merge
 * \related v4i
 * \brief Merges 2 \c v2i vectors together (reversed order).
 * \details Merges 2 \c v2i vectors together into one \c v4i vector in reversed order.
 *  Alias of v4i_rmerge2_v2i(v2i a1, v2i a0)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \see v4i_merge_v2i(v2i low, v2i high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v4i v4i_rmerge_v2i(v2i high, v2i low);
/**
 * \ingroup merge
 * \related v4l
 * \brief Merges 2 \c v2l vectors together (reversed order).
 * \details Merges 2 \c v2l vectors together into one \c v4l vector in reversed order.
 *  Alias of v4l_rmerge2_v2l(v2l a1, v2l a0)
 * \impl
dst[0:1] := low[0:1]
dst[2:3] := high[0:1]
\endimpl
 * \see v4l_merge_v2l(v2l low, v2l high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v4l v4l_rmerge_v2l(v2l high, v2l low);
/**
 * \ingroup merge
 * \related v8d
 * \brief Merges 2 \c v4d vectors together (reversed order).
 * \details Merges 2 \c v4d vectors together into one \c v8d vector in reversed order.
 *  Alias of v8d_rmerge2_v4d(v4d a1, v4d a0)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \see v8d_merge_v4d(v4d low, v4d high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v8d v8d_rmerge_v4d(v4d high, v4d low);
/**
 * \ingroup merge
 * \related v8f
 * \brief Merges 2 \c v4f vectors together (reversed order).
 * \details Merges 2 \c v4f vectors together into one \c v8f vector in reversed order.
 *  Alias of v8f_rmerge2_v4f(v4f a1, v4f a0)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \see v8f_merge_v4f(v4f low, v4f high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v8f v8f_rmerge_v4f(v4f high, v4f low);
/**
 * \ingroup merge
 * \related v8i
 * \brief Merges 2 \c v4i vectors together (reversed order).
 * \details Merges 2 \c v4i vectors together into one \c v8i vector in reversed order.
 *  Alias of v8i_rmerge2_v4i(v4i a1, v4i a0)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \see v8i_merge_v4i(v4i low, v4i high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v8i v8i_rmerge_v4i(v4i high, v4i low);
/**
 * \ingroup merge
 * \related v8l
 * \brief Merges 2 \c v4l vectors together (reversed order).
 * \details Merges 2 \c v4l vectors together into one \c v8l vector in reversed order.
 *  Alias of v8l_rmerge2_v4l(v4l a1, v4l a0)
 * \impl
dst[0:3] := low[0:3]
dst[4:7] := high[0:3]
\endimpl
 * \see v8l_merge_v4l(v4l low, v4l high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v8l v8l_rmerge_v4l(v4l high, v4l low);
/**
 * \ingroup merge
 * \related v16f
 * \brief Merges 2 \c v8f vectors together (reversed order).
 * \details Merges 2 \c v8f vectors together into one \c v16f vector in reversed order.
 *  Alias of v16f_rmerge2_v8f(v8f a1, v8f a0)
 * \impl
dst[0:7] := low[0:7]
dst[8:15] := high[0:7]
\endimpl
 * \see v16f_merge_v8f(v8f low, v8f high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v16f v16f_rmerge_v8f(v8f high, v8f low);
/**
 * \ingroup merge
 * \related v16i
 * \brief Merges 2 \c v8i vectors together (reversed order).
 * \details Merges 2 \c v8i vectors together into one \c v16i vector in reversed order.
 *  Alias of v16i_rmerge2_v8i(v8i a1, v8i a0)
 * \impl
dst[0:7] := low[0:7]
dst[8:15] := high[0:7]
\endimpl
 * \see v16i_merge_v8i(v8i low, v8i high)
 * \param high high part of the result vector
 * \param low low part of the result vector
 * \returns merged vector
 */
v16i v16i_rmerge_v8i(v8i high, v8i low);


/* HIGH and LOW manipulation */
/** \defgroup hilo high and low part manipulation functions
 * 
 */

/**
 * \ingroup hilo
 * \related v2d
 * \brief Gets the low part of a \c v2d vector.
 * \details Gets the low part of a \c v2d vector.
 *  Same effect as v1d_cast_v2d(v2d a)
 * \impl
dst[0] := a[0]
\endimpl
 * \see v1d_get_high_v2d(v2d a)
 * \param a \c v2d vector within the low part is extracted
 * \returns low part of the input
 */
v1d v1d_get_low_v2d(v2d a);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Gets the low part of a \c v2f vector.
 * \details Gets the low part of a \c v2f vector.
 *  Same effect as v1f_cast_v2f(v2f a)
 * \impl
dst[0] := a[0]
\endimpl
 * \see v1f_get_high_v2f(v2f a)
 * \param a \c v2f vector within the low part is extracted
 * \returns low part of the input
 */
v1f v1f_get_low_v2f(v2f a);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Gets the low part of a \c v2i vector.
 * \details Gets the low part of a \c v2i vector.
 *  Same effect as v1i_cast_v2i(v2i a)
 * \impl
dst[0] := a[0]
\endimpl
 * \see v1i_get_high_v2i(v2i a)
 * \param a \c v2i vector within the low part is extracted
 * \returns low part of the input
 */
v1i v1i_get_low_v2i(v2i a);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Gets the low part of a \c v2l vector.
 * \details Gets the low part of a \c v2l vector.
 *  Same effect as v1l_cast_v2l(v2l a)
 * \impl
dst[0] := a[0]
\endimpl
 * \see v1l_get_high_v2l(v2l a)
 * \param a \c v2l vector within the low part is extracted
 * \returns low part of the input
 */
v1l v1l_get_low_v2l(v2l a);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Gets the low part of a \c v4d vector.
 * \details Gets the low part of a \c v4d vector.
 *  Same effect as v2d_cast_v4d(v4d a)
 * \impl
dst[0:1] := a[0:1]
\endimpl
 * \see v2d_get_high_v4d(v4d a)
 * \param a \c v4d vector within the low part is extracted
 * \returns low part of the input
 */
v2d v2d_get_low_v4d(v4d a);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Gets the low part of a \c v4f vector.
 * \details Gets the low part of a \c v4f vector.
 *  Same effect as v2f_cast_v4f(v4f a)
 * \impl
dst[0:1] := a[0:1]
\endimpl
 * \see v2f_get_high_v4f(v4f a)
 * \param a \c v4f vector within the low part is extracted
 * \returns low part of the input
 */
v2f v2f_get_low_v4f(v4f a);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Gets the low part of a \c v4i vector.
 * \details Gets the low part of a \c v4i vector.
 *  Same effect as v2i_cast_v4i(v4i a)
 * \impl
dst[0:1] := a[0:1]
\endimpl
 * \see v2i_get_high_v4i(v4i a)
 * \param a \c v4i vector within the low part is extracted
 * \returns low part of the input
 */
v2i v2i_get_low_v4i(v4i a);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Gets the low part of a \c v4l vector.
 * \details Gets the low part of a \c v4l vector.
 *  Same effect as v2l_cast_v4l(v4l a)
 * \impl
dst[0:1] := a[0:1]
\endimpl
 * \see v2l_get_high_v4l(v4l a)
 * \param a \c v4l vector within the low part is extracted
 * \returns low part of the input
 */
v2l v2l_get_low_v4l(v4l a);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Gets the low part of a \c v8d vector.
 * \details Gets the low part of a \c v8d vector.
 *  Same effect as v4d_cast_v8d(v8d a)
 * \impl
dst[0:3] := a[0:3]
\endimpl
 * \see v4d_get_high_v8d(v8d a)
 * \param a \c v8d vector within the low part is extracted
 * \returns low part of the input
 */
v4d v4d_get_low_v8d(v8d a);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Gets the low part of a \c v8f vector.
 * \details Gets the low part of a \c v8f vector.
 *  Same effect as v4f_cast_v8f(v8f a)
 * \impl
dst[0:3] := a[0:3]
\endimpl
 * \see v4f_get_high_v8f(v8f a)
 * \param a \c v8f vector within the low part is extracted
 * \returns low part of the input
 */
v4f v4f_get_low_v8f(v8f a);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Gets the low part of a \c v8i vector.
 * \details Gets the low part of a \c v8i vector.
 *  Same effect as v4i_cast_v8i(v8i a)
 * \impl
dst[0:3] := a[0:3]
\endimpl
 * \see v4i_get_high_v8i(v8i a)
 * \param a \c v8i vector within the low part is extracted
 * \returns low part of the input
 */
v4i v4i_get_low_v8i(v8i a);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Gets the low part of a \c v8l vector.
 * \details Gets the low part of a \c v8l vector.
 *  Same effect as v4l_cast_v8l(v8l a)
 * \impl
dst[0:3] := a[0:3]
\endimpl
 * \see v4l_get_high_v8l(v8l a)
 * \param a \c v8l vector within the low part is extracted
 * \returns low part of the input
 */
v4l v4l_get_low_v8l(v8l a);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Gets the low part of a \c v16f vector.
 * \details Gets the low part of a \c v16f vector.
 *  Same effect as v8f_cast_v16f(v16f a)
 * \impl
dst[0:7] := a[0:7]
\endimpl
 * \see v8f_get_high_v16f(v16f a)
 * \param a \c v16f vector within the low part is extracted
 * \returns low part of the input
 */
v8f v8f_get_low_v16f(v16f a);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Gets the low part of a \c v16i vector.
 * \details Gets the low part of a \c v16i vector.
 *  Same effect as v8i_cast_v16i(v16i a)
 * \impl
dst[0:7] := a[0:7]
\endimpl
 * \see v8i_get_high_v16i(v16i a)
 * \param a \c v16i vector within the low part is extracted
 * \returns low part of the input
 */
v8i v8i_get_low_v16i(v16i a);
/**
 * \ingroup hilo
 * \related v2d
 * \brief Gets the high part of a \c v2d vector.
 * \details Gets the high part of a \c v2d vector.
 * \impl
dst[0] := a[1]
\endimpl
 * \see v1d_get_low_v2d(v2d a)
 * \param a \c v2d vector within the high part is extracted
 * \returns high part of the input
 */
v1d v1d_get_high_v2d(v2d a);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Gets the high part of a \c v2f vector.
 * \details Gets the high part of a \c v2f vector.
 * \impl
dst[0] := a[1]
\endimpl
 * \see v1f_get_low_v2f(v2f a)
 * \param a \c v2f vector within the high part is extracted
 * \returns high part of the input
 */
v1f v1f_get_high_v2f(v2f a);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Gets the high part of a \c v2i vector.
 * \details Gets the high part of a \c v2i vector.
 * \impl
dst[0] := a[1]
\endimpl
 * \see v1i_get_low_v2i(v2i a)
 * \param a \c v2i vector within the high part is extracted
 * \returns high part of the input
 */
v1i v1i_get_high_v2i(v2i a);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Gets the high part of a \c v2l vector.
 * \details Gets the high part of a \c v2l vector.
 * \impl
dst[0] := a[1]
\endimpl
 * \see v1l_get_low_v2l(v2l a)
 * \param a \c v2l vector within the high part is extracted
 * \returns high part of the input
 */
v1l v1l_get_high_v2l(v2l a);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Gets the high part of a \c v4d vector.
 * \details Gets the high part of a \c v4d vector.
 * \impl
dst[0:1] := a[2:3]
\endimpl
 * \see v2d_get_low_v4d(v4d a)
 * \param a \c v4d vector within the high part is extracted
 * \returns high part of the input
 */
v2d v2d_get_high_v4d(v4d a);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Gets the high part of a \c v4f vector.
 * \details Gets the high part of a \c v4f vector.
 * \impl
dst[0:1] := a[2:3]
\endimpl
 * \see v2f_get_low_v4f(v4f a)
 * \param a \c v4f vector within the high part is extracted
 * \returns high part of the input
 */
v2f v2f_get_high_v4f(v4f a);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Gets the high part of a \c v4i vector.
 * \details Gets the high part of a \c v4i vector.
 * \impl
dst[0:1] := a[2:3]
\endimpl
 * \see v2i_get_low_v4i(v4i a)
 * \param a \c v4i vector within the high part is extracted
 * \returns high part of the input
 */
v2i v2i_get_high_v4i(v4i a);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Gets the high part of a \c v4l vector.
 * \details Gets the high part of a \c v4l vector.
 * \impl
dst[0:1] := a[2:3]
\endimpl
 * \see v2l_get_low_v4l(v4l a)
 * \param a \c v4l vector within the high part is extracted
 * \returns high part of the input
 */
v2l v2l_get_high_v4l(v4l a);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Gets the high part of a \c v8d vector.
 * \details Gets the high part of a \c v8d vector.
 * \impl
dst[0:3] := a[4:7]
\endimpl
 * \see v4d_get_low_v8d(v8d a)
 * \param a \c v8d vector within the high part is extracted
 * \returns high part of the input
 */
v4d v4d_get_high_v8d(v8d a);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Gets the high part of a \c v8f vector.
 * \details Gets the high part of a \c v8f vector.
 * \impl
dst[0:3] := a[4:7]
\endimpl
 * \see v4f_get_low_v8f(v8f a)
 * \param a \c v8f vector within the high part is extracted
 * \returns high part of the input
 */
v4f v4f_get_high_v8f(v8f a);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Gets the high part of a \c v8i vector.
 * \details Gets the high part of a \c v8i vector.
 * \impl
dst[0:3] := a[4:7]
\endimpl
 * \see v4i_get_low_v8i(v8i a)
 * \param a \c v8i vector within the high part is extracted
 * \returns high part of the input
 */
v4i v4i_get_high_v8i(v8i a);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Gets the high part of a \c v8l vector.
 * \details Gets the high part of a \c v8l vector.
 * \impl
dst[0:3] := a[4:7]
\endimpl
 * \see v4l_get_low_v8l(v8l a)
 * \param a \c v8l vector within the high part is extracted
 * \returns high part of the input
 */
v4l v4l_get_high_v8l(v8l a);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Gets the high part of a \c v16f vector.
 * \details Gets the high part of a \c v16f vector.
 * \impl
dst[0:7] := a[8:15]
\endimpl
 * \see v8f_get_low_v16f(v16f a)
 * \param a \c v16f vector within the high part is extracted
 * \returns high part of the input
 */
v8f v8f_get_high_v16f(v16f a);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Gets the high part of a \c v16i vector.
 * \details Gets the high part of a \c v16i vector.
 * \impl
dst[0:7] := a[8:15]
\endimpl
 * \see v8i_get_low_v16i(v16i a)
 * \param a \c v16i vector within the high part is extracted
 * \returns high part of the input
 */
v8i v8i_get_high_v16i(v16i a);
/**
 * \ingroup hilo
 * \related v2d
 * \brief Conditionnaly gets the low or the high part of a \c v2d vector.
 * \details If \c high is true, gets the high part of the \c v2d input vector.
 *  Else, gets the low part of the \c v2d input vector.
 * \impl
if high
  dst[0] := a[1]
else
  dst[0] := a[0]
endif
\endimpl
 * \see v1d_get_high_v2d(v2d a)
 * \see v1d_get_low_v2d(v2d a)
 * \param a \c v2d vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v1d v1d_get_hilo_v2d(v2d a, int high);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Conditionnaly gets the low or the high part of a \c v2f vector.
 * \details If \c high is true, gets the high part of the \c v2f input vector.
 *  Else, gets the low part of the \c v2f input vector.
 * \impl
if high
  dst[0] := a[1]
else
  dst[0] := a[0]
endif
\endimpl
 * \see v1f_get_high_v2f(v2f a)
 * \see v1f_get_low_v2f(v2f a)
 * \param a \c v2f vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v1f v1f_get_hilo_v2f(v2f a, int high);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Conditionnaly gets the low or the high part of a \c v2i vector.
 * \details If \c high is true, gets the high part of the \c v2i input vector.
 *  Else, gets the low part of the \c v2i input vector.
 * \impl
if high
  dst[0] := a[1]
else
  dst[0] := a[0]
endif
\endimpl
 * \see v1i_get_high_v2i(v2i a)
 * \see v1i_get_low_v2i(v2i a)
 * \param a \c v2i vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v1i v1i_get_hilo_v2i(v2i a, int high);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Conditionnaly gets the low or the high part of a \c v2l vector.
 * \details If \c high is true, gets the high part of the \c v2l input vector.
 *  Else, gets the low part of the \c v2l input vector.
 * \impl
if high
  dst[0] := a[1]
else
  dst[0] := a[0]
endif
\endimpl
 * \see v1l_get_high_v2l(v2l a)
 * \see v1l_get_low_v2l(v2l a)
 * \param a \c v2l vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v1l v1l_get_hilo_v2l(v2l a, int high);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Conditionnaly gets the low or the high part of a \c v4d vector.
 * \details If \c high is true, gets the high part of the \c v4d input vector.
 *  Else, gets the low part of the \c v4d input vector.
 * \impl
if high
  dst[0:1] := a[2:3]
else
  dst[0:1] := a[0:1]
endif
\endimpl
 * \see v2d_get_high_v4d(v4d a)
 * \see v2d_get_low_v4d(v4d a)
 * \param a \c v4d vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v2d v2d_get_hilo_v4d(v4d a, int high);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Conditionnaly gets the low or the high part of a \c v4f vector.
 * \details If \c high is true, gets the high part of the \c v4f input vector.
 *  Else, gets the low part of the \c v4f input vector.
 * \impl
if high
  dst[0:1] := a[2:3]
else
  dst[0:1] := a[0:1]
endif
\endimpl
 * \see v2f_get_high_v4f(v4f a)
 * \see v2f_get_low_v4f(v4f a)
 * \param a \c v4f vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v2f v2f_get_hilo_v4f(v4f a, int high);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Conditionnaly gets the low or the high part of a \c v4i vector.
 * \details If \c high is true, gets the high part of the \c v4i input vector.
 *  Else, gets the low part of the \c v4i input vector.
 * \impl
if high
  dst[0:1] := a[2:3]
else
  dst[0:1] := a[0:1]
endif
\endimpl
 * \see v2i_get_high_v4i(v4i a)
 * \see v2i_get_low_v4i(v4i a)
 * \param a \c v4i vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v2i v2i_get_hilo_v4i(v4i a, int high);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Conditionnaly gets the low or the high part of a \c v4l vector.
 * \details If \c high is true, gets the high part of the \c v4l input vector.
 *  Else, gets the low part of the \c v4l input vector.
 * \impl
if high
  dst[0:1] := a[2:3]
else
  dst[0:1] := a[0:1]
endif
\endimpl
 * \see v2l_get_high_v4l(v4l a)
 * \see v2l_get_low_v4l(v4l a)
 * \param a \c v4l vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v2l v2l_get_hilo_v4l(v4l a, int high);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Conditionnaly gets the low or the high part of a \c v8d vector.
 * \details If \c high is true, gets the high part of the \c v8d input vector.
 *  Else, gets the low part of the \c v8d input vector.
 * \impl
if high
  dst[0:3] := a[4:7]
else
  dst[0:3] := a[0:3]
endif
\endimpl
 * \see v4d_get_high_v8d(v8d a)
 * \see v4d_get_low_v8d(v8d a)
 * \param a \c v8d vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v4d v4d_get_hilo_v8d(v8d a, int high);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Conditionnaly gets the low or the high part of a \c v8f vector.
 * \details If \c high is true, gets the high part of the \c v8f input vector.
 *  Else, gets the low part of the \c v8f input vector.
 * \impl
if high
  dst[0:3] := a[4:7]
else
  dst[0:3] := a[0:3]
endif
\endimpl
 * \see v4f_get_high_v8f(v8f a)
 * \see v4f_get_low_v8f(v8f a)
 * \param a \c v8f vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v4f v4f_get_hilo_v8f(v8f a, int high);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Conditionnaly gets the low or the high part of a \c v8i vector.
 * \details If \c high is true, gets the high part of the \c v8i input vector.
 *  Else, gets the low part of the \c v8i input vector.
 * \impl
if high
  dst[0:3] := a[4:7]
else
  dst[0:3] := a[0:3]
endif
\endimpl
 * \see v4i_get_high_v8i(v8i a)
 * \see v4i_get_low_v8i(v8i a)
 * \param a \c v8i vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v4i v4i_get_hilo_v8i(v8i a, int high);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Conditionnaly gets the low or the high part of a \c v8l vector.
 * \details If \c high is true, gets the high part of the \c v8l input vector.
 *  Else, gets the low part of the \c v8l input vector.
 * \impl
if high
  dst[0:3] := a[4:7]
else
  dst[0:3] := a[0:3]
endif
\endimpl
 * \see v4l_get_high_v8l(v8l a)
 * \see v4l_get_low_v8l(v8l a)
 * \param a \c v8l vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v4l v4l_get_hilo_v8l(v8l a, int high);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Conditionnaly gets the low or the high part of a \c v16f vector.
 * \details If \c high is true, gets the high part of the \c v16f input vector.
 *  Else, gets the low part of the \c v16f input vector.
 * \impl
if high
  dst[0:7] := a[8:15]
else
  dst[0:7] := a[0:7]
endif
\endimpl
 * \see v8f_get_high_v16f(v16f a)
 * \see v8f_get_low_v16f(v16f a)
 * \param a \c v16f vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v8f v8f_get_hilo_v16f(v16f a, int high);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Conditionnaly gets the low or the high part of a \c v16i vector.
 * \details If \c high is true, gets the high part of the \c v16i input vector.
 *  Else, gets the low part of the \c v16i input vector.
 * \impl
if high
  dst[0:7] := a[8:15]
else
  dst[0:7] := a[0:7]
endif
\endimpl
 * \see v8i_get_high_v16i(v16i a)
 * \see v8i_get_low_v16i(v16i a)
 * \param a \c v16i vector within the low/high part is extracted
 * \param high boolean to choose the high part
 * \returns low/high part of the input
 */
v8i v8i_get_hilo_v16i(v16i a, int high);
/**
 * \ingroup hilo
 * \related v2d
 * \brief Sets the low part of a \c v2d vector.
 * \details Creates a \c v2d vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0] := a[0]
dst[1] := src[1]
\endimpl
 * \see v2d_set_high_v1d(v2d src, v1d high)
 * \param src \c v2d vector within the low part is inserted
 * \param low \c v1d vector inserted as low part
 * \returns \c v2d vector with the low part set to \c low
 */
v2d v2d_set_low_v1d(v2d src, v1d low);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Sets the low part of a \c v2f vector.
 * \details Creates a \c v2f vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0] := a[0]
dst[1] := src[1]
\endimpl
 * \see v2f_set_high_v1f(v2f src, v1f high)
 * \param src \c v2f vector within the low part is inserted
 * \param low \c v1f vector inserted as low part
 * \returns \c v2f vector with the low part set to \c low
 */
v2f v2f_set_low_v1f(v2f src, v1f low);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Sets the low part of a \c v2i vector.
 * \details Creates a \c v2i vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0] := a[0]
dst[1] := src[1]
\endimpl
 * \see v2i_set_high_v1i(v2i src, v1i high)
 * \param src \c v2i vector within the low part is inserted
 * \param low \c v1i vector inserted as low part
 * \returns \c v2i vector with the low part set to \c low
 */
v2i v2i_set_low_v1i(v2i src, v1i low);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Sets the low part of a \c v2l vector.
 * \details Creates a \c v2l vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0] := a[0]
dst[1] := src[1]
\endimpl
 * \see v2l_set_high_v1l(v2l src, v1l high)
 * \param src \c v2l vector within the low part is inserted
 * \param low \c v1l vector inserted as low part
 * \returns \c v2l vector with the low part set to \c low
 */
v2l v2l_set_low_v1l(v2l src, v1l low);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Sets the low part of a \c v4d vector.
 * \details Creates a \c v4d vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:1] := a[0:1]
dst[2:3] := src[2:3]
\endimpl
 * \see v4d_set_high_v2d(v4d src, v2d high)
 * \param src \c v4d vector within the low part is inserted
 * \param low \c v2d vector inserted as low part
 * \returns \c v4d vector with the low part set to \c low
 */
v4d v4d_set_low_v2d(v4d src, v2d low);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Sets the low part of a \c v4f vector.
 * \details Creates a \c v4f vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:1] := a[0:1]
dst[2:3] := src[2:3]
\endimpl
 * \see v4f_set_high_v2f(v4f src, v2f high)
 * \param src \c v4f vector within the low part is inserted
 * \param low \c v2f vector inserted as low part
 * \returns \c v4f vector with the low part set to \c low
 */
v4f v4f_set_low_v2f(v4f src, v2f low);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Sets the low part of a \c v4i vector.
 * \details Creates a \c v4i vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:1] := a[0:1]
dst[2:3] := src[2:3]
\endimpl
 * \see v4i_set_high_v2i(v4i src, v2i high)
 * \param src \c v4i vector within the low part is inserted
 * \param low \c v2i vector inserted as low part
 * \returns \c v4i vector with the low part set to \c low
 */
v4i v4i_set_low_v2i(v4i src, v2i low);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Sets the low part of a \c v4l vector.
 * \details Creates a \c v4l vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:1] := a[0:1]
dst[2:3] := src[2:3]
\endimpl
 * \see v4l_set_high_v2l(v4l src, v2l high)
 * \param src \c v4l vector within the low part is inserted
 * \param low \c v2l vector inserted as low part
 * \returns \c v4l vector with the low part set to \c low
 */
v4l v4l_set_low_v2l(v4l src, v2l low);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Sets the low part of a \c v8d vector.
 * \details Creates a \c v8d vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:3] := a[0:3]
dst[4:7] := src[4:7]
\endimpl
 * \see v8d_set_high_v4d(v8d src, v4d high)
 * \param src \c v8d vector within the low part is inserted
 * \param low \c v4d vector inserted as low part
 * \returns \c v8d vector with the low part set to \c low
 */
v8d v8d_set_low_v4d(v8d src, v4d low);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Sets the low part of a \c v8f vector.
 * \details Creates a \c v8f vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:3] := a[0:3]
dst[4:7] := src[4:7]
\endimpl
 * \see v8f_set_high_v4f(v8f src, v4f high)
 * \param src \c v8f vector within the low part is inserted
 * \param low \c v4f vector inserted as low part
 * \returns \c v8f vector with the low part set to \c low
 */
v8f v8f_set_low_v4f(v8f src, v4f low);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Sets the low part of a \c v8i vector.
 * \details Creates a \c v8i vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:3] := a[0:3]
dst[4:7] := src[4:7]
\endimpl
 * \see v8i_set_high_v4i(v8i src, v4i high)
 * \param src \c v8i vector within the low part is inserted
 * \param low \c v4i vector inserted as low part
 * \returns \c v8i vector with the low part set to \c low
 */
v8i v8i_set_low_v4i(v8i src, v4i low);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Sets the low part of a \c v8l vector.
 * \details Creates a \c v8l vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:3] := a[0:3]
dst[4:7] := src[4:7]
\endimpl
 * \see v8l_set_high_v4l(v8l src, v4l high)
 * \param src \c v8l vector within the low part is inserted
 * \param low \c v4l vector inserted as low part
 * \returns \c v8l vector with the low part set to \c low
 */
v8l v8l_set_low_v4l(v8l src, v4l low);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Sets the low part of a \c v16f vector.
 * \details Creates a \c v16f vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:7] := a[0:7]
dst[8:15] := src[8:15]
\endimpl
 * \see v16f_set_high_v8f(v16f src, v8f high)
 * \param src \c v16f vector within the low part is inserted
 * \param low \c v8f vector inserted as low part
 * \returns \c v16f vector with the low part set to \c low
 */
v16f v16f_set_low_v8f(v16f src, v8f low);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Sets the low part of a \c v16i vector.
 * \details Creates a \c v16i vector with the low part being \c low and the high part being the same as the high part or \c src
 * \impl
dst[0:7] := a[0:7]
dst[8:15] := src[8:15]
\endimpl
 * \see v16i_set_high_v8i(v16i src, v8i high)
 * \param src \c v16i vector within the low part is inserted
 * \param low \c v8i vector inserted as low part
 * \returns \c v16i vector with the low part set to \c low
 */
v16i v16i_set_low_v8i(v16i src, v8i low);
/**
 * \ingroup hilo
 * \related v2d
 * \brief Sets the high part of a \c v2d vector.
 * \details Creates a \c v2d vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0] := src[0]
dst[1] := a[0]
\endimpl
 * \see v2d_set_low_v1d(v2d src, v1d low)
 * \param src \c v2d vector within the high part is inserted
 * \param high \c v1d vector inserted as high part
 * \returns \c v2d vector with the high part set to \c high
 */
v2d v2d_set_high_v1d(v2d src, v1d high);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Sets the high part of a \c v2f vector.
 * \details Creates a \c v2f vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0] := src[0]
dst[1] := a[0]
\endimpl
 * \see v2f_set_low_v1f(v2f src, v1f low)
 * \param src \c v2f vector within the high part is inserted
 * \param high \c v1f vector inserted as high part
 * \returns \c v2f vector with the high part set to \c high
 */
v2f v2f_set_high_v1f(v2f src, v1f high);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Sets the high part of a \c v2i vector.
 * \details Creates a \c v2i vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0] := src[0]
dst[1] := a[0]
\endimpl
 * \see v2i_set_low_v1i(v2i src, v1i low)
 * \param src \c v2i vector within the high part is inserted
 * \param high \c v1i vector inserted as high part
 * \returns \c v2i vector with the high part set to \c high
 */
v2i v2i_set_high_v1i(v2i src, v1i high);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Sets the high part of a \c v2l vector.
 * \details Creates a \c v2l vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0] := src[0]
dst[1] := a[0]
\endimpl
 * \see v2l_set_low_v1l(v2l src, v1l low)
 * \param src \c v2l vector within the high part is inserted
 * \param high \c v1l vector inserted as high part
 * \returns \c v2l vector with the high part set to \c high
 */
v2l v2l_set_high_v1l(v2l src, v1l high);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Sets the high part of a \c v4d vector.
 * \details Creates a \c v4d vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:1] := src[0:1]
dst[2:3] := a[0:1]
\endimpl
 * \see v4d_set_low_v2d(v4d src, v2d low)
 * \param src \c v4d vector within the high part is inserted
 * \param high \c v2d vector inserted as high part
 * \returns \c v4d vector with the high part set to \c high
 */
v4d v4d_set_high_v2d(v4d src, v2d high);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Sets the high part of a \c v4f vector.
 * \details Creates a \c v4f vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:1] := src[0:1]
dst[2:3] := a[0:1]
\endimpl
 * \see v4f_set_low_v2f(v4f src, v2f low)
 * \param src \c v4f vector within the high part is inserted
 * \param high \c v2f vector inserted as high part
 * \returns \c v4f vector with the high part set to \c high
 */
v4f v4f_set_high_v2f(v4f src, v2f high);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Sets the high part of a \c v4i vector.
 * \details Creates a \c v4i vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:1] := src[0:1]
dst[2:3] := a[0:1]
\endimpl
 * \see v4i_set_low_v2i(v4i src, v2i low)
 * \param src \c v4i vector within the high part is inserted
 * \param high \c v2i vector inserted as high part
 * \returns \c v4i vector with the high part set to \c high
 */
v4i v4i_set_high_v2i(v4i src, v2i high);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Sets the high part of a \c v4l vector.
 * \details Creates a \c v4l vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:1] := src[0:1]
dst[2:3] := a[0:1]
\endimpl
 * \see v4l_set_low_v2l(v4l src, v2l low)
 * \param src \c v4l vector within the high part is inserted
 * \param high \c v2l vector inserted as high part
 * \returns \c v4l vector with the high part set to \c high
 */
v4l v4l_set_high_v2l(v4l src, v2l high);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Sets the high part of a \c v8d vector.
 * \details Creates a \c v8d vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:3] := src[0:3]
dst[4:7] := a[0:3]
\endimpl
 * \see v8d_set_low_v4d(v8d src, v4d low)
 * \param src \c v8d vector within the high part is inserted
 * \param high \c v4d vector inserted as high part
 * \returns \c v8d vector with the high part set to \c high
 */
v8d v8d_set_high_v4d(v8d src, v4d high);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Sets the high part of a \c v8f vector.
 * \details Creates a \c v8f vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:3] := src[0:3]
dst[4:7] := a[0:3]
\endimpl
 * \see v8f_set_low_v4f(v8f src, v4f low)
 * \param src \c v8f vector within the high part is inserted
 * \param high \c v4f vector inserted as high part
 * \returns \c v8f vector with the high part set to \c high
 */
v8f v8f_set_high_v4f(v8f src, v4f high);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Sets the high part of a \c v8i vector.
 * \details Creates a \c v8i vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:3] := src[0:3]
dst[4:7] := a[0:3]
\endimpl
 * \see v8i_set_low_v4i(v8i src, v4i low)
 * \param src \c v8i vector within the high part is inserted
 * \param high \c v4i vector inserted as high part
 * \returns \c v8i vector with the high part set to \c high
 */
v8i v8i_set_high_v4i(v8i src, v4i high);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Sets the high part of a \c v8l vector.
 * \details Creates a \c v8l vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:3] := src[0:3]
dst[4:7] := a[0:3]
\endimpl
 * \see v8l_set_low_v4l(v8l src, v4l low)
 * \param src \c v8l vector within the high part is inserted
 * \param high \c v4l vector inserted as high part
 * \returns \c v8l vector with the high part set to \c high
 */
v8l v8l_set_high_v4l(v8l src, v4l high);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Sets the high part of a \c v16f vector.
 * \details Creates a \c v16f vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:7] := src[0:7]
dst[8:15] := a[0:7]
\endimpl
 * \see v16f_set_low_v8f(v16f src, v8f low)
 * \param src \c v16f vector within the high part is inserted
 * \param high \c v8f vector inserted as high part
 * \returns \c v16f vector with the high part set to \c high
 */
v16f v16f_set_high_v8f(v16f src, v8f high);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Sets the high part of a \c v16i vector.
 * \details Creates a \c v16i vector with the high part being \c high and the low part being the same as the low part or \c src
 * \impl
dst[0:7] := src[0:7]
dst[8:15] := a[0:7]
\endimpl
 * \see v16i_set_low_v8i(v16i src, v8i low)
 * \param src \c v16i vector within the high part is inserted
 * \param high \c v8i vector inserted as high part
 * \returns \c v16i vector with the high part set to \c high
 */
v16i v16i_set_high_v8i(v16i src, v8i high);
/**
 * \ingroup hilo
 * \related v2d
 * \brief Conditionally sets the low or the high part of a \c v2d vector.
 * \details If \c high is true, sets the high part of the \c v2d input vector.
 *  Else, sets the low part of the \c v2d input vector.
 * \impl
if high
  dst[0] := src[0]
  dst[1] := a[0]
else
  dst[0] := a[0]
  dst[1] := src[1]
endif
\endimpl
 * \see v2d_set_low_v1d(v2d src, v1d low)
 * \see v2d_set_high_v1d(v2d src, v1d high)
 * \param src \c v2d vector within the low/high part is inserted
 * \param a \c v1d vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v2d vector with low/high part set to \c a
 */
v2d v2d_set_hilo_v1d(v2d src, v1d a, int high);
/**
 * \ingroup hilo
 * \related v2f
 * \brief Conditionally sets the low or the high part of a \c v2f vector.
 * \details If \c high is true, sets the high part of the \c v2f input vector.
 *  Else, sets the low part of the \c v2f input vector.
 * \impl
if high
  dst[0] := src[0]
  dst[1] := a[0]
else
  dst[0] := a[0]
  dst[1] := src[1]
endif
\endimpl
 * \see v2f_set_low_v1f(v2f src, v1f low)
 * \see v2f_set_high_v1f(v2f src, v1f high)
 * \param src \c v2f vector within the low/high part is inserted
 * \param a \c v1f vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v2f vector with low/high part set to \c a
 */
v2f v2f_set_hilo_v1f(v2f src, v1f a, int high);
/**
 * \ingroup hilo
 * \related v2i
 * \brief Conditionally sets the low or the high part of a \c v2i vector.
 * \details If \c high is true, sets the high part of the \c v2i input vector.
 *  Else, sets the low part of the \c v2i input vector.
 * \impl
if high
  dst[0] := src[0]
  dst[1] := a[0]
else
  dst[0] := a[0]
  dst[1] := src[1]
endif
\endimpl
 * \see v2i_set_low_v1i(v2i src, v1i low)
 * \see v2i_set_high_v1i(v2i src, v1i high)
 * \param src \c v2i vector within the low/high part is inserted
 * \param a \c v1i vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v2i vector with low/high part set to \c a
 */
v2i v2i_set_hilo_v1i(v2i src, v1i a, int high);
/**
 * \ingroup hilo
 * \related v2l
 * \brief Conditionally sets the low or the high part of a \c v2l vector.
 * \details If \c high is true, sets the high part of the \c v2l input vector.
 *  Else, sets the low part of the \c v2l input vector.
 * \impl
if high
  dst[0] := src[0]
  dst[1] := a[0]
else
  dst[0] := a[0]
  dst[1] := src[1]
endif
\endimpl
 * \see v2l_set_low_v1l(v2l src, v1l low)
 * \see v2l_set_high_v1l(v2l src, v1l high)
 * \param src \c v2l vector within the low/high part is inserted
 * \param a \c v1l vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v2l vector with low/high part set to \c a
 */
v2l v2l_set_hilo_v1l(v2l src, v1l a, int high);
/**
 * \ingroup hilo
 * \related v4d
 * \brief Conditionally sets the low or the high part of a \c v4d vector.
 * \details If \c high is true, sets the high part of the \c v4d input vector.
 *  Else, sets the low part of the \c v4d input vector.
 * \impl
if high
  dst[0:1] := src[0:1]
  dst[2:3] := a[0:1]
else
  dst[0:1] := a[0:1]
  dst[2:3] := src[2:3]
endif
\endimpl
 * \see v4d_set_low_v2d(v4d src, v2d low)
 * \see v4d_set_high_v2d(v4d src, v2d high)
 * \param src \c v4d vector within the low/high part is inserted
 * \param a \c v2d vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v4d vector with low/high part set to \c a
 */
v4d v4d_set_hilo_v2d(v4d src, v2d a, int high);
/**
 * \ingroup hilo
 * \related v4f
 * \brief Conditionally sets the low or the high part of a \c v4f vector.
 * \details If \c high is true, sets the high part of the \c v4f input vector.
 *  Else, sets the low part of the \c v4f input vector.
 * \impl
if high
  dst[0:1] := src[0:1]
  dst[2:3] := a[0:1]
else
  dst[0:1] := a[0:1]
  dst[2:3] := src[2:3]
endif
\endimpl
 * \see v4f_set_low_v2f(v4f src, v2f low)
 * \see v4f_set_high_v2f(v4f src, v2f high)
 * \param src \c v4f vector within the low/high part is inserted
 * \param a \c v2f vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v4f vector with low/high part set to \c a
 */
v4f v4f_set_hilo_v2f(v4f src, v2f a, int high);
/**
 * \ingroup hilo
 * \related v4i
 * \brief Conditionally sets the low or the high part of a \c v4i vector.
 * \details If \c high is true, sets the high part of the \c v4i input vector.
 *  Else, sets the low part of the \c v4i input vector.
 * \impl
if high
  dst[0:1] := src[0:1]
  dst[2:3] := a[0:1]
else
  dst[0:1] := a[0:1]
  dst[2:3] := src[2:3]
endif
\endimpl
 * \see v4i_set_low_v2i(v4i src, v2i low)
 * \see v4i_set_high_v2i(v4i src, v2i high)
 * \param src \c v4i vector within the low/high part is inserted
 * \param a \c v2i vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v4i vector with low/high part set to \c a
 */
v4i v4i_set_hilo_v2i(v4i src, v2i a, int high);
/**
 * \ingroup hilo
 * \related v4l
 * \brief Conditionally sets the low or the high part of a \c v4l vector.
 * \details If \c high is true, sets the high part of the \c v4l input vector.
 *  Else, sets the low part of the \c v4l input vector.
 * \impl
if high
  dst[0:1] := src[0:1]
  dst[2:3] := a[0:1]
else
  dst[0:1] := a[0:1]
  dst[2:3] := src[2:3]
endif
\endimpl
 * \see v4l_set_low_v2l(v4l src, v2l low)
 * \see v4l_set_high_v2l(v4l src, v2l high)
 * \param src \c v4l vector within the low/high part is inserted
 * \param a \c v2l vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v4l vector with low/high part set to \c a
 */
v4l v4l_set_hilo_v2l(v4l src, v2l a, int high);
/**
 * \ingroup hilo
 * \related v8d
 * \brief Conditionally sets the low or the high part of a \c v8d vector.
 * \details If \c high is true, sets the high part of the \c v8d input vector.
 *  Else, sets the low part of the \c v8d input vector.
 * \impl
if high
  dst[0:3] := src[0:3]
  dst[4:7] := a[0:3]
else
  dst[0:3] := a[0:3]
  dst[4:7] := src[4:7]
endif
\endimpl
 * \see v8d_set_low_v4d(v8d src, v4d low)
 * \see v8d_set_high_v4d(v8d src, v4d high)
 * \param src \c v8d vector within the low/high part is inserted
 * \param a \c v4d vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v8d vector with low/high part set to \c a
 */
v8d v8d_set_hilo_v4d(v8d src, v4d a, int high);
/**
 * \ingroup hilo
 * \related v8f
 * \brief Conditionally sets the low or the high part of a \c v8f vector.
 * \details If \c high is true, sets the high part of the \c v8f input vector.
 *  Else, sets the low part of the \c v8f input vector.
 * \impl
if high
  dst[0:3] := src[0:3]
  dst[4:7] := a[0:3]
else
  dst[0:3] := a[0:3]
  dst[4:7] := src[4:7]
endif
\endimpl
 * \see v8f_set_low_v4f(v8f src, v4f low)
 * \see v8f_set_high_v4f(v8f src, v4f high)
 * \param src \c v8f vector within the low/high part is inserted
 * \param a \c v4f vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v8f vector with low/high part set to \c a
 */
v8f v8f_set_hilo_v4f(v8f src, v4f a, int high);
/**
 * \ingroup hilo
 * \related v8i
 * \brief Conditionally sets the low or the high part of a \c v8i vector.
 * \details If \c high is true, sets the high part of the \c v8i input vector.
 *  Else, sets the low part of the \c v8i input vector.
 * \impl
if high
  dst[0:3] := src[0:3]
  dst[4:7] := a[0:3]
else
  dst[0:3] := a[0:3]
  dst[4:7] := src[4:7]
endif
\endimpl
 * \see v8i_set_low_v4i(v8i src, v4i low)
 * \see v8i_set_high_v4i(v8i src, v4i high)
 * \param src \c v8i vector within the low/high part is inserted
 * \param a \c v4i vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v8i vector with low/high part set to \c a
 */
v8i v8i_set_hilo_v4i(v8i src, v4i a, int high);
/**
 * \ingroup hilo
 * \related v8l
 * \brief Conditionally sets the low or the high part of a \c v8l vector.
 * \details If \c high is true, sets the high part of the \c v8l input vector.
 *  Else, sets the low part of the \c v8l input vector.
 * \impl
if high
  dst[0:3] := src[0:3]
  dst[4:7] := a[0:3]
else
  dst[0:3] := a[0:3]
  dst[4:7] := src[4:7]
endif
\endimpl
 * \see v8l_set_low_v4l(v8l src, v4l low)
 * \see v8l_set_high_v4l(v8l src, v4l high)
 * \param src \c v8l vector within the low/high part is inserted
 * \param a \c v4l vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v8l vector with low/high part set to \c a
 */
v8l v8l_set_hilo_v4l(v8l src, v4l a, int high);
/**
 * \ingroup hilo
 * \related v16f
 * \brief Conditionally sets the low or the high part of a \c v16f vector.
 * \details If \c high is true, sets the high part of the \c v16f input vector.
 *  Else, sets the low part of the \c v16f input vector.
 * \impl
if high
  dst[0:7] := src[0:7]
  dst[8:15] := a[0:7]
else
  dst[0:7] := a[0:7]
  dst[8:15] := src[8:15]
endif
\endimpl
 * \see v16f_set_low_v8f(v16f src, v8f low)
 * \see v16f_set_high_v8f(v16f src, v8f high)
 * \param src \c v16f vector within the low/high part is inserted
 * \param a \c v8f vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v16f vector with low/high part set to \c a
 */
v16f v16f_set_hilo_v8f(v16f src, v8f a, int high);
/**
 * \ingroup hilo
 * \related v16i
 * \brief Conditionally sets the low or the high part of a \c v16i vector.
 * \details If \c high is true, sets the high part of the \c v16i input vector.
 *  Else, sets the low part of the \c v16i input vector.
 * \impl
if high
  dst[0:7] := src[0:7]
  dst[8:15] := a[0:7]
else
  dst[0:7] := a[0:7]
  dst[8:15] := src[8:15]
endif
\endimpl
 * \see v16i_set_low_v8i(v16i src, v8i low)
 * \see v16i_set_high_v8i(v16i src, v8i high)
 * \param src \c v16i vector within the low/high part is inserted
 * \param a \c v8i vector inserted as low/high part
 * \param high boolean to choose the high part
 * \returns \c v16i vector with low/high part set to \c a
 */
v16i v16i_set_hilo_v8i(v16i src, v8i a, int high);

/* BLENDS */
/** \defgroup blend blend functions
 * 
 */

/**
 * \ingroup blend
 * \related v1d
 * \brief Creates a new \c v1d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1d vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1d v1d_blend1(v1d a, v1d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1f
 * \brief Creates a new \c v1f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1f vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1f v1f_blend1(v1f a, v1f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1i
 * \brief Creates a new \c v1i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1i vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1i v1i_blend1(v1i a, v1i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1l
 * \brief Creates a new \c v1l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1l vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1l v1l_blend1(v1l a, v1l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2d
 * \brief Creates a new \c v2d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2d vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2d v2d_blend1(v2d a, v2d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2f
 * \brief Creates a new \c v2f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2f vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2f v2f_blend1(v2f a, v2f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2i
 * \brief Creates a new \c v2i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2i vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2i v2i_blend1(v2i a, v2i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2l
 * \brief Creates a new \c v2l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2l vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2l v2l_blend1(v2l a, v2l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend1(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend1(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend1(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend1(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend1(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend1(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend1(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend1(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith block of 16 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 16
  if mask.bits[j]
    dst[i:i+15] = b[i:i+15]
  else
    dst[i:i+15] = a[i:i+15]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend1(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith block of 16 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 0
  i = j * 16
  if mask.bits[j]
    dst[i:i+15] = b[i:i+15]
  else
    dst[i:i+15] = a[i:i+15]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend1(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2d
 * \brief Creates a new \c v2d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2d vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2d v2d_blend2(v2d a, v2d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2f
 * \brief Creates a new \c v2f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2f vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2f v2f_blend2(v2f a, v2f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2i
 * \brief Creates a new \c v2i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2i vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2i v2i_blend2(v2i a, v2i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2l
 * \brief Creates a new \c v2l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2l vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2l v2l_blend2(v2l a, v2l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend2(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend2(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend2(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend2(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend2(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend2(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend2(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend2(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend2(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith block of 8 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 1
  i = j * 8
  if mask.bits[j]
    dst[i:i+7] = b[i:i+7]
  else
    dst[i:i+7] = a[i:i+7]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend2(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend4(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend4(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend4(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend4(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend4(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend4(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend4(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend4(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend4(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith block of 4 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 3
  i = j * 4
  if mask.bits[j]
    dst[i:i+3] = b[i:i+3]
  else
    dst[i:i+3] = a[i:i+3]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend4(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend8(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend8(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend8(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend8(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend8(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith block of 2 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 7
  i = j * 2
  if mask.bits[j]
    dst[i:i+1] = b[i:i+1]
  else
    dst[i:i+1] = a[i:i+1]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend8(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 15
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend16(v16f a, v16f b, uint_fast16_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith block of 1 elements is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 * \impl
for j from 0 to 15
  i = j * 1
  if mask.bits[j]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend16(v16i a, v16i b, uint_fast16_t mask);

/**
 * \ingroup blend
 * \related v1d
 * \brief Creates a new \c v1d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1d vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1d v1d_blend1x1(v1d a, v1d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1f
 * \brief Creates a new \c v1f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1f vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1f v1f_blend1x1(v1f a, v1f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1i
 * \brief Creates a new \c v1i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1i vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1i v1i_blend1x1(v1i a, v1i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1l
 * \brief Creates a new \c v1l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1l vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1l v1l_blend1x1(v1l a, v1l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2d
 * \brief Creates a new \c v2d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2d vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2d v2d_blend1x2(v2d a, v2d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2f
 * \brief Creates a new \c v2f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2f vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2f v2f_blend1x2(v2f a, v2f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2i
 * \brief Creates a new \c v2i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2i vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2i v2i_blend1x2(v2i a, v2i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2l
 * \brief Creates a new \c v2l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2l vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2l v2l_blend1x2(v2l a, v2l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend1x4(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend1x4(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend1x4(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend1x4(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend1x8(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend1x8(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend1x8(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend1x8(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 15
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend1x16(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the \c `(i % 1)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND1(_a, _b, _m) {
  for i from 0 to 0
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 15
  i = j * 1
  dst[i] = BLEND1(a[i], b[i], mask)
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend1x16(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2d
 * \brief Creates a new \c v2d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2d vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2d v2d_blend2x1(v2d a, v2d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2f
 * \brief Creates a new \c v2f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2f vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2f v2f_blend2x1(v2f a, v2f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2i
 * \brief Creates a new \c v2i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2i vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2i v2i_blend2x1(v2i a, v2i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2l
 * \brief Creates a new \c v2l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2l vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2l v2l_blend2x1(v2l a, v2l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend2x2(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend2x2(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend2x2(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend2x2(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend2x4(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend2x4(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend2x4(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend2x4(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend2x8(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the \c `(i % 2)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND2(_a, _b, _m) {
  for i from 0 to 1
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 7
  i = j * 2
  dst[i:i+1] = BLEND2(a[i:i+1], b[i:i+1], mask)
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend2x8(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend4x1(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend4x1(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend4x1(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend4x1(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend4x2(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend4x2(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend4x2(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend4x2(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend4x4(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the \c `(i % 4)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND4(_a, _b, _m) {
  for i from 0 to 3
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 3
  i = j * 4
  dst[i:i+3] = BLEND4(a[i:i+3], b[i:i+3], mask)
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend4x4(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend8x1(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend8x1(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend8x1(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend8x1(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend8x2(v16f a, v16f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the \c `(i % 8)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND8(_a, _b, _m) {
  for i from 0 to 7
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 1
  i = j * 8
  dst[i:i+7] = BLEND8(a[i:i+7], b[i:i+7], mask)
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend8x2(v16i a, v16i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the \c `(i % 16)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND16(_a, _b, _m) {
  for i from 0 to 15
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 16
  dst[i:i+15] = BLEND16(a[i:i+15], b[i:i+15], mask)
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend16x1(v16f a, v16f b, uint_fast16_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the \c `(i % 16)`th bit of \c mask is 1 and from \c a otherwise.
 * \impl
function BLEND16(_a, _b, _m) {
  for i from 0 to 15
    if _m.bits[i]
      _tmp[i] = _b[i]
    else
      _tmp[i] = _a[i]
    endif
  endfor
  return _tmp
}

for j from 0 to 0
  i = j * 16
  dst[i:i+15] = BLEND16(a[i:i+15], b[i:i+15], mask)
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend16x1(v16i a, v16i b, uint_fast16_t mask);

/**
 * \ingroup blend
 * \related v1d
 * \brief Creates a new \c v1d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1d vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v1d_blend1(v1d a, v1d b, uint_fast8_t mask)
 * \impl
for i from 0 to 0
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1d v1d_blend(v1d a, v1d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1f
 * \brief Creates a new \c v1f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1f vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v1f_blend1(v1f a, v1f b, uint_fast8_t mask)
 * \impl
for i from 0 to 0
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1f v1f_blend(v1f a, v1f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1i
 * \brief Creates a new \c v1i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1i vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v1i_blend1(v1i a, v1i b, uint_fast8_t mask)
 * \impl
for i from 0 to 0
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1i v1i_blend(v1i a, v1i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v1l
 * \brief Creates a new \c v1l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v1l vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v1l_blend1(v1l a, v1l b, uint_fast8_t mask)
 * \impl
for i from 0 to 0
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v1l v1l_blend(v1l a, v1l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2d
 * \brief Creates a new \c v2d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2d vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v2d_blend2(v2d a, v2d b, uint_fast8_t mask)
 * \impl
for i from 0 to 1
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2d v2d_blend(v2d a, v2d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2f
 * \brief Creates a new \c v2f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2f vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v2f_blend2(v2f a, v2f b, uint_fast8_t mask)
 * \impl
for i from 0 to 1
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2f v2f_blend(v2f a, v2f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2i
 * \brief Creates a new \c v2i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2i vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v2i_blend2(v2i a, v2i b, uint_fast8_t mask)
 * \impl
for i from 0 to 1
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2i v2i_blend(v2i a, v2i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v2l
 * \brief Creates a new \c v2l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v2l vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v2l_blend2(v2l a, v2l b, uint_fast8_t mask)
 * \impl
for i from 0 to 1
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v2l v2l_blend(v2l a, v2l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4d
 * \brief Creates a new \c v4d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4d vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v4d_blend4(v4d a, v4d b, uint_fast8_t mask)
 * \impl
for i from 0 to 3
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4d v4d_blend(v4d a, v4d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4f
 * \brief Creates a new \c v4f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4f vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v4f_blend4(v4f a, v4f b, uint_fast8_t mask)
 * \impl
for i from 0 to 3
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4f v4f_blend(v4f a, v4f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4i
 * \brief Creates a new \c v4i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4i vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v4i_blend4(v4i a, v4i b, uint_fast8_t mask)
 * \impl
for i from 0 to 3
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4i v4i_blend(v4i a, v4i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v4l
 * \brief Creates a new \c v4l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v4l vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v4l_blend4(v4l a, v4l b, uint_fast8_t mask)
 * \impl
for i from 0 to 3
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v4l v4l_blend(v4l a, v4l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8d
 * \brief Creates a new \c v8d vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8d vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v8d_blend8(v8d a, v8d b, uint_fast8_t mask)
 * \impl
for i from 0 to 7
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8d v8d_blend(v8d a, v8d b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8f
 * \brief Creates a new \c v8f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8f vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v8f_blend8(v8f a, v8f b, uint_fast8_t mask)
 * \impl
for i from 0 to 7
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8f v8f_blend(v8f a, v8f b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8i
 * \brief Creates a new \c v8i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8i vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v8i_blend8(v8i a, v8i b, uint_fast8_t mask)
 * \impl
for i from 0 to 7
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8i v8i_blend(v8i a, v8i b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v8l
 * \brief Creates a new \c v8l vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v8l vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v8l_blend8(v8l a, v8l b, uint_fast8_t mask)
 * \impl
for i from 0 to 7
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v8l v8l_blend(v8l a, v8l b, uint_fast8_t mask);
/**
 * \ingroup blend
 * \related v16f
 * \brief Creates a new \c v16f vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16f vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v16f_blend16(v16f a, v16f b, uint_fast16_t mask)
 * \impl
for i from 0 to 15
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16f v16f_blend(v16f a, v16f b, uint_fast16_t mask);
/**
 * \ingroup blend
 * \related v16i
 * \brief Creates a new \c v16i vector whose elements are from \c a and \c b choosed by \c mask.
 * \details Creates a new \c v16i vector where the ith element is from \c b if the ith bit of \c mask is 1 and from \c a otherwise.
 *  Alias of v16i_blend16(v16i a, v16i b, uint_fast16_t mask)
 * \impl
for i from 0 to 15
  if mask.bits[i]
    dst[i] = b[i]
  else
    dst[i] = a[i]
  endif
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param mask integer mask choosing the input for each element. Must be an immediate!
 * \returns blended vector
 */
v16i v16i_blend(v16i a, v16i b, uint_fast16_t mask);

/* SHUFFLES */
/** \defgroup shuffle shuffling and permutation functions
 * 
 */

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_hshuffle2(v2d a, v2d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_hshuffle2(v2f a, v2f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_hshuffle2(v2i a, v2i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_hshuffle2(v2l a, v2l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_hshuffle2(v4d a, v4d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_hshuffle2(v4f a, v4f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_hshuffle2(v4i a, v4i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_hshuffle2(v4l a, v4l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle2(v8d a, v8d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle2(v8f a, v8f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle2(v8i a, v8i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle2(v8l a, v8l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 8 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2(a, rule[0])
dst[8:15] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle2(v16f a, v16f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 8 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2(a, rule[0])
dst[8:15] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle2(v16i a, v16i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_hshuffle4(v4d a, v4d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_hshuffle4(v4f a, v4f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_hshuffle4(v4i a, v4i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_hshuffle4(v4l a, v4l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(b, rule[4:5])
dst[6:7] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle4(v8d a, v8d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(b, rule[4:5])
dst[6:7] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle4(v8f a, v8f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(b, rule[4:5])
dst[6:7] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle4(v8i a, v8i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(b, rule[4:5])
dst[6:7] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle4(v8l a, v8l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4(a, rule[0:1])
dst[4:7] := SELECT4(a, rule[2:3])
dst[8:11] := SELECT4(b, rule[4:5])
dst[12:15] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle4(v16f a, v16f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4(a, rule[0:1])
dst[4:7] := SELECT4(a, rule[2:3])
dst[8:11] := SELECT4(b, rule[4:5])
dst[12:15] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle4(v16i a, v16i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle8(v8d a, v8d b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle8(v8f a, v8f b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle8(v8i a, v8i b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle8(v8l a, v8l b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 2 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8(a, rule[0:2])
dst[2:3] := SELECT8(a, rule[3:5])
dst[4:5] := SELECT8(a, rule[6:8])
dst[6:7] := SELECT8(a, rule[9:11])
dst[8:9] := SELECT8(b, rule[12:14])
dst[10:11] := SELECT8(b, rule[15:17])
dst[12:13] := SELECT8(b, rule[18:20])
dst[14:15] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle8(v16f a, v16f b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 2 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8(a, rule[0:2])
dst[2:3] := SELECT8(a, rule[3:5])
dst[4:5] := SELECT8(a, rule[6:8])
dst[6:7] := SELECT8(a, rule[9:11])
dst[8:9] := SELECT8(b, rule[12:14])
dst[10:11] := SELECT8(b, rule[15:17])
dst[12:13] := SELECT8(b, rule[18:20])
dst[14:15] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle8(v16i a, v16i b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 16 blocks of 1 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(b, rule[32:35])
dst[9] := SELECT16(b, rule[36:39])
dst[10] := SELECT16(b, rule[40:43])
dst[11] := SELECT16(b, rule[44:47])
dst[12] := SELECT16(b, rule[48:51])
dst[13] := SELECT16(b, rule[52:55])
dst[14] := SELECT16(b, rule[56:59])
dst[15] := SELECT16(b, rule[60:63])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle16(v16f a, v16f b, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 16 blocks of 1 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(b, rule[32:35])
dst[9] := SELECT16(b, rule[36:39])
dst[10] := SELECT16(b, rule[40:43])
dst[11] := SELECT16(b, rule[44:47])
dst[12] := SELECT16(b, rule[48:51])
dst[13] := SELECT16(b, rule[52:55])
dst[14] := SELECT16(b, rule[56:59])
dst[15] := SELECT16(b, rule[60:63])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle16(v16i a, v16i b, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_hshuffle2x1(v2d a, v2d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_hshuffle2x1(v2f a, v2f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_hshuffle2x1(v2i a, v2i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_hshuffle2x1(v2l a, v2l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_hshuffle2x2(v4d a, v4d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_hshuffle2x2(v4f a, v4f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_hshuffle2x2(v4i a, v4i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_hshuffle2x2(v4l a, v4l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle2x4(v8d a, v8d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle2x4(v8f a, v8f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle2x4(v8i a, v8i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle2x4(v8l a, v8l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle2x8(v16f a, v16f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(b[i:i+1], rule[1])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle2x8(v16i a, v16i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_hshuffle4x1(v4d a, v4d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_hshuffle4x1(v4f a, v4f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_hshuffle4x1(v4i a, v4i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_hshuffle4x1(v4l a, v4l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle4x2(v8d a, v8d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle4x2(v8f a, v8f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle4x2(v8i a, v8i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle4x2(v8l a, v8l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle4x4(v16f a, v16f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(b[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(b[i:i+3], rule[6:7])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle4x4(v16i a, v16i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle8x1(v8d a, v8d b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle8x1(v8f a, v8f b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle8x1(v8i a, v8i b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle8x1(v8l a, v8l b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle8x2(v16f a, v16f b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(b[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(b[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(b[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(b[i:i+7], rule[21:23])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle8x2(v16i a, v16i b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16(a[i:i+15], rule[0:3])
  dst[i+1] := SELECT16(a[i:i+15], rule[4:7])
  dst[i+2] := SELECT16(a[i:i+15], rule[8:11])
  dst[i+3] := SELECT16(a[i:i+15], rule[12:15])
  dst[i+4] := SELECT16(a[i:i+15], rule[16:19])
  dst[i+5] := SELECT16(a[i:i+15], rule[20:23])
  dst[i+6] := SELECT16(a[i:i+15], rule[24:27])
  dst[i+7] := SELECT16(a[i:i+15], rule[28:31])
  dst[i+8] := SELECT16(b[i:i+15], rule[32:35])
  dst[i+9] := SELECT16(b[i:i+15], rule[36:39])
  dst[i+10] := SELECT16(b[i:i+15], rule[40:43])
  dst[i+11] := SELECT16(b[i:i+15], rule[44:47])
  dst[i+12] := SELECT16(b[i:i+15], rule[48:51])
  dst[i+13] := SELECT16(b[i:i+15], rule[52:55])
  dst[i+14] := SELECT16(b[i:i+15], rule[56:59])
  dst[i+15] := SELECT16(b[i:i+15], rule[60:63])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle16x1(v16f a, v16f b, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16(a[i:i+15], rule[0:3])
  dst[i+1] := SELECT16(a[i:i+15], rule[4:7])
  dst[i+2] := SELECT16(a[i:i+15], rule[8:11])
  dst[i+3] := SELECT16(a[i:i+15], rule[12:15])
  dst[i+4] := SELECT16(a[i:i+15], rule[16:19])
  dst[i+5] := SELECT16(a[i:i+15], rule[20:23])
  dst[i+6] := SELECT16(a[i:i+15], rule[24:27])
  dst[i+7] := SELECT16(a[i:i+15], rule[28:31])
  dst[i+8] := SELECT16(b[i:i+15], rule[32:35])
  dst[i+9] := SELECT16(b[i:i+15], rule[36:39])
  dst[i+10] := SELECT16(b[i:i+15], rule[40:43])
  dst[i+11] := SELECT16(b[i:i+15], rule[44:47])
  dst[i+12] := SELECT16(b[i:i+15], rule[48:51])
  dst[i+13] := SELECT16(b[i:i+15], rule[52:55])
  dst[i+14] := SELECT16(b[i:i+15], rule[56:59])
  dst[i+15] := SELECT16(b[i:i+15], rule[60:63])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle16x1(v16i a, v16i b, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v2d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v2d_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2d_hshuffle2(v2d a, v2d b, uint_fast8_t rule)
 * \param a \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_permute2(v2d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v2f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v2f_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2f_hshuffle2(v2f a, v2f b, uint_fast8_t rule)
 * \param a \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_permute2(v2f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v2i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v2i_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2i_hshuffle2(v2i a, v2i b, uint_fast8_t rule)
 * \param a \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_permute2(v2i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v2l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v2l_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2l_hshuffle2(v2l a, v2l b, uint_fast8_t rule)
 * \param a \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_permute2(v2l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4d_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(a, rule[1])
\endimpl
 *  \see v4d_hshuffle2(v4d a, v4d b, uint_fast8_t rule)
 * \param a \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_permute2(v4d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4f_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(a, rule[1])
\endimpl
 *  \see v4f_hshuffle2(v4f a, v4f b, uint_fast8_t rule)
 * \param a \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_permute2(v4f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4i_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(a, rule[1])
\endimpl
 *  \see v4i_hshuffle2(v4i a, v4i b, uint_fast8_t rule)
 * \param a \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_permute2(v4i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4l_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2(a, rule[0])
dst[2:3] := SELECT2(a, rule[1])
\endimpl
 *  \see v4l_hshuffle2(v4l a, v4l b, uint_fast8_t rule)
 * \param a \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_permute2(v4l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(a, rule[1])
\endimpl
 *  \see v8d_hshuffle2(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute2(v8d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(a, rule[1])
\endimpl
 *  \see v8f_hshuffle2(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute2(v8f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(a, rule[1])
\endimpl
 *  \see v8i_hshuffle2(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute2(v8i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2(a, rule[0])
dst[4:7] := SELECT2(a, rule[1])
\endimpl
 *  \see v8l_hshuffle2(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute2(v8l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2(a, rule[0])
dst[8:15] := SELECT2(a, rule[1])
\endimpl
 *  \see v16f_hshuffle2(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute2(v16f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2(a, rule[0])
dst[8:15] := SELECT2(a, rule[1])
\endimpl
 *  \see v16i_hshuffle2(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute2(v16i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v4d_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4d_hshuffle4(v4d a, v4d b, uint_fast8_t rule)
 * \param a \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_permute4(v4d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v4f_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4f_hshuffle4(v4f a, v4f b, uint_fast8_t rule)
 * \param a \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_permute4(v4f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v4i_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4i_hshuffle4(v4i a, v4i b, uint_fast8_t rule)
 * \param a \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_permute4(v4i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v4l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v4l_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4l_hshuffle4(v4l a, v4l b, uint_fast8_t rule)
 * \param a \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_permute4(v4l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(a, rule[4:5])
dst[6:7] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v8d_hshuffle4(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute4(v8d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(a, rule[4:5])
dst[6:7] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v8f_hshuffle4(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute4(v8f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(a, rule[4:5])
dst[6:7] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v8i_hshuffle4(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute4(v8i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4(a, rule[0:1])
dst[2:3] := SELECT4(a, rule[2:3])
dst[4:5] := SELECT4(a, rule[4:5])
dst[6:7] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v8l_hshuffle4(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute4(v8l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4(a, rule[0:1])
dst[4:7] := SELECT4(a, rule[2:3])
dst[8:11] := SELECT4(a, rule[4:5])
dst[12:15] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v16f_hshuffle4(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute4(v16f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4(a, rule[0:1])
dst[4:7] := SELECT4(a, rule[2:3])
dst[8:11] := SELECT4(a, rule[4:5])
dst[12:15] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v16i_hshuffle4(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute4(v16i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8d_hshuffle8(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute8(v8d a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8f_hshuffle8(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute8(v8f a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8i_hshuffle8(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute8(v8i a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8l_hshuffle8(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute8(v8l a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8(a, rule[0:2])
dst[2:3] := SELECT8(a, rule[3:5])
dst[4:5] := SELECT8(a, rule[6:8])
dst[6:7] := SELECT8(a, rule[9:11])
dst[8:9] := SELECT8(a, rule[12:14])
dst[10:11] := SELECT8(a, rule[15:17])
dst[12:13] := SELECT8(a, rule[18:20])
dst[14:15] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v16f_hshuffle8(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute8(v16f a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle8(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8(a, rule[0:2])
dst[2:3] := SELECT8(a, rule[3:5])
dst[4:5] := SELECT8(a, rule[6:8])
dst[6:7] := SELECT8(a, rule[9:11])
dst[8:9] := SELECT8(a, rule[12:14])
dst[10:11] := SELECT8(a, rule[15:17])
dst[12:13] := SELECT8(a, rule[18:20])
dst[14:15] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v16i_hshuffle8(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute8(v16i a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle16(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(a, rule[32:35])
dst[9] := SELECT16(a, rule[36:39])
dst[10] := SELECT16(a, rule[40:43])
dst[11] := SELECT16(a, rule[44:47])
dst[12] := SELECT16(a, rule[48:51])
dst[13] := SELECT16(a, rule[52:55])
dst[14] := SELECT16(a, rule[56:59])
dst[15] := SELECT16(a, rule[60:63])
\endimpl
 *  \see v16f_hshuffle16(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute16(v16f a, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (outer) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 blocks of 1 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle16(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(a, rule[32:35])
dst[9] := SELECT16(a, rule[36:39])
dst[10] := SELECT16(a, rule[40:43])
dst[11] := SELECT16(a, rule[44:47])
dst[12] := SELECT16(a, rule[48:51])
dst[13] := SELECT16(a, rule[52:55])
dst[14] := SELECT16(a, rule[56:59])
dst[15] := SELECT16(a, rule[60:63])
\endimpl
 *  \see v16i_hshuffle16(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute16(v16i a, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v2d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v2d_hshuffle2x1(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v2d_hshuffle2x1(v2d a, v2d b, uint_fast8_t rule)
 * \param a \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_permute2x1(v2d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v2f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v2f_hshuffle2x1(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v2f_hshuffle2x1(v2f a, v2f b, uint_fast8_t rule)
 * \param a \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_permute2x1(v2f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v2i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v2i_hshuffle2x1(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v2i_hshuffle2x1(v2i a, v2i b, uint_fast8_t rule)
 * \param a \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_permute2x1(v2i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v2l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v2l_hshuffle2x1(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v2l_hshuffle2x1(v2l a, v2l b, uint_fast8_t rule)
 * \param a \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_permute2x1(v2l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4d_hshuffle2x2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v4d_hshuffle2x2(v4d a, v4d b, uint_fast8_t rule)
 * \param a \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_permute2x2(v4d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4f_hshuffle2x2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v4f_hshuffle2x2(v4f a, v4f b, uint_fast8_t rule)
 * \param a \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_permute2x2(v4f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4i_hshuffle2x2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v4i_hshuffle2x2(v4i a, v4i b, uint_fast8_t rule)
 * \param a \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_permute2x2(v4i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v4l_hshuffle2x2(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v4l_hshuffle2x2(v4l a, v4l b, uint_fast8_t rule)
 * \param a \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_permute2x2(v4l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle2x4(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v8d_hshuffle2x4(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute2x4(v8d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle2x4(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v8f_hshuffle2x4(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute2x4(v8f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle2x4(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v8i_hshuffle2x4(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute2x4(v8i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle2x4(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v8l_hshuffle2x4(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute2x4(v8l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle2x8(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v16f_hshuffle2x8(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute2x8(v16f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle2x8(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2(a[i:i+1], rule[0])
  dst[i+1] := SELECT2(a[i:i+1], rule[1])
endfor
\endimpl
 *  \see v16i_hshuffle2x8(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute2x8(v16i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v4d_hshuffle4x1(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v4d_hshuffle4x1(v4d a, v4d b, uint_fast8_t rule)
 * \param a \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_permute4x1(v4d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v4f_hshuffle4x1(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v4f_hshuffle4x1(v4f a, v4f b, uint_fast8_t rule)
 * \param a \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_permute4x1(v4f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v4i_hshuffle4x1(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v4i_hshuffle4x1(v4i a, v4i b, uint_fast8_t rule)
 * \param a \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_permute4x1(v4i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v4l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v4l_hshuffle4x1(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v4l_hshuffle4x1(v4l a, v4l b, uint_fast8_t rule)
 * \param a \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_permute4x1(v4l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle4x2(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v8d_hshuffle4x2(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute4x2(v8d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle4x2(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v8f_hshuffle4x2(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute4x2(v8f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle4x2(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v8i_hshuffle4x2(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute4x2(v8i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle4x2(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v8l_hshuffle4x2(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute4x2(v8l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle4x4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v16f_hshuffle4x4(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute4x4(v16f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle4x4(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4(a[i:i+3], rule[0:1])
  dst[i+1] := SELECT4(a[i:i+3], rule[2:3])
  dst[i+2] := SELECT4(a[i:i+3], rule[4:5])
  dst[i+3] := SELECT4(a[i:i+3], rule[6:7])
endfor
\endimpl
 *  \see v16i_hshuffle4x4(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute4x4(v16i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v8d_hshuffle8x1(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v8d_hshuffle8x1(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute8x1(v8d a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v8f_hshuffle8x1(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v8f_hshuffle8x1(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute8x1(v8f a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v8i_hshuffle8x1(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v8i_hshuffle8x1(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute8x1(v8i a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v8l_hshuffle8x1(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v8l_hshuffle8x1(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute8x1(v8l a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle8x2(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v16f_hshuffle8x2(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute8x2(v16f a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle8x2(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8(a[i:i+7], rule[0:2])
  dst[i+1] := SELECT8(a[i:i+7], rule[3:5])
  dst[i+2] := SELECT8(a[i:i+7], rule[6:8])
  dst[i+3] := SELECT8(a[i:i+7], rule[9:11])
  dst[i+4] := SELECT8(a[i:i+7], rule[12:14])
  dst[i+5] := SELECT8(a[i:i+7], rule[15:17])
  dst[i+6] := SELECT8(a[i:i+7], rule[18:20])
  dst[i+7] := SELECT8(a[i:i+7], rule[21:23])
endfor
\endimpl
 *  \see v16i_hshuffle8x2(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute8x2(v16i a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 *
 *  Functionally equivalent to \c `v16f_hshuffle16x1(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16(a[i:i+15], rule[0:3])
  dst[i+1] := SELECT16(a[i:i+15], rule[4:7])
  dst[i+2] := SELECT16(a[i:i+15], rule[8:11])
  dst[i+3] := SELECT16(a[i:i+15], rule[12:15])
  dst[i+4] := SELECT16(a[i:i+15], rule[16:19])
  dst[i+5] := SELECT16(a[i:i+15], rule[20:23])
  dst[i+6] := SELECT16(a[i:i+15], rule[24:27])
  dst[i+7] := SELECT16(a[i:i+15], rule[28:31])
  dst[i+8] := SELECT16(a[i:i+15], rule[32:35])
  dst[i+9] := SELECT16(a[i:i+15], rule[36:39])
  dst[i+10] := SELECT16(a[i:i+15], rule[40:43])
  dst[i+11] := SELECT16(a[i:i+15], rule[44:47])
  dst[i+12] := SELECT16(a[i:i+15], rule[48:51])
  dst[i+13] := SELECT16(a[i:i+15], rule[52:55])
  dst[i+14] := SELECT16(a[i:i+15], rule[56:59])
  dst[i+15] := SELECT16(a[i:i+15], rule[60:63])
endfor
\endimpl
 *  \see v16f_hshuffle16x1(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute16x1(v16f a, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles (inner) \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 *
 *  Functionally equivalent to \c `v16i_hshuffle16x1(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16(a[i:i+15], rule[0:3])
  dst[i+1] := SELECT16(a[i:i+15], rule[4:7])
  dst[i+2] := SELECT16(a[i:i+15], rule[8:11])
  dst[i+3] := SELECT16(a[i:i+15], rule[12:15])
  dst[i+4] := SELECT16(a[i:i+15], rule[16:19])
  dst[i+5] := SELECT16(a[i:i+15], rule[20:23])
  dst[i+6] := SELECT16(a[i:i+15], rule[24:27])
  dst[i+7] := SELECT16(a[i:i+15], rule[28:31])
  dst[i+8] := SELECT16(a[i:i+15], rule[32:35])
  dst[i+9] := SELECT16(a[i:i+15], rule[36:39])
  dst[i+10] := SELECT16(a[i:i+15], rule[40:43])
  dst[i+11] := SELECT16(a[i:i+15], rule[44:47])
  dst[i+12] := SELECT16(a[i:i+15], rule[48:51])
  dst[i+13] := SELECT16(a[i:i+15], rule[52:55])
  dst[i+14] := SELECT16(a[i:i+15], rule[56:59])
  dst[i+15] := SELECT16(a[i:i+15], rule[60:63])
endfor
\endimpl
 *  \see v16i_hshuffle16x1(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute16x1(v16i a, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_fshuffle2(v2d a, v2d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_fshuffle2(v2f a, v2f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_fshuffle2(v2i a, v2i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 1 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_fshuffle2(v2l a, v2l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[2:3] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_fshuffle2(v4d a, v4d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[2:3] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_fshuffle2(v4f a, v4f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[2:3] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_fshuffle2(v4i a, v4i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
  endcase
  return _tmp
}

dst[0:1] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[2:3] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_fshuffle2(v4l a, v4l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[4:7] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle2(v8d a, v8d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[4:7] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle2(v8f a, v8f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[4:7] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle2(v8i a, v8i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 4 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
  endcase
  return _tmp
}

dst[0:3] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[4:7] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle2(v8l a, v8l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 8 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[8:15] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle2(v16f a, v16f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 blocks of 8 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0:7]
    0x1:  _tmp := _src[8:15]
  endcase
  return _tmp
}

dst[0:7] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[8:15] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle2(v16i a, v16i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_fshuffle4(v4d a, v4d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_fshuffle4(v4f a, v4f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_fshuffle4(v4i a, v4i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 1 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_fshuffle4(v4l a, v4l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[2:3] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[4:5] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[6:7] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle4(v8d a, v8d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[2:3] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[4:5] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[6:7] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle4(v8f a, v8f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[2:3] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[4:5] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[6:7] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle4(v8i a, v8i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 2 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
  endcase
  return _tmp
}

dst[0:1] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[2:3] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[4:5] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[6:7] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle4(v8l a, v8l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[4:7] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[8:11] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[12:15] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle4(v16f a, v16f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0:3]
    0x1:  _tmp := _src[4:7]
    0x2:  _tmp := _src[8:11]
    0x3:  _tmp := _src[12:15]
  endcase
  return _tmp
}

dst[0:3] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[4:7] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[8:11] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[12:15] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle4(v16i a, v16i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle8(v8d a, v8d b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle8(v8f a, v8f b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle8(v8i a, v8i b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 1 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle8(v8l a, v8l b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 2 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[2:3] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[4:5] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[6:7] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[8:9] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[10:11] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[12:13] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[14:15] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle8(v16f a, v16f b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 blocks of 2 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0:1]
    0x1:  _tmp := _src[2:3]
    0x2:  _tmp := _src[4:5]
    0x3:  _tmp := _src[6:7]
    0x4:  _tmp := _src[8:9]
    0x5:  _tmp := _src[10:11]
    0x6:  _tmp := _src[12:13]
    0x7:  _tmp := _src[14:15]
  endcase
  return _tmp
}

dst[0:1] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[2:3] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[4:5] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[6:7] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[8:9] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[10:11] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[12:13] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[14:15] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle8(v16i a, v16i b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 16 blocks of 1 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16((mask.bits[0] ? b : a), rule[0:3])
dst[1] := SELECT16((mask.bits[1] ? b : a), rule[4:7])
dst[2] := SELECT16((mask.bits[2] ? b : a), rule[8:11])
dst[3] := SELECT16((mask.bits[3] ? b : a), rule[12:15])
dst[4] := SELECT16((mask.bits[4] ? b : a), rule[16:19])
dst[5] := SELECT16((mask.bits[5] ? b : a), rule[20:23])
dst[6] := SELECT16((mask.bits[6] ? b : a), rule[24:27])
dst[7] := SELECT16((mask.bits[7] ? b : a), rule[28:31])
dst[8] := SELECT16((mask.bits[8] ? b : a), rule[32:35])
dst[9] := SELECT16((mask.bits[9] ? b : a), rule[36:39])
dst[10] := SELECT16((mask.bits[10] ? b : a), rule[40:43])
dst[11] := SELECT16((mask.bits[11] ? b : a), rule[44:47])
dst[12] := SELECT16((mask.bits[12] ? b : a), rule[48:51])
dst[13] := SELECT16((mask.bits[13] ? b : a), rule[52:55])
dst[14] := SELECT16((mask.bits[14] ? b : a), rule[56:59])
dst[15] := SELECT16((mask.bits[15] ? b : a), rule[60:63])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle16(v16f a, v16f b, uint_fast64_t rule, uint_fast16_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (outer) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 16 blocks of 1 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16((mask.bits[0] ? b : a), rule[0:3])
dst[1] := SELECT16((mask.bits[1] ? b : a), rule[4:7])
dst[2] := SELECT16((mask.bits[2] ? b : a), rule[8:11])
dst[3] := SELECT16((mask.bits[3] ? b : a), rule[12:15])
dst[4] := SELECT16((mask.bits[4] ? b : a), rule[16:19])
dst[5] := SELECT16((mask.bits[5] ? b : a), rule[20:23])
dst[6] := SELECT16((mask.bits[6] ? b : a), rule[24:27])
dst[7] := SELECT16((mask.bits[7] ? b : a), rule[28:31])
dst[8] := SELECT16((mask.bits[8] ? b : a), rule[32:35])
dst[9] := SELECT16((mask.bits[9] ? b : a), rule[36:39])
dst[10] := SELECT16((mask.bits[10] ? b : a), rule[40:43])
dst[11] := SELECT16((mask.bits[11] ? b : a), rule[44:47])
dst[12] := SELECT16((mask.bits[12] ? b : a), rule[48:51])
dst[13] := SELECT16((mask.bits[13] ? b : a), rule[52:55])
dst[14] := SELECT16((mask.bits[14] ? b : a), rule[56:59])
dst[15] := SELECT16((mask.bits[15] ? b : a), rule[60:63])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle16(v16i a, v16i b, uint_fast64_t rule, uint_fast16_t mask);

/**
 * \ingroup shuffle
 * \related v2d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_fshuffle2x1(v2d a, v2d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_fshuffle2x1(v2f a, v2f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_fshuffle2x1(v2i a, v2i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_fshuffle2x1(v2l a, v2l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_fshuffle2x2(v4d a, v4d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_fshuffle2x2(v4f a, v4f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_fshuffle2x2(v4i a, v4i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 2 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_fshuffle2x2(v4l a, v4l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle2x4(v8d a, v8d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle2x4(v8f a, v8f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle2x4(v8i a, v8i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 4 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle2x4(v8l a, v8l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle2x8(v16f a, v16f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 2 elements with the same rule for every 8 blocks of 2 elements.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

for j from 0 to 7
  i = j*2
  dst[i] := SELECT2((mask.bits[i] ? a[i:i+1] : b[i:i+1]), rule[0])
  dst[i+1] := SELECT2((mask.bits[i+1] ? a[i:i+1] : b[i:i+1]), rule[1])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle2x8(v16i a, v16i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_fshuffle4x1(v4d a, v4d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_fshuffle4x1(v4f a, v4f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_fshuffle4x1(v4i a, v4i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_fshuffle4x1(v4l a, v4l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle4x2(v8d a, v8d b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle4x2(v8f a, v8f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle4x2(v8i a, v8i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 2 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle4x2(v8l a, v8l b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle4x4(v16f a, v16f b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 4 elements with the same rule for every 4 blocks of 4 elements.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

for j from 0 to 3
  i = j*4
  dst[i] := SELECT4((mask.bits[i] ? a[i:i+3] : b[i:i+3]), rule[0:1])
  dst[i+1] := SELECT4((mask.bits[i+1] ? a[i:i+3] : b[i:i+3]), rule[2:3])
  dst[i+2] := SELECT4((mask.bits[i+2] ? a[i:i+3] : b[i:i+3]), rule[4:5])
  dst[i+3] := SELECT4((mask.bits[i+3] ? a[i:i+3] : b[i:i+3]), rule[6:7])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle4x4(v16i a, v16i b, uint_fast8_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle8x1(v8d a, v8d b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle8x1(v8f a, v8f b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle8x1(v8i a, v8i b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle8x1(v8l a, v8l b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle8x2(v16f a, v16f b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 8 elements with the same rule for every 2 blocks of 8 elements.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

for j from 0 to 1
  i = j*8
  dst[i] := SELECT8((mask.bits[i] ? a[i:i+7] : b[i:i+7]), rule[0:2])
  dst[i+1] := SELECT8((mask.bits[i+1] ? a[i:i+7] : b[i:i+7]), rule[3:5])
  dst[i+2] := SELECT8((mask.bits[i+2] ? a[i:i+7] : b[i:i+7]), rule[6:8])
  dst[i+3] := SELECT8((mask.bits[i+3] ? a[i:i+7] : b[i:i+7]), rule[9:11])
  dst[i+4] := SELECT8((mask.bits[i+4] ? a[i:i+7] : b[i:i+7]), rule[12:14])
  dst[i+5] := SELECT8((mask.bits[i+5] ? a[i:i+7] : b[i:i+7]), rule[15:17])
  dst[i+6] := SELECT8((mask.bits[i+6] ? a[i:i+7] : b[i:i+7]), rule[18:20])
  dst[i+7] := SELECT8((mask.bits[i+7] ? a[i:i+7] : b[i:i+7]), rule[21:23])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle8x2(v16i a, v16i b, uint_fast32_t rule, uint_fast8_t mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16((mask.bits[i] ? a[i:i+15] : b[i:i+15]), rule[0:3])
  dst[i+1] := SELECT16((mask.bits[i+1] ? a[i:i+15] : b[i:i+15]), rule[4:7])
  dst[i+2] := SELECT16((mask.bits[i+2] ? a[i:i+15] : b[i:i+15]), rule[8:11])
  dst[i+3] := SELECT16((mask.bits[i+3] ? a[i:i+15] : b[i:i+15]), rule[12:15])
  dst[i+4] := SELECT16((mask.bits[i+4] ? a[i:i+15] : b[i:i+15]), rule[16:19])
  dst[i+5] := SELECT16((mask.bits[i+5] ? a[i:i+15] : b[i:i+15]), rule[20:23])
  dst[i+6] := SELECT16((mask.bits[i+6] ? a[i:i+15] : b[i:i+15]), rule[24:27])
  dst[i+7] := SELECT16((mask.bits[i+7] ? a[i:i+15] : b[i:i+15]), rule[28:31])
  dst[i+8] := SELECT16((mask.bits[i+8] ? a[i:i+15] : b[i:i+15]), rule[32:35])
  dst[i+9] := SELECT16((mask.bits[i+9] ? a[i:i+15] : b[i:i+15]), rule[36:39])
  dst[i+10] := SELECT16((mask.bits[i+10] ? a[i:i+15] : b[i:i+15]), rule[40:43])
  dst[i+11] := SELECT16((mask.bits[i+11] ? a[i:i+15] : b[i:i+15]), rule[44:47])
  dst[i+12] := SELECT16((mask.bits[i+12] ? a[i:i+15] : b[i:i+15]), rule[48:51])
  dst[i+13] := SELECT16((mask.bits[i+13] ? a[i:i+15] : b[i:i+15]), rule[52:55])
  dst[i+14] := SELECT16((mask.bits[i+14] ? a[i:i+15] : b[i:i+15]), rule[56:59])
  dst[i+15] := SELECT16((mask.bits[i+15] ? a[i:i+15] : b[i:i+15]), rule[60:63])
endfor
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle16x1(v16f a, v16f b, uint_fast64_t rule, uint_fast16_t mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle and the blend are done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

for j from 0 to 0
  i = j*16
  dst[i] := SELECT16((mask.bits[i] ? a[i:i+15] : b[i:i+15]), rule[0:3])
  dst[i+1] := SELECT16((mask.bits[i+1] ? a[i:i+15] : b[i:i+15]), rule[4:7])
  dst[i+2] := SELECT16((mask.bits[i+2] ? a[i:i+15] : b[i:i+15]), rule[8:11])
  dst[i+3] := SELECT16((mask.bits[i+3] ? a[i:i+15] : b[i:i+15]), rule[12:15])
  dst[i+4] := SELECT16((mask.bits[i+4] ? a[i:i+15] : b[i:i+15]), rule[16:19])
  dst[i+5] := SELECT16((mask.bits[i+5] ? a[i:i+15] : b[i:i+15]), rule[20:23])
  dst[i+6] := SELECT16((mask.bits[i+6] ? a[i:i+15] : b[i:i+15]), rule[24:27])
  dst[i+7] := SELECT16((mask.bits[i+7] ? a[i:i+15] : b[i:i+15]), rule[28:31])
  dst[i+8] := SELECT16((mask.bits[i+8] ? a[i:i+15] : b[i:i+15]), rule[32:35])
  dst[i+9] := SELECT16((mask.bits[i+9] ? a[i:i+15] : b[i:i+15]), rule[36:39])
  dst[i+10] := SELECT16((mask.bits[i+10] ? a[i:i+15] : b[i:i+15]), rule[40:43])
  dst[i+11] := SELECT16((mask.bits[i+11] ? a[i:i+15] : b[i:i+15]), rule[44:47])
  dst[i+12] := SELECT16((mask.bits[i+12] ? a[i:i+15] : b[i:i+15]), rule[48:51])
  dst[i+13] := SELECT16((mask.bits[i+13] ? a[i:i+15] : b[i:i+15]), rule[52:55])
  dst[i+14] := SELECT16((mask.bits[i+14] ? a[i:i+15] : b[i:i+15]), rule[56:59])
  dst[i+15] := SELECT16((mask.bits[i+15] ? a[i:i+15] : b[i:i+15]), rule[60:63])
endfor
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle16x1(v16i a, v16i b, uint_fast64_t rule, uint_fast16_t mask);

/**
 * \ingroup shuffle
 * \related v1d
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v1d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(b, rule[])
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1d v1d_hshuffle(v1d a, v1d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1f
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v1f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(b, rule[])
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1f v1f_hshuffle(v1f a, v1f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1i
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v1i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(b, rule[])
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1i v1i_hshuffle(v1i a, v1i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1l
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v1l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(b, rule[])
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1l v1l_hshuffle(v1l a, v1l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_hshuffle(v2d a, v2d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_hshuffle(v2f a, v2f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_hshuffle(v2i a, v2i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v2l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(b, rule[1])
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_hshuffle(v2l a, v2l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_hshuffle(v4d a, v4d b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_hshuffle(v4f a, v4f b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_hshuffle(v4i a, v4i b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v4l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(b, rule[4:5])
dst[3] := SELECT4(b, rule[6:7])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_hshuffle(v4l a, v4l b, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8d vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_hshuffle(v8d a, v8d b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_hshuffle(v8f a, v8f b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_hshuffle(v8i a, v8i b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v8l vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(b, rule[12:14])
dst[5] := SELECT8(b, rule[15:17])
dst[6] := SELECT8(b, rule[18:20])
dst[7] := SELECT8(b, rule[21:23])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_hshuffle(v8l a, v8l b, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16f vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(b, rule[32:35])
dst[9] := SELECT16(b, rule[36:39])
dst[10] := SELECT16(b, rule[40:43])
dst[11] := SELECT16(b, rule[44:47])
dst[12] := SELECT16(b, rule[48:51])
dst[13] := SELECT16(b, rule[52:55])
dst[14] := SELECT16(b, rule[56:59])
dst[15] := SELECT16(b, rule[60:63])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_hshuffle(v16f a, v16f b, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles \c a and \c b together using the control in \c rule.
 * \details Shuffles \c v16i vectors \c a and \c b together using the control in \c rule.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(b, rule[32:35])
dst[9] := SELECT16(b, rule[36:39])
dst[10] := SELECT16(b, rule[40:43])
dst[11] := SELECT16(b, rule[44:47])
dst[12] := SELECT16(b, rule[48:51])
dst[13] := SELECT16(b, rule[52:55])
dst[14] := SELECT16(b, rule[56:59])
dst[15] := SELECT16(b, rule[60:63])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_hshuffle(v16i a, v16i b, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v1d
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v1d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 1 elements with the same rule for every 1 blocks of 1 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v1d_hshuffle(a, a, rule)`
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(a, rule[])
\endimpl
 *  \see v1d_hshuffle1x1(v1d a, v1d b, uint_fast8_t rule)
 * \param a \c v1d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1d v1d_permute(v1d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1f
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v1f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 1 elements with the same rule for every 1 blocks of 1 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v1f_hshuffle(a, a, rule)`
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(a, rule[])
\endimpl
 *  \see v1f_hshuffle1x1(v1f a, v1f b, uint_fast8_t rule)
 * \param a \c v1f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1f v1f_permute(v1f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1i
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v1i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 1 elements with the same rule for every 1 blocks of 1 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v1i_hshuffle(a, a, rule)`
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(a, rule[])
\endimpl
 *  \see v1i_hshuffle1x1(v1i a, v1i b, uint_fast8_t rule)
 * \param a \c v1i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1i v1i_permute(v1i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v1l
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v1l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 1 elements with the same rule for every 1 blocks of 1 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v1l_hshuffle(a, a, rule)`
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1(a, rule[])
\endimpl
 *  \see v1l_hshuffle1x1(v1l a, v1l b, uint_fast8_t rule)
 * \param a \c v1l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v1l v1l_permute(v1l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2d
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v2d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v2d_hshuffle(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2d_hshuffle2x1(v2d a, v2d b, uint_fast8_t rule)
 * \param a \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_permute(v2d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v2f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v2f_hshuffle(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2f_hshuffle2x1(v2f a, v2f b, uint_fast8_t rule)
 * \param a \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_permute(v2f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v2i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v2i_hshuffle(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2i_hshuffle2x1(v2i a, v2i b, uint_fast8_t rule)
 * \param a \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_permute(v2i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v2l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 2 elements with the same rule for every 1 blocks of 2 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v2l_hshuffle(a, a, rule)`
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2(a, rule[0])
dst[1] := SELECT2(a, rule[1])
\endimpl
 *  \see v2l_hshuffle2x1(v2l a, v2l b, uint_fast8_t rule)
 * \param a \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_permute(v2l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v4d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v4d_hshuffle(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4d_hshuffle4x1(v4d a, v4d b, uint_fast8_t rule)
 * \param a \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_permute(v4d a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v4f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v4f_hshuffle(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4f_hshuffle4x1(v4f a, v4f b, uint_fast8_t rule)
 * \param a \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_permute(v4f a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v4i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v4i_hshuffle(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4i_hshuffle4x1(v4i a, v4i b, uint_fast8_t rule)
 * \param a \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_permute(v4i a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v4l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 4 elements with the same rule for every 1 blocks of 4 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v4l_hshuffle(a, a, rule)`
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4(a, rule[0:1])
dst[1] := SELECT4(a, rule[2:3])
dst[2] := SELECT4(a, rule[4:5])
dst[3] := SELECT4(a, rule[6:7])
\endimpl
 *  \see v4l_hshuffle4x1(v4l a, v4l b, uint_fast8_t rule)
 * \param a \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_permute(v4l a, uint_fast8_t rule);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v8d vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v8d_hshuffle(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8d_hshuffle8x1(v8d a, v8d b, uint_fast32_t rule)
 * \param a \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_permute(v8d a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v8f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v8f_hshuffle(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8f_hshuffle8x1(v8f a, v8f b, uint_fast32_t rule)
 * \param a \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_permute(v8f a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v8i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v8i_hshuffle(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8i_hshuffle8x1(v8i a, v8i b, uint_fast32_t rule)
 * \param a \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_permute(v8i a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v8l vector \c a using the control in \c rule.
 *  The shuffle is done by moving 8 elements with the same rule for every 1 blocks of 8 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v8l_hshuffle(a, a, rule)`
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8(a, rule[0:2])
dst[1] := SELECT8(a, rule[3:5])
dst[2] := SELECT8(a, rule[6:8])
dst[3] := SELECT8(a, rule[9:11])
dst[4] := SELECT8(a, rule[12:14])
dst[5] := SELECT8(a, rule[15:17])
dst[6] := SELECT8(a, rule[18:20])
dst[7] := SELECT8(a, rule[21:23])
\endimpl
 *  \see v8l_hshuffle8x1(v8l a, v8l b, uint_fast32_t rule)
 * \param a \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_permute(v8l a, uint_fast32_t rule);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v16f vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v16f_hshuffle(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(a, rule[32:35])
dst[9] := SELECT16(a, rule[36:39])
dst[10] := SELECT16(a, rule[40:43])
dst[11] := SELECT16(a, rule[44:47])
dst[12] := SELECT16(a, rule[48:51])
dst[13] := SELECT16(a, rule[52:55])
dst[14] := SELECT16(a, rule[56:59])
dst[15] := SELECT16(a, rule[60:63])
\endimpl
 *  \see v16f_hshuffle16x1(v16f a, v16f b, uint_fast64_t rule)
 * \param a \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_permute(v16f a, uint_fast64_t rule);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Shuffles \c a using the control in \c rule.
 * \details Shuffles the \c v16i vector \c a using the control in \c rule.
 *  The shuffle is done by moving 16 elements with the same rule for every 1 blocks of 16 elements.
 *  The shuffle is done on the whole vector.
 *
 *  Functionally equivalent to \c `v16i_hshuffle(a, a, rule)`
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16(a, rule[0:3])
dst[1] := SELECT16(a, rule[4:7])
dst[2] := SELECT16(a, rule[8:11])
dst[3] := SELECT16(a, rule[12:15])
dst[4] := SELECT16(a, rule[16:19])
dst[5] := SELECT16(a, rule[20:23])
dst[6] := SELECT16(a, rule[24:27])
dst[7] := SELECT16(a, rule[28:31])
dst[8] := SELECT16(a, rule[32:35])
dst[9] := SELECT16(a, rule[36:39])
dst[10] := SELECT16(a, rule[40:43])
dst[11] := SELECT16(a, rule[44:47])
dst[12] := SELECT16(a, rule[48:51])
dst[13] := SELECT16(a, rule[52:55])
dst[14] := SELECT16(a, rule[56:59])
dst[15] := SELECT16(a, rule[60:63])
\endimpl
 *  \see v16i_hshuffle16x1(v16i a, v16i b, uint_fast64_t rule)
 * \param a \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_permute(v16i a, uint_fast64_t rule);

/**
 * \ingroup shuffle
 * \related v1d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v1d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1((mask.bits[0] ? b : a), rule[])
\endimpl
 * \param a first \c v1d input vector
 * \param b second \c v1d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v1d v1d_fshuffle(v1d a, v1d b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v1f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v1f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1((mask.bits[0] ? b : a), rule[])
\endimpl
 * \param a first \c v1f input vector
 * \param b second \c v1f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v1f v1f_fshuffle(v1f a, v1f b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v1i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v1i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1((mask.bits[0] ? b : a), rule[])
\endimpl
 * \param a first \c v1i input vector
 * \param b second \c v1i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v1i v1i_fshuffle(v1i a, v1i b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v1l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v1l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT1(_src, _ctrl) {
  case _ctrl.bits[]
    0x0:  _tmp := _src[0]
  endcase
  return _tmp
}

dst[0] := SELECT1((mask.bits[0] ? b : a), rule[])
\endimpl
 * \param a first \c v1l input vector
 * \param b second \c v1l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v1l v1l_fshuffle(v1l a, v1l b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v2d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2d input vector
 * \param b second \c v2d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2d v2d_fshuffle(v2d a, v2d b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v2f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2f input vector
 * \param b second \c v2f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2f v2f_fshuffle(v2f a, v2f b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v2i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2i input vector
 * \param b second \c v2i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2i v2i_fshuffle(v2i a, v2i b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v2l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v2l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT2(_src, _ctrl) {
  case _ctrl.bits[0]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
  endcase
  return _tmp
}

dst[0] := SELECT2((mask.bits[0] ? b : a), rule[0])
dst[1] := SELECT2((mask.bits[1] ? b : a), rule[1])
\endimpl
 * \param a first \c v2l input vector
 * \param b second \c v2l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v2l v2l_fshuffle(v2l a, v2l b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v4d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4d input vector
 * \param b second \c v4d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4d v4d_fshuffle(v4d a, v4d b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v4f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4f input vector
 * \param b second \c v4f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4f v4f_fshuffle(v4f a, v4f b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v4i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4i input vector
 * \param b second \c v4i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4i v4i_fshuffle(v4i a, v4i b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v4l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v4l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT4(_src, _ctrl) {
  case _ctrl.bits[0:1]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
  endcase
  return _tmp
}

dst[0] := SELECT4((mask.bits[0] ? b : a), rule[0:1])
dst[1] := SELECT4((mask.bits[1] ? b : a), rule[2:3])
dst[2] := SELECT4((mask.bits[2] ? b : a), rule[4:5])
dst[3] := SELECT4((mask.bits[3] ? b : a), rule[6:7])
\endimpl
 * \param a first \c v4l input vector
 * \param b second \c v4l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v4l v4l_fshuffle(v4l a, v4l b, uint_fast8_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v8d
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8d vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8d input vector
 * \param b second \c v8d input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8d v8d_fshuffle(v8d a, v8d b, uint_fast32_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v8f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8f input vector
 * \param b second \c v8f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8f v8f_fshuffle(v8f a, v8f b, uint_fast32_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v8i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8i input vector
 * \param b second \c v8i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8i v8i_fshuffle(v8i a, v8i b, uint_fast32_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v8l
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v8l vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT8(_src, _ctrl) {
  case _ctrl.bits[0:2]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
  endcase
  return _tmp
}

dst[0] := SELECT8((mask.bits[0] ? b : a), rule[0:2])
dst[1] := SELECT8((mask.bits[1] ? b : a), rule[3:5])
dst[2] := SELECT8((mask.bits[2] ? b : a), rule[6:8])
dst[3] := SELECT8((mask.bits[3] ? b : a), rule[9:11])
dst[4] := SELECT8((mask.bits[4] ? b : a), rule[12:14])
dst[5] := SELECT8((mask.bits[5] ? b : a), rule[15:17])
dst[6] := SELECT8((mask.bits[6] ? b : a), rule[18:20])
dst[7] := SELECT8((mask.bits[7] ? b : a), rule[21:23])
\endimpl
 * \param a first \c v8l input vector
 * \param b second \c v8l input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v8l v8l_fshuffle(v8l a, v8l b, uint_fast32_t rule, uint_fast8_t  mask);
/**
 * \ingroup shuffle
 * \related v16f
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16f vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16((mask.bits[0] ? b : a), rule[0:3])
dst[1] := SELECT16((mask.bits[1] ? b : a), rule[4:7])
dst[2] := SELECT16((mask.bits[2] ? b : a), rule[8:11])
dst[3] := SELECT16((mask.bits[3] ? b : a), rule[12:15])
dst[4] := SELECT16((mask.bits[4] ? b : a), rule[16:19])
dst[5] := SELECT16((mask.bits[5] ? b : a), rule[20:23])
dst[6] := SELECT16((mask.bits[6] ? b : a), rule[24:27])
dst[7] := SELECT16((mask.bits[7] ? b : a), rule[28:31])
dst[8] := SELECT16((mask.bits[8] ? b : a), rule[32:35])
dst[9] := SELECT16((mask.bits[9] ? b : a), rule[36:39])
dst[10] := SELECT16((mask.bits[10] ? b : a), rule[40:43])
dst[11] := SELECT16((mask.bits[11] ? b : a), rule[44:47])
dst[12] := SELECT16((mask.bits[12] ? b : a), rule[48:51])
dst[13] := SELECT16((mask.bits[13] ? b : a), rule[52:55])
dst[14] := SELECT16((mask.bits[14] ? b : a), rule[56:59])
dst[15] := SELECT16((mask.bits[15] ? b : a), rule[60:63])
\endimpl
 * \param a first \c v16f input vector
 * \param b second \c v16f input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16f v16f_fshuffle(v16f a, v16f b, uint_fast64_t rule, uint_fast16_t  mask);
/**
 * \ingroup shuffle
 * \related v16i
 * \brief Fully shuffles (inner) \c a and \c b using the control in \c rule, and blends them together using \c mask.
 * \details Fully shuffles \c v16i vectors \c a and \c b using the control in \c rule, and blends them together using \c mask.
 *  The shuffle is done on whole vectors.
 * \impl
function SELECT16(_src, _ctrl) {
  case _ctrl.bits[0:3]
    0x0:  _tmp := _src[0]
    0x1:  _tmp := _src[1]
    0x2:  _tmp := _src[2]
    0x3:  _tmp := _src[3]
    0x4:  _tmp := _src[4]
    0x5:  _tmp := _src[5]
    0x6:  _tmp := _src[6]
    0x7:  _tmp := _src[7]
    0x8:  _tmp := _src[8]
    0x9:  _tmp := _src[9]
    0xA:  _tmp := _src[10]
    0xB:  _tmp := _src[11]
    0xC:  _tmp := _src[12]
    0xD:  _tmp := _src[13]
    0xE:  _tmp := _src[14]
    0xF:  _tmp := _src[15]
  endcase
  return _tmp
}

dst[0] := SELECT16((mask.bits[0] ? b : a), rule[0:3])
dst[1] := SELECT16((mask.bits[1] ? b : a), rule[4:7])
dst[2] := SELECT16((mask.bits[2] ? b : a), rule[8:11])
dst[3] := SELECT16((mask.bits[3] ? b : a), rule[12:15])
dst[4] := SELECT16((mask.bits[4] ? b : a), rule[16:19])
dst[5] := SELECT16((mask.bits[5] ? b : a), rule[20:23])
dst[6] := SELECT16((mask.bits[6] ? b : a), rule[24:27])
dst[7] := SELECT16((mask.bits[7] ? b : a), rule[28:31])
dst[8] := SELECT16((mask.bits[8] ? b : a), rule[32:35])
dst[9] := SELECT16((mask.bits[9] ? b : a), rule[36:39])
dst[10] := SELECT16((mask.bits[10] ? b : a), rule[40:43])
dst[11] := SELECT16((mask.bits[11] ? b : a), rule[44:47])
dst[12] := SELECT16((mask.bits[12] ? b : a), rule[48:51])
dst[13] := SELECT16((mask.bits[13] ? b : a), rule[52:55])
dst[14] := SELECT16((mask.bits[14] ? b : a), rule[56:59])
dst[15] := SELECT16((mask.bits[15] ? b : a), rule[60:63])
\endimpl
 * \param a first \c v16i input vector
 * \param b second \c v16i input vector
 * \param rule integer controlling the shuffle. Must be an immediate!
 * \param mask integer mask controlling the blend. Must be an immediate!
 * \returns shuffled vector
 */
v16i v16i_fshuffle(v16i a, v16i b, uint_fast64_t rule, uint_fast16_t  mask);

/* REDUCTIONS */
/** \defgroup red reductions functions
 * 
 */

/**
 * \ingroup red
 * \related v1d
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v1d v1d_reduce_add(v1d a);
/**
 * \ingroup red
 * \related v1f
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v1f v1f_reduce_add(v1f a);
/**
 * \ingroup red
 * \related v1i
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v1i v1i_reduce_add(v1i a);
/**
 * \ingroup red
 * \related v1l
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v1l v1l_reduce_add(v1l a);
/**
 * \ingroup red
 * \related v2d
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp + a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v2d v2d_reduce_add(v2d a);
/**
 * \ingroup red
 * \related v2f
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp + a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v2f v2f_reduce_add(v2f a);
/**
 * \ingroup red
 * \related v2i
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp + a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v2i v2i_reduce_add(v2i a);
/**
 * \ingroup red
 * \related v2l
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp + a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v2l v2l_reduce_add(v2l a);
/**
 * \ingroup red
 * \related v4d
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp + a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v4d v4d_reduce_add(v4d a);
/**
 * \ingroup red
 * \related v4f
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp + a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v4f v4f_reduce_add(v4f a);
/**
 * \ingroup red
 * \related v4i
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp + a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v4i v4i_reduce_add(v4i a);
/**
 * \ingroup red
 * \related v4l
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp + a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v4l v4l_reduce_add(v4l a);
/**
 * \ingroup red
 * \related v8d
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp + a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v8d v8d_reduce_add(v8d a);
/**
 * \ingroup red
 * \related v8f
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp + a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v8f v8f_reduce_add(v8f a);
/**
 * \ingroup red
 * \related v8i
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp + a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v8i v8i_reduce_add(v8i a);
/**
 * \ingroup red
 * \related v8l
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp + a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v8l v8l_reduce_add(v8l a);
/**
 * \ingroup red
 * \related v16f
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp + a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v16f v16f_reduce_add(v16f a);
/**
 * \ingroup red
 * \related v16i
 * \brief Reduction \c add ( + )
 * \details Reduces the operation \c add ( + ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp + a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce+(input)
 */
v16i v16i_reduce_add(v16i a);
/**
 * \ingroup red
 * \related v1d
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v1d v1d_reduce_mul(v1d a);
/**
 * \ingroup red
 * \related v1f
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v1f v1f_reduce_mul(v1f a);
/**
 * \ingroup red
 * \related v1i
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v1i v1i_reduce_mul(v1i a);
/**
 * \ingroup red
 * \related v1l
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v1l v1l_reduce_mul(v1l a);
/**
 * \ingroup red
 * \related v2d
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp * a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v2d v2d_reduce_mul(v2d a);
/**
 * \ingroup red
 * \related v2f
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp * a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v2f v2f_reduce_mul(v2f a);
/**
 * \ingroup red
 * \related v2i
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp * a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v2i v2i_reduce_mul(v2i a);
/**
 * \ingroup red
 * \related v2l
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp * a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v2l v2l_reduce_mul(v2l a);
/**
 * \ingroup red
 * \related v4d
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp * a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v4d v4d_reduce_mul(v4d a);
/**
 * \ingroup red
 * \related v4f
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp * a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v4f v4f_reduce_mul(v4f a);
/**
 * \ingroup red
 * \related v4i
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp * a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v4i v4i_reduce_mul(v4i a);
/**
 * \ingroup red
 * \related v4l
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp * a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v4l v4l_reduce_mul(v4l a);
/**
 * \ingroup red
 * \related v8d
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp * a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v8d v8d_reduce_mul(v8d a);
/**
 * \ingroup red
 * \related v8f
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp * a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v8f v8f_reduce_mul(v8f a);
/**
 * \ingroup red
 * \related v8i
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp * a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v8i v8i_reduce_mul(v8i a);
/**
 * \ingroup red
 * \related v8l
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp * a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v8l v8l_reduce_mul(v8l a);
/**
 * \ingroup red
 * \related v16f
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp * a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v16f v16f_reduce_mul(v16f a);
/**
 * \ingroup red
 * \related v16i
 * \brief Reduction \c mul ( * )
 * \details Reduces the operation \c mul ( * ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp * a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce*(input)
 */
v16i v16i_reduce_mul(v16i a);
/**
 * \ingroup red
 * \related v1d
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v1d v1d_reduce_and(v1d a);
/**
 * \ingroup red
 * \related v1f
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v1f v1f_reduce_and(v1f a);
/**
 * \ingroup red
 * \related v1i
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v1i v1i_reduce_and(v1i a);
/**
 * \ingroup red
 * \related v1l
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v1l v1l_reduce_and(v1l a);
/**
 * \ingroup red
 * \related v2d
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp & a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v2d v2d_reduce_and(v2d a);
/**
 * \ingroup red
 * \related v2f
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp & a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v2f v2f_reduce_and(v2f a);
/**
 * \ingroup red
 * \related v2i
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp & a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v2i v2i_reduce_and(v2i a);
/**
 * \ingroup red
 * \related v2l
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp & a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v2l v2l_reduce_and(v2l a);
/**
 * \ingroup red
 * \related v4d
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp & a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v4d v4d_reduce_and(v4d a);
/**
 * \ingroup red
 * \related v4f
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp & a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v4f v4f_reduce_and(v4f a);
/**
 * \ingroup red
 * \related v4i
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp & a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v4i v4i_reduce_and(v4i a);
/**
 * \ingroup red
 * \related v4l
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp & a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v4l v4l_reduce_and(v4l a);
/**
 * \ingroup red
 * \related v8d
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp & a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v8d v8d_reduce_and(v8d a);
/**
 * \ingroup red
 * \related v8f
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp & a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v8f v8f_reduce_and(v8f a);
/**
 * \ingroup red
 * \related v8i
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp & a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v8i v8i_reduce_and(v8i a);
/**
 * \ingroup red
 * \related v8l
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp & a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v8l v8l_reduce_and(v8l a);
/**
 * \ingroup red
 * \related v16f
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp & a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v16f v16f_reduce_and(v16f a);
/**
 * \ingroup red
 * \related v16i
 * \brief Reduction \c and ( & )
 * \details Reduces the operation \c and ( & ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp & a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce&(input)
 */
v16i v16i_reduce_and(v16i a);
/**
 * \ingroup red
 * \related v1d
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v1d v1d_reduce_or(v1d a);
/**
 * \ingroup red
 * \related v1f
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v1f v1f_reduce_or(v1f a);
/**
 * \ingroup red
 * \related v1i
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v1i v1i_reduce_or(v1i a);
/**
 * \ingroup red
 * \related v1l
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
dst := a
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v1l v1l_reduce_or(v1l a);
/**
 * \ingroup red
 * \related v2d
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp | a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v2d v2d_reduce_or(v2d a);
/**
 * \ingroup red
 * \related v2f
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp | a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v2f v2f_reduce_or(v2f a);
/**
 * \ingroup red
 * \related v2i
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp | a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v2i v2i_reduce_or(v2i a);
/**
 * \ingroup red
 * \related v2l
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 1
  tmp := tmp | a[i]
endfor

for i from 0 to 1
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v2l v2l_reduce_or(v2l a);
/**
 * \ingroup red
 * \related v4d
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp | a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v4d v4d_reduce_or(v4d a);
/**
 * \ingroup red
 * \related v4f
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp | a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v4f v4f_reduce_or(v4f a);
/**
 * \ingroup red
 * \related v4i
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp | a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v4i v4i_reduce_or(v4i a);
/**
 * \ingroup red
 * \related v4l
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 3
  tmp := tmp | a[i]
endfor

for i from 0 to 3
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v4l v4l_reduce_or(v4l a);
/**
 * \ingroup red
 * \related v8d
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp | a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v8d v8d_reduce_or(v8d a);
/**
 * \ingroup red
 * \related v8f
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp | a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v8f v8f_reduce_or(v8f a);
/**
 * \ingroup red
 * \related v8i
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp | a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v8i v8i_reduce_or(v8i a);
/**
 * \ingroup red
 * \related v8l
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 7
  tmp := tmp | a[i]
endfor

for i from 0 to 7
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v8l v8l_reduce_or(v8l a);
/**
 * \ingroup red
 * \related v16f
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp | a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v16f v16f_reduce_or(v16f a);
/**
 * \ingroup red
 * \related v16i
 * \brief Reduction \c or ( | )
 * \details Reduces the operation \c or ( | ) over every elements of the input.
 *  Stores the result in every elements of the vector.
 * \impl
tmp := a[0]
for i from 1 to 15
  tmp := tmp | a[i]
endfor

for i from 0 to 15
  dst[i] := tmp
endfor
\endimpl
 * \param a input
 * \returns reduce|(input)
 */
v16i v16i_reduce_or(v16i a);


/* MOVES */
/** \defgroup mov move functions
 * 
 */

/**
 * \ingroup mov
 * \related v1d
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v1d v1d_move(v1d a);
/**
 * \ingroup mov
 * \related v1f
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v1f v1f_move(v1f a);
/**
 * \ingroup mov
 * \related v1i
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v1i v1i_move(v1i a);
/**
 * \ingroup mov
 * \related v1l
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v1l v1l_move(v1l a);
/**
 * \ingroup mov
 * \related v2d
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v2d v2d_move(v2d a);
/**
 * \ingroup mov
 * \related v2f
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v2f v2f_move(v2f a);
/**
 * \ingroup mov
 * \related v2i
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v2i v2i_move(v2i a);
/**
 * \ingroup mov
 * \related v2l
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v2l v2l_move(v2l a);
/**
 * \ingroup mov
 * \related v4d
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v4d v4d_move(v4d a);
/**
 * \ingroup mov
 * \related v4f
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v4f v4f_move(v4f a);
/**
 * \ingroup mov
 * \related v4i
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v4i v4i_move(v4i a);
/**
 * \ingroup mov
 * \related v4l
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v4l v4l_move(v4l a);
/**
 * \ingroup mov
 * \related v8d
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v8d v8d_move(v8d a);
/**
 * \ingroup mov
 * \related v8f
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v8f v8f_move(v8f a);
/**
 * \ingroup mov
 * \related v8i
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v8i v8i_move(v8i a);
/**
 * \ingroup mov
 * \related v8l
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v8l v8l_move(v8l a);
/**
 * \ingroup mov
 * \related v16f
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v16f v16f_move(v16f a);
/**
 * \ingroup mov
 * \related v16i
 * \brief Forwards the input.
 * \details Forwards the input vector to the output: does nothing.
 * \param a input
 * \returns input
 */
v16i v16i_move(v16i a);

/**
 * \ingroup mov
 * \related v1d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v1d v1d_maskz_move(m1d mask, v1d a);
/**
 * \ingroup mov
 * \related v1f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v1f v1f_maskz_move(m1f mask, v1f a);
/**
 * \ingroup mov
 * \related v1i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v1i v1i_maskz_move(m1i mask, v1i a);
/**
 * \ingroup mov
 * \related v1l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v1l v1l_maskz_move(m1l mask, v1l a);
/**
 * \ingroup mov
 * \related v2d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v2d v2d_maskz_move(m2d mask, v2d a);
/**
 * \ingroup mov
 * \related v2f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v2f v2f_maskz_move(m2f mask, v2f a);
/**
 * \ingroup mov
 * \related v2i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v2i v2i_maskz_move(m2i mask, v2i a);
/**
 * \ingroup mov
 * \related v2l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v2l v2l_maskz_move(m2l mask, v2l a);
/**
 * \ingroup mov
 * \related v4d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v4d v4d_maskz_move(m4d mask, v4d a);
/**
 * \ingroup mov
 * \related v4f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v4f v4f_maskz_move(m4f mask, v4f a);
/**
 * \ingroup mov
 * \related v4i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v4i v4i_maskz_move(m4i mask, v4i a);
/**
 * \ingroup mov
 * \related v4l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v4l v4l_maskz_move(m4l mask, v4l a);
/**
 * \ingroup mov
 * \related v8d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v8d v8d_maskz_move(m8d mask, v8d a);
/**
 * \ingroup mov
 * \related v8f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v8f v8f_maskz_move(m8f mask, v8f a);
/**
 * \ingroup mov
 * \related v8i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v8i v8i_maskz_move(m8i mask, v8i a);
/**
 * \ingroup mov
 * \related v8l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v8l v8l_maskz_move(m8l mask, v8l a);
/**
 * \ingroup mov
 * \related v16f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v16f v16f_maskz_move(m16f mask, v16f a);
/**
 * \ingroup mov
 * \related v16i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, 0 otherwise
 * \param mask 
 * \param a input
 * \returns masked input
 */
v16i v16i_maskz_move(m16i mask, v16i a);

/**
 * \ingroup mov
 * \related v1d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v1d v1d_mask_move(m1d mask, v1d src, v1d a);
/**
 * \ingroup mov
 * \related v1f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v1f v1f_mask_move(m1f mask, v1f src, v1f a);
/**
 * \ingroup mov
 * \related v1i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v1i v1i_mask_move(m1i mask, v1i src, v1i a);
/**
 * \ingroup mov
 * \related v1l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v1l v1l_mask_move(m1l mask, v1l src, v1l a);
/**
 * \ingroup mov
 * \related v2d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v2d v2d_mask_move(m2d mask, v2d src, v2d a);
/**
 * \ingroup mov
 * \related v2f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v2f v2f_mask_move(m2f mask, v2f src, v2f a);
/**
 * \ingroup mov
 * \related v2i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v2i v2i_mask_move(m2i mask, v2i src, v2i a);
/**
 * \ingroup mov
 * \related v2l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v2l v2l_mask_move(m2l mask, v2l src, v2l a);
/**
 * \ingroup mov
 * \related v4d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v4d v4d_mask_move(m4d mask, v4d src, v4d a);
/**
 * \ingroup mov
 * \related v4f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v4f v4f_mask_move(m4f mask, v4f src, v4f a);
/**
 * \ingroup mov
 * \related v4i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v4i v4i_mask_move(m4i mask, v4i src, v4i a);
/**
 * \ingroup mov
 * \related v4l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v4l v4l_mask_move(m4l mask, v4l src, v4l a);
/**
 * \ingroup mov
 * \related v8d
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v8d v8d_mask_move(m8d mask, v8d src, v8d a);
/**
 * \ingroup mov
 * \related v8f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v8f v8f_mask_move(m8f mask, v8f src, v8f a);
/**
 * \ingroup mov
 * \related v8i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v8i v8i_mask_move(m8i mask, v8i src, v8i a);
/**
 * \ingroup mov
 * \related v8l
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v8l v8l_mask_move(m8l mask, v8l src, v8l a);
/**
 * \ingroup mov
 * \related v16f
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v16f v16f_mask_move(m16f mask, v16f src, v16f a);
/**
 * \ingroup mov
 * \related v16i
 * \brief Mask the input.
 * \details Copy the input elements to the output if mask[i] is set, src[i] otherwise
 * \param mask chooses between \c src and \c a
 * \param src elements when mask is not set
 * \param a input
 * \returns masked input
 */
v16i v16i_mask_move(m16i mask, v16i src, v16i a);


/* PRINTS */
/** \defgroup print print functions
 * 
 */

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector
 * \details Prints the \c v1d input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1d vector to print
 * \param format printf-like format
 */
void v1d_fprintf(FILE *file, v1d a, const char* format);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector
 * \details Prints the \c v1f input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1f vector to print
 * \param format printf-like format
 */
void v1f_fprintf(FILE *file, v1f a, const char* format);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector
 * \details Prints the \c v1i input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1i vector to print
 * \param format printf-like format
 */
void v1i_fprintf(FILE *file, v1i a, const char* format);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector
 * \details Prints the \c v1l input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1l vector to print
 * \param format printf-like format
 */
void v1l_fprintf(FILE *file, v1l a, const char* format);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector
 * \details Prints the \c v2d input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2d vector to print
 * \param format printf-like format
 */
void v2d_fprintf(FILE *file, v2d a, const char* format);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector
 * \details Prints the \c v2f input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2f vector to print
 * \param format printf-like format
 */
void v2f_fprintf(FILE *file, v2f a, const char* format);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector
 * \details Prints the \c v2i input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2i vector to print
 * \param format printf-like format
 */
void v2i_fprintf(FILE *file, v2i a, const char* format);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector
 * \details Prints the \c v2l input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2l vector to print
 * \param format printf-like format
 */
void v2l_fprintf(FILE *file, v2l a, const char* format);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector
 * \details Prints the \c v4d input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4d vector to print
 * \param format printf-like format
 */
void v4d_fprintf(FILE *file, v4d a, const char* format);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector
 * \details Prints the \c v4f input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4f vector to print
 * \param format printf-like format
 */
void v4f_fprintf(FILE *file, v4f a, const char* format);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector
 * \details Prints the \c v4i input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4i vector to print
 * \param format printf-like format
 */
void v4i_fprintf(FILE *file, v4i a, const char* format);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector
 * \details Prints the \c v4l input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4l vector to print
 * \param format printf-like format
 */
void v4l_fprintf(FILE *file, v4l a, const char* format);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector
 * \details Prints the \c v8d input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8d vector to print
 * \param format printf-like format
 */
void v8d_fprintf(FILE *file, v8d a, const char* format);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector
 * \details Prints the \c v8f input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8f vector to print
 * \param format printf-like format
 */
void v8f_fprintf(FILE *file, v8f a, const char* format);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector
 * \details Prints the \c v8i input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8i vector to print
 * \param format printf-like format
 */
void v8i_fprintf(FILE *file, v8i a, const char* format);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector
 * \details Prints the \c v8l input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8l vector to print
 * \param format printf-like format
 */
void v8l_fprintf(FILE *file, v8l a, const char* format);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector
 * \details Prints the \c v16f input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v16f vector to print
 * \param format printf-like format
 */
void v16f_fprintf(FILE *file, v16f a, const char* format);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector
 * \details Prints the \c v16i input vector into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v16i vector to print
 * \param format printf-like format
 */
void v16i_fprintf(FILE *file, v16i a, const char* format);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector
 * \details Prints the \c v1d input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1d_fprintf(stdout, a, format)`
 * \param a \c v1d vector to print
 * \param format printf-like format
 */
void v1d_printf(v1d a, const char* format);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector
 * \details Prints the \c v1f input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1f_fprintf(stdout, a, format)`
 * \param a \c v1f vector to print
 * \param format printf-like format
 */
void v1f_printf(v1f a, const char* format);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector
 * \details Prints the \c v1i input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1i_fprintf(stdout, a, format)`
 * \param a \c v1i vector to print
 * \param format printf-like format
 */
void v1i_printf(v1i a, const char* format);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector
 * \details Prints the \c v1l input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1l_fprintf(stdout, a, format)`
 * \param a \c v1l vector to print
 * \param format printf-like format
 */
void v1l_printf(v1l a, const char* format);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector
 * \details Prints the \c v2d input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2d_fprintf(stdout, a, format)`
 * \param a \c v2d vector to print
 * \param format printf-like format
 */
void v2d_printf(v2d a, const char* format);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector
 * \details Prints the \c v2f input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2f_fprintf(stdout, a, format)`
 * \param a \c v2f vector to print
 * \param format printf-like format
 */
void v2f_printf(v2f a, const char* format);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector
 * \details Prints the \c v2i input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2i_fprintf(stdout, a, format)`
 * \param a \c v2i vector to print
 * \param format printf-like format
 */
void v2i_printf(v2i a, const char* format);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector
 * \details Prints the \c v2l input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2l_fprintf(stdout, a, format)`
 * \param a \c v2l vector to print
 * \param format printf-like format
 */
void v2l_printf(v2l a, const char* format);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector
 * \details Prints the \c v4d input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4d_fprintf(stdout, a, format)`
 * \param a \c v4d vector to print
 * \param format printf-like format
 */
void v4d_printf(v4d a, const char* format);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector
 * \details Prints the \c v4f input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4f_fprintf(stdout, a, format)`
 * \param a \c v4f vector to print
 * \param format printf-like format
 */
void v4f_printf(v4f a, const char* format);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector
 * \details Prints the \c v4i input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4i_fprintf(stdout, a, format)`
 * \param a \c v4i vector to print
 * \param format printf-like format
 */
void v4i_printf(v4i a, const char* format);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector
 * \details Prints the \c v4l input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4l_fprintf(stdout, a, format)`
 * \param a \c v4l vector to print
 * \param format printf-like format
 */
void v4l_printf(v4l a, const char* format);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector
 * \details Prints the \c v8d input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8d_fprintf(stdout, a, format)`
 * \param a \c v8d vector to print
 * \param format printf-like format
 */
void v8d_printf(v8d a, const char* format);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector
 * \details Prints the \c v8f input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8f_fprintf(stdout, a, format)`
 * \param a \c v8f vector to print
 * \param format printf-like format
 */
void v8f_printf(v8f a, const char* format);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector
 * \details Prints the \c v8i input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8i_fprintf(stdout, a, format)`
 * \param a \c v8i vector to print
 * \param format printf-like format
 */
void v8i_printf(v8i a, const char* format);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector
 * \details Prints the \c v8l input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8l_fprintf(stdout, a, format)`
 * \param a \c v8l vector to print
 * \param format printf-like format
 */
void v8l_printf(v8l a, const char* format);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector
 * \details Prints the \c v16f input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v16f_fprintf(stdout, a, format)`
 * \param a \c v16f vector to print
 * \param format printf-like format
 */
void v16f_printf(v16f a, const char* format);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector
 * \details Prints the \c v16i input vector to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v16i_fprintf(stdout, a, format)`
 * \param a \c v16i vector to print
 * \param format printf-like format
 */
void v16i_printf(v16i a, const char* format);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector
 * \details Prints the \c v1d input vector into \c file.
 * \details functionally equivalent to \c `v1d_fprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v1d vector to print
 */
void v1d_fprint(FILE *file, v1d a);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector
 * \details Prints the \c v1f input vector into \c file.
 * \details functionally equivalent to \c `v1f_fprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v1f vector to print
 */
void v1f_fprint(FILE *file, v1f a);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector
 * \details Prints the \c v1i input vector into \c file.
 * \details functionally equivalent to \c `v1i_fprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v1i vector to print
 */
void v1i_fprint(FILE *file, v1i a);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector
 * \details Prints the \c v1l input vector into \c file.
 * \details functionally equivalent to \c `v1l_fprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v1l vector to print
 */
void v1l_fprint(FILE *file, v1l a);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector
 * \details Prints the \c v2d input vector into \c file.
 * \details functionally equivalent to \c `v2d_fprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v2d vector to print
 */
void v2d_fprint(FILE *file, v2d a);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector
 * \details Prints the \c v2f input vector into \c file.
 * \details functionally equivalent to \c `v2f_fprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v2f vector to print
 */
void v2f_fprint(FILE *file, v2f a);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector
 * \details Prints the \c v2i input vector into \c file.
 * \details functionally equivalent to \c `v2i_fprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v2i vector to print
 */
void v2i_fprint(FILE *file, v2i a);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector
 * \details Prints the \c v2l input vector into \c file.
 * \details functionally equivalent to \c `v2l_fprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v2l vector to print
 */
void v2l_fprint(FILE *file, v2l a);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector
 * \details Prints the \c v4d input vector into \c file.
 * \details functionally equivalent to \c `v4d_fprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v4d vector to print
 */
void v4d_fprint(FILE *file, v4d a);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector
 * \details Prints the \c v4f input vector into \c file.
 * \details functionally equivalent to \c `v4f_fprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v4f vector to print
 */
void v4f_fprint(FILE *file, v4f a);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector
 * \details Prints the \c v4i input vector into \c file.
 * \details functionally equivalent to \c `v4i_fprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v4i vector to print
 */
void v4i_fprint(FILE *file, v4i a);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector
 * \details Prints the \c v4l input vector into \c file.
 * \details functionally equivalent to \c `v4l_fprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v4l vector to print
 */
void v4l_fprint(FILE *file, v4l a);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector
 * \details Prints the \c v8d input vector into \c file.
 * \details functionally equivalent to \c `v8d_fprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v8d vector to print
 */
void v8d_fprint(FILE *file, v8d a);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector
 * \details Prints the \c v8f input vector into \c file.
 * \details functionally equivalent to \c `v8f_fprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v8f vector to print
 */
void v8f_fprint(FILE *file, v8f a);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector
 * \details Prints the \c v8i input vector into \c file.
 * \details functionally equivalent to \c `v8i_fprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v8i vector to print
 */
void v8i_fprint(FILE *file, v8i a);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector
 * \details Prints the \c v8l input vector into \c file.
 * \details functionally equivalent to \c `v8l_fprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v8l vector to print
 */
void v8l_fprint(FILE *file, v8l a);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector
 * \details Prints the \c v16f input vector into \c file.
 * \details functionally equivalent to \c `v16f_fprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v16f vector to print
 */
void v16f_fprint(FILE *file, v16f a);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector
 * \details Prints the \c v16i input vector into \c file.
 * \details functionally equivalent to \c `v16i_fprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v16i vector to print
 */
void v16i_fprint(FILE *file, v16i a);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector
 * \details Prints the \c v1d input vector to stdout.
 * \details functionally equivalent to \c `v1d_fprintf(stdout, a, "%lf")`
 * \param a \c v1d vector to print
 */
void v1d_print(v1d a);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector
 * \details Prints the \c v1f input vector to stdout.
 * \details functionally equivalent to \c `v1f_fprintf(stdout, a, "%f")`
 * \param a \c v1f vector to print
 */
void v1f_print(v1f a);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector
 * \details Prints the \c v1i input vector to stdout.
 * \details functionally equivalent to \c `v1i_fprintf(stdout, a, "%i")`
 * \param a \c v1i vector to print
 */
void v1i_print(v1i a);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector
 * \details Prints the \c v1l input vector to stdout.
 * \details functionally equivalent to \c `v1l_fprintf(stdout, a, "%lli")`
 * \param a \c v1l vector to print
 */
void v1l_print(v1l a);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector
 * \details Prints the \c v2d input vector to stdout.
 * \details functionally equivalent to \c `v2d_fprintf(stdout, a, "%lf")`
 * \param a \c v2d vector to print
 */
void v2d_print(v2d a);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector
 * \details Prints the \c v2f input vector to stdout.
 * \details functionally equivalent to \c `v2f_fprintf(stdout, a, "%f")`
 * \param a \c v2f vector to print
 */
void v2f_print(v2f a);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector
 * \details Prints the \c v2i input vector to stdout.
 * \details functionally equivalent to \c `v2i_fprintf(stdout, a, "%i")`
 * \param a \c v2i vector to print
 */
void v2i_print(v2i a);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector
 * \details Prints the \c v2l input vector to stdout.
 * \details functionally equivalent to \c `v2l_fprintf(stdout, a, "%lli")`
 * \param a \c v2l vector to print
 */
void v2l_print(v2l a);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector
 * \details Prints the \c v4d input vector to stdout.
 * \details functionally equivalent to \c `v4d_fprintf(stdout, a, "%lf")`
 * \param a \c v4d vector to print
 */
void v4d_print(v4d a);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector
 * \details Prints the \c v4f input vector to stdout.
 * \details functionally equivalent to \c `v4f_fprintf(stdout, a, "%f")`
 * \param a \c v4f vector to print
 */
void v4f_print(v4f a);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector
 * \details Prints the \c v4i input vector to stdout.
 * \details functionally equivalent to \c `v4i_fprintf(stdout, a, "%i")`
 * \param a \c v4i vector to print
 */
void v4i_print(v4i a);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector
 * \details Prints the \c v4l input vector to stdout.
 * \details functionally equivalent to \c `v4l_fprintf(stdout, a, "%lli")`
 * \param a \c v4l vector to print
 */
void v4l_print(v4l a);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector
 * \details Prints the \c v8d input vector to stdout.
 * \details functionally equivalent to \c `v8d_fprintf(stdout, a, "%lf")`
 * \param a \c v8d vector to print
 */
void v8d_print(v8d a);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector
 * \details Prints the \c v8f input vector to stdout.
 * \details functionally equivalent to \c `v8f_fprintf(stdout, a, "%f")`
 * \param a \c v8f vector to print
 */
void v8f_print(v8f a);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector
 * \details Prints the \c v8i input vector to stdout.
 * \details functionally equivalent to \c `v8i_fprintf(stdout, a, "%i")`
 * \param a \c v8i vector to print
 */
void v8i_print(v8i a);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector
 * \details Prints the \c v8l input vector to stdout.
 * \details functionally equivalent to \c `v8l_fprintf(stdout, a, "%lli")`
 * \param a \c v8l vector to print
 */
void v8l_print(v8l a);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector
 * \details Prints the \c v16f input vector to stdout.
 * \details functionally equivalent to \c `v16f_fprintf(stdout, a, "%f")`
 * \param a \c v16f vector to print
 */
void v16f_print(v16f a);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector
 * \details Prints the \c v16i input vector to stdout.
 * \details functionally equivalent to \c `v16i_fprintf(stdout, a, "%i")`
 * \param a \c v16i vector to print
 */
void v16i_print(v16i a);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector (reversed order)
 * \details Prints the \c v1d input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1d vector to print
 * \param format printf-like format
 */
void v1d_rfprintf(FILE *file, v1d a, const char* format);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector (reversed order)
 * \details Prints the \c v1f input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1f vector to print
 * \param format printf-like format
 */
void v1f_rfprintf(FILE *file, v1f a, const char* format);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector (reversed order)
 * \details Prints the \c v1i input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1i vector to print
 * \param format printf-like format
 */
void v1i_rfprintf(FILE *file, v1i a, const char* format);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector (reversed order)
 * \details Prints the \c v1l input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v1l vector to print
 * \param format printf-like format
 */
void v1l_rfprintf(FILE *file, v1l a, const char* format);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector (reversed order)
 * \details Prints the \c v2d input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2d vector to print
 * \param format printf-like format
 */
void v2d_rfprintf(FILE *file, v2d a, const char* format);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector (reversed order)
 * \details Prints the \c v2f input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2f vector to print
 * \param format printf-like format
 */
void v2f_rfprintf(FILE *file, v2f a, const char* format);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector (reversed order)
 * \details Prints the \c v2i input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2i vector to print
 * \param format printf-like format
 */
void v2i_rfprintf(FILE *file, v2i a, const char* format);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector (reversed order)
 * \details Prints the \c v2l input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v2l vector to print
 * \param format printf-like format
 */
void v2l_rfprintf(FILE *file, v2l a, const char* format);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector (reversed order)
 * \details Prints the \c v4d input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4d vector to print
 * \param format printf-like format
 */
void v4d_rfprintf(FILE *file, v4d a, const char* format);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector (reversed order)
 * \details Prints the \c v4f input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4f vector to print
 * \param format printf-like format
 */
void v4f_rfprintf(FILE *file, v4f a, const char* format);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector (reversed order)
 * \details Prints the \c v4i input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4i vector to print
 * \param format printf-like format
 */
void v4i_rfprintf(FILE *file, v4i a, const char* format);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector (reversed order)
 * \details Prints the \c v4l input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v4l vector to print
 * \param format printf-like format
 */
void v4l_rfprintf(FILE *file, v4l a, const char* format);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector (reversed order)
 * \details Prints the \c v8d input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8d vector to print
 * \param format printf-like format
 */
void v8d_rfprintf(FILE *file, v8d a, const char* format);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector (reversed order)
 * \details Prints the \c v8f input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8f vector to print
 * \param format printf-like format
 */
void v8f_rfprintf(FILE *file, v8f a, const char* format);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector (reversed order)
 * \details Prints the \c v8i input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8i vector to print
 * \param format printf-like format
 */
void v8i_rfprintf(FILE *file, v8i a, const char* format);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector (reversed order)
 * \details Prints the \c v8l input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v8l vector to print
 * \param format printf-like format
 */
void v8l_rfprintf(FILE *file, v8l a, const char* format);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector (reversed order)
 * \details Prints the \c v16f input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v16f vector to print
 * \param format printf-like format
 */
void v16f_rfprintf(FILE *file, v16f a, const char* format);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector (reversed order)
 * \details Prints the \c v16i input vector in reverse order into \c file,
 *  using \c format to format the printing of each element.
 * \param file output file
 * \param a \c v16i vector to print
 * \param format printf-like format
 */
void v16i_rfprintf(FILE *file, v16i a, const char* format);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector (reversed order)
 * \details Prints the \c v1d input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1d_rfprintf(stdout, a, format)`
 * \param a \c v1d vector to print
 * \param format printf-like format
 */
void v1d_rprintf(v1d a, const char* format);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector (reversed order)
 * \details Prints the \c v1f input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1f_rfprintf(stdout, a, format)`
 * \param a \c v1f vector to print
 * \param format printf-like format
 */
void v1f_rprintf(v1f a, const char* format);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector (reversed order)
 * \details Prints the \c v1i input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1i_rfprintf(stdout, a, format)`
 * \param a \c v1i vector to print
 * \param format printf-like format
 */
void v1i_rprintf(v1i a, const char* format);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector (reversed order)
 * \details Prints the \c v1l input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v1l_rfprintf(stdout, a, format)`
 * \param a \c v1l vector to print
 * \param format printf-like format
 */
void v1l_rprintf(v1l a, const char* format);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector (reversed order)
 * \details Prints the \c v2d input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2d_rfprintf(stdout, a, format)`
 * \param a \c v2d vector to print
 * \param format printf-like format
 */
void v2d_rprintf(v2d a, const char* format);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector (reversed order)
 * \details Prints the \c v2f input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2f_rfprintf(stdout, a, format)`
 * \param a \c v2f vector to print
 * \param format printf-like format
 */
void v2f_rprintf(v2f a, const char* format);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector (reversed order)
 * \details Prints the \c v2i input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2i_rfprintf(stdout, a, format)`
 * \param a \c v2i vector to print
 * \param format printf-like format
 */
void v2i_rprintf(v2i a, const char* format);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector (reversed order)
 * \details Prints the \c v2l input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v2l_rfprintf(stdout, a, format)`
 * \param a \c v2l vector to print
 * \param format printf-like format
 */
void v2l_rprintf(v2l a, const char* format);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector (reversed order)
 * \details Prints the \c v4d input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4d_rfprintf(stdout, a, format)`
 * \param a \c v4d vector to print
 * \param format printf-like format
 */
void v4d_rprintf(v4d a, const char* format);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector (reversed order)
 * \details Prints the \c v4f input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4f_rfprintf(stdout, a, format)`
 * \param a \c v4f vector to print
 * \param format printf-like format
 */
void v4f_rprintf(v4f a, const char* format);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector (reversed order)
 * \details Prints the \c v4i input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4i_rfprintf(stdout, a, format)`
 * \param a \c v4i vector to print
 * \param format printf-like format
 */
void v4i_rprintf(v4i a, const char* format);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector (reversed order)
 * \details Prints the \c v4l input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v4l_rfprintf(stdout, a, format)`
 * \param a \c v4l vector to print
 * \param format printf-like format
 */
void v4l_rprintf(v4l a, const char* format);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector (reversed order)
 * \details Prints the \c v8d input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8d_rfprintf(stdout, a, format)`
 * \param a \c v8d vector to print
 * \param format printf-like format
 */
void v8d_rprintf(v8d a, const char* format);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector (reversed order)
 * \details Prints the \c v8f input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8f_rfprintf(stdout, a, format)`
 * \param a \c v8f vector to print
 * \param format printf-like format
 */
void v8f_rprintf(v8f a, const char* format);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector (reversed order)
 * \details Prints the \c v8i input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8i_rfprintf(stdout, a, format)`
 * \param a \c v8i vector to print
 * \param format printf-like format
 */
void v8i_rprintf(v8i a, const char* format);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector (reversed order)
 * \details Prints the \c v8l input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v8l_rfprintf(stdout, a, format)`
 * \param a \c v8l vector to print
 * \param format printf-like format
 */
void v8l_rprintf(v8l a, const char* format);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector (reversed order)
 * \details Prints the \c v16f input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v16f_rfprintf(stdout, a, format)`
 * \param a \c v16f vector to print
 * \param format printf-like format
 */
void v16f_rprintf(v16f a, const char* format);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector (reversed order)
 * \details Prints the \c v16i input vector in reverse order to \c stdout,
 *  using \c format to format the printing of each element.
 * \details functionally equivalent to \c `v16i_rfprintf(stdout, a, format)`
 * \param a \c v16i vector to print
 * \param format printf-like format
 */
void v16i_rprintf(v16i a, const char* format);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector (reversed order)
 * \details Prints the \c v1d input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v1d_rfprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v1d vector to print
 */
void v1d_rfprint(FILE *file, v1d a);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector (reversed order)
 * \details Prints the \c v1f input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v1f_rfprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v1f vector to print
 */
void v1f_rfprint(FILE *file, v1f a);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector (reversed order)
 * \details Prints the \c v1i input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v1i_rfprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v1i vector to print
 */
void v1i_rfprint(FILE *file, v1i a);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector (reversed order)
 * \details Prints the \c v1l input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v1l_rfprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v1l vector to print
 */
void v1l_rfprint(FILE *file, v1l a);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector (reversed order)
 * \details Prints the \c v2d input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v2d_rfprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v2d vector to print
 */
void v2d_rfprint(FILE *file, v2d a);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector (reversed order)
 * \details Prints the \c v2f input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v2f_rfprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v2f vector to print
 */
void v2f_rfprint(FILE *file, v2f a);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector (reversed order)
 * \details Prints the \c v2i input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v2i_rfprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v2i vector to print
 */
void v2i_rfprint(FILE *file, v2i a);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector (reversed order)
 * \details Prints the \c v2l input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v2l_rfprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v2l vector to print
 */
void v2l_rfprint(FILE *file, v2l a);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector (reversed order)
 * \details Prints the \c v4d input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v4d_rfprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v4d vector to print
 */
void v4d_rfprint(FILE *file, v4d a);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector (reversed order)
 * \details Prints the \c v4f input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v4f_rfprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v4f vector to print
 */
void v4f_rfprint(FILE *file, v4f a);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector (reversed order)
 * \details Prints the \c v4i input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v4i_rfprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v4i vector to print
 */
void v4i_rfprint(FILE *file, v4i a);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector (reversed order)
 * \details Prints the \c v4l input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v4l_rfprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v4l vector to print
 */
void v4l_rfprint(FILE *file, v4l a);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector (reversed order)
 * \details Prints the \c v8d input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v8d_rfprintf(file, a, "%lf")`
 * \param file output file
 * \param a \c v8d vector to print
 */
void v8d_rfprint(FILE *file, v8d a);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector (reversed order)
 * \details Prints the \c v8f input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v8f_rfprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v8f vector to print
 */
void v8f_rfprint(FILE *file, v8f a);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector (reversed order)
 * \details Prints the \c v8i input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v8i_rfprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v8i vector to print
 */
void v8i_rfprint(FILE *file, v8i a);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector (reversed order)
 * \details Prints the \c v8l input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v8l_rfprintf(file, a, "%lli")`
 * \param file output file
 * \param a \c v8l vector to print
 */
void v8l_rfprint(FILE *file, v8l a);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector (reversed order)
 * \details Prints the \c v16f input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v16f_rfprintf(file, a, "%f")`
 * \param file output file
 * \param a \c v16f vector to print
 */
void v16f_rfprint(FILE *file, v16f a);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector (reversed order)
 * \details Prints the \c v16i input vector in reverse order into \c file.
 * \details functionally equivalent to \c `v16i_rfprintf(file, a, "%i")`
 * \param file output file
 * \param a \c v16i vector to print
 */
void v16i_rfprint(FILE *file, v16i a);

/**
 * \ingroup print
 * \related v1d
 * \brief Prints a \c v1d vector (reversed order)
 * \details Prints the \c v1d input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v1d_rfprintf(stdout, a, "%lf")`
 * \param a \c v1d vector to print
 */
void v1d_rprint(v1d a);
/**
 * \ingroup print
 * \related v1f
 * \brief Prints a \c v1f vector (reversed order)
 * \details Prints the \c v1f input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v1f_rfprintf(stdout, a, "%f")`
 * \param a \c v1f vector to print
 */
void v1f_rprint(v1f a);
/**
 * \ingroup print
 * \related v1i
 * \brief Prints a \c v1i vector (reversed order)
 * \details Prints the \c v1i input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v1i_rfprintf(stdout, a, "%i")`
 * \param a \c v1i vector to print
 */
void v1i_rprint(v1i a);
/**
 * \ingroup print
 * \related v1l
 * \brief Prints a \c v1l vector (reversed order)
 * \details Prints the \c v1l input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v1l_rfprintf(stdout, a, "%lli")`
 * \param a \c v1l vector to print
 */
void v1l_rprint(v1l a);
/**
 * \ingroup print
 * \related v2d
 * \brief Prints a \c v2d vector (reversed order)
 * \details Prints the \c v2d input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v2d_rfprintf(stdout, a, "%lf")`
 * \param a \c v2d vector to print
 */
void v2d_rprint(v2d a);
/**
 * \ingroup print
 * \related v2f
 * \brief Prints a \c v2f vector (reversed order)
 * \details Prints the \c v2f input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v2f_rfprintf(stdout, a, "%f")`
 * \param a \c v2f vector to print
 */
void v2f_rprint(v2f a);
/**
 * \ingroup print
 * \related v2i
 * \brief Prints a \c v2i vector (reversed order)
 * \details Prints the \c v2i input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v2i_rfprintf(stdout, a, "%i")`
 * \param a \c v2i vector to print
 */
void v2i_rprint(v2i a);
/**
 * \ingroup print
 * \related v2l
 * \brief Prints a \c v2l vector (reversed order)
 * \details Prints the \c v2l input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v2l_rfprintf(stdout, a, "%lli")`
 * \param a \c v2l vector to print
 */
void v2l_rprint(v2l a);
/**
 * \ingroup print
 * \related v4d
 * \brief Prints a \c v4d vector (reversed order)
 * \details Prints the \c v4d input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v4d_rfprintf(stdout, a, "%lf")`
 * \param a \c v4d vector to print
 */
void v4d_rprint(v4d a);
/**
 * \ingroup print
 * \related v4f
 * \brief Prints a \c v4f vector (reversed order)
 * \details Prints the \c v4f input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v4f_rfprintf(stdout, a, "%f")`
 * \param a \c v4f vector to print
 */
void v4f_rprint(v4f a);
/**
 * \ingroup print
 * \related v4i
 * \brief Prints a \c v4i vector (reversed order)
 * \details Prints the \c v4i input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v4i_rfprintf(stdout, a, "%i")`
 * \param a \c v4i vector to print
 */
void v4i_rprint(v4i a);
/**
 * \ingroup print
 * \related v4l
 * \brief Prints a \c v4l vector (reversed order)
 * \details Prints the \c v4l input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v4l_rfprintf(stdout, a, "%lli")`
 * \param a \c v4l vector to print
 */
void v4l_rprint(v4l a);
/**
 * \ingroup print
 * \related v8d
 * \brief Prints a \c v8d vector (reversed order)
 * \details Prints the \c v8d input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v8d_rfprintf(stdout, a, "%lf")`
 * \param a \c v8d vector to print
 */
void v8d_rprint(v8d a);
/**
 * \ingroup print
 * \related v8f
 * \brief Prints a \c v8f vector (reversed order)
 * \details Prints the \c v8f input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v8f_rfprintf(stdout, a, "%f")`
 * \param a \c v8f vector to print
 */
void v8f_rprint(v8f a);
/**
 * \ingroup print
 * \related v8i
 * \brief Prints a \c v8i vector (reversed order)
 * \details Prints the \c v8i input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v8i_rfprintf(stdout, a, "%i")`
 * \param a \c v8i vector to print
 */
void v8i_rprint(v8i a);
/**
 * \ingroup print
 * \related v8l
 * \brief Prints a \c v8l vector (reversed order)
 * \details Prints the \c v8l input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v8l_rfprintf(stdout, a, "%lli")`
 * \param a \c v8l vector to print
 */
void v8l_rprint(v8l a);
/**
 * \ingroup print
 * \related v16f
 * \brief Prints a \c v16f vector (reversed order)
 * \details Prints the \c v16f input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v16f_rfprintf(stdout, a, "%f")`
 * \param a \c v16f vector to print
 */
void v16f_rprint(v16f a);
/**
 * \ingroup print
 * \related v16i
 * \brief Prints a \c v16i vector (reversed order)
 * \details Prints the \c v16i input vector in reverse order to stdout.
 * \details functionally equivalent to \c `v16i_rfprintf(stdout, a, "%i")`
 * \param a \c v16i vector to print
 */
void v16i_rprint(v16i a);

/* CASTS */
/** \defgroup cast cast functions
 * Functions for (bitwise) casting vectors
 */

/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v1d vector into a \c v1d vector.
 * \details Casts a \c v1d vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v1d vector into a \c v1f vector.
 * \details Casts a \c v1d vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v1d vector into a \c v1i vector.
 * \details Casts a \c v1d vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v1d vector into a \c v1l vector.
 * \details Casts a \c v1d vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v1d vector into a \c v2d vector.
 * \details Casts a \c v1d vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v1d vector into a \c v2f vector.
 * \details Casts a \c v1d vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v1d vector into a \c v2i vector.
 * \details Casts a \c v1d vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v1d vector into a \c v2l vector.
 * \details Casts a \c v1d vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v1d vector into a \c v4d vector.
 * \details Casts a \c v1d vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v1d vector into a \c v4f vector.
 * \details Casts a \c v1d vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v1d vector into a \c v4i vector.
 * \details Casts a \c v1d vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v1d vector into a \c v4l vector.
 * \details Casts a \c v1d vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v1d vector into a \c v8d vector.
 * \details Casts a \c v1d vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v1d vector into a \c v8f vector.
 * \details Casts a \c v1d vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v1d vector into a \c v8i vector.
 * \details Casts a \c v1d vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v1d vector into a \c v8l vector.
 * \details Casts a \c v1d vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v1d vector into a \c v16f vector.
 * \details Casts a \c v1d vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v1d vector into a \c v16i vector.
 * \details Casts a \c v1d vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v1d(v1d a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v1f vector into a \c v1d vector.
 * \details Casts a \c v1f vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v1f vector into a \c v1f vector.
 * \details Casts a \c v1f vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v1f vector into a \c v1i vector.
 * \details Casts a \c v1f vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v1f vector into a \c v1l vector.
 * \details Casts a \c v1f vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v1f vector into a \c v2d vector.
 * \details Casts a \c v1f vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v1f vector into a \c v2f vector.
 * \details Casts a \c v1f vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v1f vector into a \c v2i vector.
 * \details Casts a \c v1f vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v1f vector into a \c v2l vector.
 * \details Casts a \c v1f vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v1f vector into a \c v4d vector.
 * \details Casts a \c v1f vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v1f vector into a \c v4f vector.
 * \details Casts a \c v1f vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v1f vector into a \c v4i vector.
 * \details Casts a \c v1f vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v1f vector into a \c v4l vector.
 * \details Casts a \c v1f vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v1f vector into a \c v8d vector.
 * \details Casts a \c v1f vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v1f vector into a \c v8f vector.
 * \details Casts a \c v1f vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v1f vector into a \c v8i vector.
 * \details Casts a \c v1f vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v1f vector into a \c v8l vector.
 * \details Casts a \c v1f vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v1f vector into a \c v16f vector.
 * \details Casts a \c v1f vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v1f vector into a \c v16i vector.
 * \details Casts a \c v1f vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v1f(v1f a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v1i vector into a \c v1d vector.
 * \details Casts a \c v1i vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v1i vector into a \c v1f vector.
 * \details Casts a \c v1i vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v1i vector into a \c v1i vector.
 * \details Casts a \c v1i vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v1i vector into a \c v1l vector.
 * \details Casts a \c v1i vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v1i vector into a \c v2d vector.
 * \details Casts a \c v1i vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v1i vector into a \c v2f vector.
 * \details Casts a \c v1i vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v1i vector into a \c v2i vector.
 * \details Casts a \c v1i vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v1i vector into a \c v2l vector.
 * \details Casts a \c v1i vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v1i vector into a \c v4d vector.
 * \details Casts a \c v1i vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v1i vector into a \c v4f vector.
 * \details Casts a \c v1i vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v1i vector into a \c v4i vector.
 * \details Casts a \c v1i vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v1i vector into a \c v4l vector.
 * \details Casts a \c v1i vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v1i vector into a \c v8d vector.
 * \details Casts a \c v1i vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v1i vector into a \c v8f vector.
 * \details Casts a \c v1i vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v1i vector into a \c v8i vector.
 * \details Casts a \c v1i vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v1i vector into a \c v8l vector.
 * \details Casts a \c v1i vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v1i vector into a \c v16f vector.
 * \details Casts a \c v1i vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v1i vector into a \c v16i vector.
 * \details Casts a \c v1i vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v1i(v1i a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v1l vector into a \c v1d vector.
 * \details Casts a \c v1l vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v1l vector into a \c v1f vector.
 * \details Casts a \c v1l vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v1l vector into a \c v1i vector.
 * \details Casts a \c v1l vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v1l vector into a \c v1l vector.
 * \details Casts a \c v1l vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v1l vector into a \c v2d vector.
 * \details Casts a \c v1l vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v1l vector into a \c v2f vector.
 * \details Casts a \c v1l vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v1l vector into a \c v2i vector.
 * \details Casts a \c v1l vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v1l vector into a \c v2l vector.
 * \details Casts a \c v1l vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v1l vector into a \c v4d vector.
 * \details Casts a \c v1l vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v1l vector into a \c v4f vector.
 * \details Casts a \c v1l vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v1l vector into a \c v4i vector.
 * \details Casts a \c v1l vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v1l vector into a \c v4l vector.
 * \details Casts a \c v1l vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v1l vector into a \c v8d vector.
 * \details Casts a \c v1l vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v1l vector into a \c v8f vector.
 * \details Casts a \c v1l vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v1l vector into a \c v8i vector.
 * \details Casts a \c v1l vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v1l vector into a \c v8l vector.
 * \details Casts a \c v1l vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v1l vector into a \c v16f vector.
 * \details Casts a \c v1l vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v1l vector into a \c v16i vector.
 * \details Casts a \c v1l vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v1l(v1l a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v2d vector into a \c v1d vector.
 * \details Casts a \c v2d vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v2d vector into a \c v1f vector.
 * \details Casts a \c v2d vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v2d vector into a \c v1i vector.
 * \details Casts a \c v2d vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v2d vector into a \c v1l vector.
 * \details Casts a \c v2d vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v2d vector into a \c v2d vector.
 * \details Casts a \c v2d vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v2d vector into a \c v2f vector.
 * \details Casts a \c v2d vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v2d vector into a \c v2i vector.
 * \details Casts a \c v2d vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v2d vector into a \c v2l vector.
 * \details Casts a \c v2d vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v2d vector into a \c v4d vector.
 * \details Casts a \c v2d vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v2d vector into a \c v4f vector.
 * \details Casts a \c v2d vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v2d vector into a \c v4i vector.
 * \details Casts a \c v2d vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v2d vector into a \c v4l vector.
 * \details Casts a \c v2d vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v2d vector into a \c v8d vector.
 * \details Casts a \c v2d vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v2d vector into a \c v8f vector.
 * \details Casts a \c v2d vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v2d vector into a \c v8i vector.
 * \details Casts a \c v2d vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v2d vector into a \c v8l vector.
 * \details Casts a \c v2d vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v2d vector into a \c v16f vector.
 * \details Casts a \c v2d vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v2d vector into a \c v16i vector.
 * \details Casts a \c v2d vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v2d(v2d a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v2f vector into a \c v1d vector.
 * \details Casts a \c v2f vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v2f vector into a \c v1f vector.
 * \details Casts a \c v2f vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v2f vector into a \c v1i vector.
 * \details Casts a \c v2f vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v2f vector into a \c v1l vector.
 * \details Casts a \c v2f vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v2f vector into a \c v2d vector.
 * \details Casts a \c v2f vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v2f vector into a \c v2f vector.
 * \details Casts a \c v2f vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v2f vector into a \c v2i vector.
 * \details Casts a \c v2f vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v2f vector into a \c v2l vector.
 * \details Casts a \c v2f vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v2f vector into a \c v4d vector.
 * \details Casts a \c v2f vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v2f vector into a \c v4f vector.
 * \details Casts a \c v2f vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v2f vector into a \c v4i vector.
 * \details Casts a \c v2f vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v2f vector into a \c v4l vector.
 * \details Casts a \c v2f vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v2f vector into a \c v8d vector.
 * \details Casts a \c v2f vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v2f vector into a \c v8f vector.
 * \details Casts a \c v2f vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v2f vector into a \c v8i vector.
 * \details Casts a \c v2f vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v2f vector into a \c v8l vector.
 * \details Casts a \c v2f vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v2f vector into a \c v16f vector.
 * \details Casts a \c v2f vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v2f vector into a \c v16i vector.
 * \details Casts a \c v2f vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v2f(v2f a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v2i vector into a \c v1d vector.
 * \details Casts a \c v2i vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v2i vector into a \c v1f vector.
 * \details Casts a \c v2i vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v2i vector into a \c v1i vector.
 * \details Casts a \c v2i vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v2i vector into a \c v1l vector.
 * \details Casts a \c v2i vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v2i vector into a \c v2d vector.
 * \details Casts a \c v2i vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v2i vector into a \c v2f vector.
 * \details Casts a \c v2i vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v2i vector into a \c v2i vector.
 * \details Casts a \c v2i vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v2i vector into a \c v2l vector.
 * \details Casts a \c v2i vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v2i vector into a \c v4d vector.
 * \details Casts a \c v2i vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v2i vector into a \c v4f vector.
 * \details Casts a \c v2i vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v2i vector into a \c v4i vector.
 * \details Casts a \c v2i vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v2i vector into a \c v4l vector.
 * \details Casts a \c v2i vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v2i vector into a \c v8d vector.
 * \details Casts a \c v2i vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v2i vector into a \c v8f vector.
 * \details Casts a \c v2i vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v2i vector into a \c v8i vector.
 * \details Casts a \c v2i vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v2i vector into a \c v8l vector.
 * \details Casts a \c v2i vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v2i vector into a \c v16f vector.
 * \details Casts a \c v2i vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v2i vector into a \c v16i vector.
 * \details Casts a \c v2i vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v2i(v2i a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v2l vector into a \c v1d vector.
 * \details Casts a \c v2l vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v2l vector into a \c v1f vector.
 * \details Casts a \c v2l vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v2l vector into a \c v1i vector.
 * \details Casts a \c v2l vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v2l vector into a \c v1l vector.
 * \details Casts a \c v2l vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v2l vector into a \c v2d vector.
 * \details Casts a \c v2l vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v2l vector into a \c v2f vector.
 * \details Casts a \c v2l vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v2l vector into a \c v2i vector.
 * \details Casts a \c v2l vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v2l vector into a \c v2l vector.
 * \details Casts a \c v2l vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v2l vector into a \c v4d vector.
 * \details Casts a \c v2l vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v2l vector into a \c v4f vector.
 * \details Casts a \c v2l vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v2l vector into a \c v4i vector.
 * \details Casts a \c v2l vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v2l vector into a \c v4l vector.
 * \details Casts a \c v2l vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v2l vector into a \c v8d vector.
 * \details Casts a \c v2l vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v2l vector into a \c v8f vector.
 * \details Casts a \c v2l vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v2l vector into a \c v8i vector.
 * \details Casts a \c v2l vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v2l vector into a \c v8l vector.
 * \details Casts a \c v2l vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v2l vector into a \c v16f vector.
 * \details Casts a \c v2l vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v2l vector into a \c v16i vector.
 * \details Casts a \c v2l vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v2l(v2l a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v4d vector into a \c v1d vector.
 * \details Casts a \c v4d vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v4d vector into a \c v1f vector.
 * \details Casts a \c v4d vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v4d vector into a \c v1i vector.
 * \details Casts a \c v4d vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v4d vector into a \c v1l vector.
 * \details Casts a \c v4d vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v4d vector into a \c v2d vector.
 * \details Casts a \c v4d vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v4d vector into a \c v2f vector.
 * \details Casts a \c v4d vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v4d vector into a \c v2i vector.
 * \details Casts a \c v4d vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v4d vector into a \c v2l vector.
 * \details Casts a \c v4d vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v4d vector into a \c v4d vector.
 * \details Casts a \c v4d vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v4d vector into a \c v4f vector.
 * \details Casts a \c v4d vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v4d vector into a \c v4i vector.
 * \details Casts a \c v4d vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v4d vector into a \c v4l vector.
 * \details Casts a \c v4d vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v4d vector into a \c v8d vector.
 * \details Casts a \c v4d vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v4d vector into a \c v8f vector.
 * \details Casts a \c v4d vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v4d vector into a \c v8i vector.
 * \details Casts a \c v4d vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v4d vector into a \c v8l vector.
 * \details Casts a \c v4d vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v4d vector into a \c v16f vector.
 * \details Casts a \c v4d vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v4d vector into a \c v16i vector.
 * \details Casts a \c v4d vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v4d(v4d a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v4f vector into a \c v1d vector.
 * \details Casts a \c v4f vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v4f vector into a \c v1f vector.
 * \details Casts a \c v4f vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v4f vector into a \c v1i vector.
 * \details Casts a \c v4f vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v4f vector into a \c v1l vector.
 * \details Casts a \c v4f vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v4f vector into a \c v2d vector.
 * \details Casts a \c v4f vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v4f vector into a \c v2f vector.
 * \details Casts a \c v4f vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v4f vector into a \c v2i vector.
 * \details Casts a \c v4f vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v4f vector into a \c v2l vector.
 * \details Casts a \c v4f vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v4f vector into a \c v4d vector.
 * \details Casts a \c v4f vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v4f vector into a \c v4f vector.
 * \details Casts a \c v4f vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v4f vector into a \c v4i vector.
 * \details Casts a \c v4f vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v4f vector into a \c v4l vector.
 * \details Casts a \c v4f vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v4f vector into a \c v8d vector.
 * \details Casts a \c v4f vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v4f vector into a \c v8f vector.
 * \details Casts a \c v4f vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v4f vector into a \c v8i vector.
 * \details Casts a \c v4f vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v4f vector into a \c v8l vector.
 * \details Casts a \c v4f vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v4f vector into a \c v16f vector.
 * \details Casts a \c v4f vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v4f vector into a \c v16i vector.
 * \details Casts a \c v4f vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v4f(v4f a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v4i vector into a \c v1d vector.
 * \details Casts a \c v4i vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v4i vector into a \c v1f vector.
 * \details Casts a \c v4i vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v4i vector into a \c v1i vector.
 * \details Casts a \c v4i vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v4i vector into a \c v1l vector.
 * \details Casts a \c v4i vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v4i vector into a \c v2d vector.
 * \details Casts a \c v4i vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v4i vector into a \c v2f vector.
 * \details Casts a \c v4i vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v4i vector into a \c v2i vector.
 * \details Casts a \c v4i vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v4i vector into a \c v2l vector.
 * \details Casts a \c v4i vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v4i vector into a \c v4d vector.
 * \details Casts a \c v4i vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v4i vector into a \c v4f vector.
 * \details Casts a \c v4i vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v4i vector into a \c v4i vector.
 * \details Casts a \c v4i vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v4i vector into a \c v4l vector.
 * \details Casts a \c v4i vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v4i vector into a \c v8d vector.
 * \details Casts a \c v4i vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v4i vector into a \c v8f vector.
 * \details Casts a \c v4i vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v4i vector into a \c v8i vector.
 * \details Casts a \c v4i vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v4i vector into a \c v8l vector.
 * \details Casts a \c v4i vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v4i vector into a \c v16f vector.
 * \details Casts a \c v4i vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v4i vector into a \c v16i vector.
 * \details Casts a \c v4i vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v4i(v4i a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v4l vector into a \c v1d vector.
 * \details Casts a \c v4l vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v4l vector into a \c v1f vector.
 * \details Casts a \c v4l vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v4l vector into a \c v1i vector.
 * \details Casts a \c v4l vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v4l vector into a \c v1l vector.
 * \details Casts a \c v4l vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v4l vector into a \c v2d vector.
 * \details Casts a \c v4l vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v4l vector into a \c v2f vector.
 * \details Casts a \c v4l vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v4l vector into a \c v2i vector.
 * \details Casts a \c v4l vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v4l vector into a \c v2l vector.
 * \details Casts a \c v4l vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v4l vector into a \c v4d vector.
 * \details Casts a \c v4l vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v4l vector into a \c v4f vector.
 * \details Casts a \c v4l vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v4l vector into a \c v4i vector.
 * \details Casts a \c v4l vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v4l vector into a \c v4l vector.
 * \details Casts a \c v4l vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v4l vector into a \c v8d vector.
 * \details Casts a \c v4l vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v4l vector into a \c v8f vector.
 * \details Casts a \c v4l vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v4l vector into a \c v8i vector.
 * \details Casts a \c v4l vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v4l vector into a \c v8l vector.
 * \details Casts a \c v4l vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v4l vector into a \c v16f vector.
 * \details Casts a \c v4l vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v4l vector into a \c v16i vector.
 * \details Casts a \c v4l vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v4l(v4l a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v8d vector into a \c v1d vector.
 * \details Casts a \c v8d vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v8d vector into a \c v1f vector.
 * \details Casts a \c v8d vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v8d vector into a \c v1i vector.
 * \details Casts a \c v8d vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v8d vector into a \c v1l vector.
 * \details Casts a \c v8d vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v8d vector into a \c v2d vector.
 * \details Casts a \c v8d vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v8d vector into a \c v2f vector.
 * \details Casts a \c v8d vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v8d vector into a \c v2i vector.
 * \details Casts a \c v8d vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v8d vector into a \c v2l vector.
 * \details Casts a \c v8d vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v8d vector into a \c v4d vector.
 * \details Casts a \c v8d vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v8d vector into a \c v4f vector.
 * \details Casts a \c v8d vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v8d vector into a \c v4i vector.
 * \details Casts a \c v8d vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v8d vector into a \c v4l vector.
 * \details Casts a \c v8d vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v8d vector into a \c v8d vector.
 * \details Casts a \c v8d vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v8d vector into a \c v8f vector.
 * \details Casts a \c v8d vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v8d vector into a \c v8i vector.
 * \details Casts a \c v8d vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v8d vector into a \c v8l vector.
 * \details Casts a \c v8d vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v8d vector into a \c v16f vector.
 * \details Casts a \c v8d vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v8d vector into a \c v16i vector.
 * \details Casts a \c v8d vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v8d(v8d a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v8f vector into a \c v1d vector.
 * \details Casts a \c v8f vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v8f vector into a \c v1f vector.
 * \details Casts a \c v8f vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v8f vector into a \c v1i vector.
 * \details Casts a \c v8f vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v8f vector into a \c v1l vector.
 * \details Casts a \c v8f vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v8f vector into a \c v2d vector.
 * \details Casts a \c v8f vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v8f vector into a \c v2f vector.
 * \details Casts a \c v8f vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v8f vector into a \c v2i vector.
 * \details Casts a \c v8f vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v8f vector into a \c v2l vector.
 * \details Casts a \c v8f vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v8f vector into a \c v4d vector.
 * \details Casts a \c v8f vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v8f vector into a \c v4f vector.
 * \details Casts a \c v8f vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v8f vector into a \c v4i vector.
 * \details Casts a \c v8f vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v8f vector into a \c v4l vector.
 * \details Casts a \c v8f vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v8f vector into a \c v8d vector.
 * \details Casts a \c v8f vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v8f vector into a \c v8f vector.
 * \details Casts a \c v8f vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v8f vector into a \c v8i vector.
 * \details Casts a \c v8f vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v8f vector into a \c v8l vector.
 * \details Casts a \c v8f vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v8f vector into a \c v16f vector.
 * \details Casts a \c v8f vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v8f vector into a \c v16i vector.
 * \details Casts a \c v8f vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v8f(v8f a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v8i vector into a \c v1d vector.
 * \details Casts a \c v8i vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v8i vector into a \c v1f vector.
 * \details Casts a \c v8i vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v8i vector into a \c v1i vector.
 * \details Casts a \c v8i vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v8i vector into a \c v1l vector.
 * \details Casts a \c v8i vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v8i vector into a \c v2d vector.
 * \details Casts a \c v8i vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v8i vector into a \c v2f vector.
 * \details Casts a \c v8i vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v8i vector into a \c v2i vector.
 * \details Casts a \c v8i vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v8i vector into a \c v2l vector.
 * \details Casts a \c v8i vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v8i vector into a \c v4d vector.
 * \details Casts a \c v8i vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v8i vector into a \c v4f vector.
 * \details Casts a \c v8i vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v8i vector into a \c v4i vector.
 * \details Casts a \c v8i vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v8i vector into a \c v4l vector.
 * \details Casts a \c v8i vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v8i vector into a \c v8d vector.
 * \details Casts a \c v8i vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v8i vector into a \c v8f vector.
 * \details Casts a \c v8i vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v8i vector into a \c v8i vector.
 * \details Casts a \c v8i vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v8i vector into a \c v8l vector.
 * \details Casts a \c v8i vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v8i vector into a \c v16f vector.
 * \details Casts a \c v8i vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v8i vector into a \c v16i vector.
 * \details Casts a \c v8i vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the result are undefined.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v8i(v8i a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v8l vector into a \c v1d vector.
 * \details Casts a \c v8l vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v8l vector into a \c v1f vector.
 * \details Casts a \c v8l vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v8l vector into a \c v1i vector.
 * \details Casts a \c v8l vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v8l vector into a \c v1l vector.
 * \details Casts a \c v8l vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v8l vector into a \c v2d vector.
 * \details Casts a \c v8l vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v8l vector into a \c v2f vector.
 * \details Casts a \c v8l vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v8l vector into a \c v2i vector.
 * \details Casts a \c v8l vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v8l vector into a \c v2l vector.
 * \details Casts a \c v8l vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v8l vector into a \c v4d vector.
 * \details Casts a \c v8l vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v8l vector into a \c v4f vector.
 * \details Casts a \c v8l vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v8l vector into a \c v4i vector.
 * \details Casts a \c v8l vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v8l vector into a \c v4l vector.
 * \details Casts a \c v8l vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v8l vector into a \c v8d vector.
 * \details Casts a \c v8l vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v8l vector into a \c v8f vector.
 * \details Casts a \c v8l vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v8l vector into a \c v8i vector.
 * \details Casts a \c v8l vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v8l vector into a \c v8l vector.
 * \details Casts a \c v8l vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v8l vector into a \c v16f vector.
 * \details Casts a \c v8l vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v8l vector into a \c v16i vector.
 * \details Casts a \c v8l vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v8l(v8l a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v16f vector into a \c v1d vector.
 * \details Casts a \c v16f vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v16f vector into a \c v1f vector.
 * \details Casts a \c v16f vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v16f vector into a \c v1i vector.
 * \details Casts a \c v16f vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v16f vector into a \c v1l vector.
 * \details Casts a \c v16f vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v16f vector into a \c v2d vector.
 * \details Casts a \c v16f vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v16f vector into a \c v2f vector.
 * \details Casts a \c v16f vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v16f vector into a \c v2i vector.
 * \details Casts a \c v16f vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v16f vector into a \c v2l vector.
 * \details Casts a \c v16f vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v16f vector into a \c v4d vector.
 * \details Casts a \c v16f vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v16f vector into a \c v4f vector.
 * \details Casts a \c v16f vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v16f vector into a \c v4i vector.
 * \details Casts a \c v16f vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v16f vector into a \c v4l vector.
 * \details Casts a \c v16f vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v16f vector into a \c v8d vector.
 * \details Casts a \c v16f vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v16f vector into a \c v8f vector.
 * \details Casts a \c v16f vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v16f vector into a \c v8i vector.
 * \details Casts a \c v16f vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v16f vector into a \c v8l vector.
 * \details Casts a \c v16f vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v16f vector into a \c v16f vector.
 * \details Casts a \c v16f vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v16f vector into a \c v16i vector.
 * \details Casts a \c v16f vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v16f(v16f a);
/**
 * \ingroup cast
 * \related v1d
 * \brief Casts a \c v16i vector into a \c v1d vector.
 * \details Casts a \c v16i vector into a \c v1d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1d v1d_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v1f
 * \brief Casts a \c v16i vector into a \c v1f vector.
 * \details Casts a \c v16i vector into a \c v1f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1f v1f_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v1i
 * \brief Casts a \c v16i vector into a \c v1i vector.
 * \details Casts a \c v16i vector into a \c v1i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:31] := a.bits[0:31]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1i v1i_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v1l
 * \brief Casts a \c v16i vector into a \c v1l vector.
 * \details Casts a \c v16i vector into a \c v1l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v1l v1l_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v2d
 * \brief Casts a \c v16i vector into a \c v2d vector.
 * \details Casts a \c v16i vector into a \c v2d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2d v2d_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v2f
 * \brief Casts a \c v16i vector into a \c v2f vector.
 * \details Casts a \c v16i vector into a \c v2f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2f v2f_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v2i
 * \brief Casts a \c v16i vector into a \c v2i vector.
 * \details Casts a \c v16i vector into a \c v2i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:63] := a.bits[0:63]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2i v2i_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v2l
 * \brief Casts a \c v16i vector into a \c v2l vector.
 * \details Casts a \c v16i vector into a \c v2l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v2l v2l_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v4d
 * \brief Casts a \c v16i vector into a \c v4d vector.
 * \details Casts a \c v16i vector into a \c v4d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4d v4d_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v4f
 * \brief Casts a \c v16i vector into a \c v4f vector.
 * \details Casts a \c v16i vector into a \c v4f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4f v4f_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v4i
 * \brief Casts a \c v16i vector into a \c v4i vector.
 * \details Casts a \c v16i vector into a \c v4i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:127] := a.bits[0:127]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4i v4i_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v4l
 * \brief Casts a \c v16i vector into a \c v4l vector.
 * \details Casts a \c v16i vector into a \c v4l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v4l v4l_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v8d
 * \brief Casts a \c v16i vector into a \c v8d vector.
 * \details Casts a \c v16i vector into a \c v8d vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8d v8d_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v8f
 * \brief Casts a \c v16i vector into a \c v8f vector.
 * \details Casts a \c v16i vector into a \c v8f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8f v8f_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v8i
 * \brief Casts a \c v16i vector into a \c v8i vector.
 * \details Casts a \c v16i vector into a \c v8i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 *  The upper bits of the input are discarded.
 * \impl
  dst.bits[0:255] := a.bits[0:255]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8i v8i_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v8l
 * \brief Casts a \c v16i vector into a \c v8l vector.
 * \details Casts a \c v16i vector into a \c v8l vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v8l v8l_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v16f
 * \brief Casts a \c v16i vector into a \c v16f vector.
 * \details Casts a \c v16i vector into a \c v16f vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16f v16f_cast_v16i(v16i a);
/**
 * \ingroup cast
 * \related v16i
 * \brief Casts a \c v16i vector into a \c v16i vector.
 * \details Casts a \c v16i vector into a \c v16i vector.
 *  No conversion is done: it consists in a reinterpretation of the bit sequence.
 *
 *  Should be just a compiler hint and never produces any assembly instructions.
 * \impl
  dst.bits[0:511] := a.bits[0:511]
\endimpl
 * \param a the vector to cast
 * \returns the casted vector
 */
v16i v16i_cast_v16i(v16i a);

/** \defgroup mcast mask cast functions
 * \ingroup maskop
 * Functions for casting vectors into or from mask-vectors
 */

/**
 * \ingroup mcast
 * \related v1d
 * \brief Casts a \c v1d vector into a \c m1d vector-mask.
 * \details Casts a \c v1d vector into a \c m1d vector-mask.
 * \details May be faster than m1d_cvt_v1d(v1d a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v1d \c vec:
 *  - \c `v1d_and(a, vec)`
 *  - \c `v1d_mask_move(m1d_cast_v1d(a), vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m1d m1d_cast_v1d(v1d a);
/**
 * \ingroup mcast
 * \related v1f
 * \brief Casts a \c v1f vector into a \c m1f vector-mask.
 * \details Casts a \c v1f vector into a \c m1f vector-mask.
 * \details May be faster than m1f_cvt_v1f(v1f a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v1f \c vec:
 *  - \c `v1f_and(a, vec)`
 *  - \c `v1f_mask_move(m1f_cast_v1f(a), vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m1f m1f_cast_v1f(v1f a);
/**
 * \ingroup mcast
 * \related v1i
 * \brief Casts a \c v1i vector into a \c m1i vector-mask.
 * \details Casts a \c v1i vector into a \c m1i vector-mask.
 * \details May be faster than m1i_cvt_v1i(v1i a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v1i \c vec:
 *  - \c `v1i_and(a, vec)`
 *  - \c `v1i_mask_move(m1i_cast_v1i(a), vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m1i m1i_cast_v1i(v1i a);
/**
 * \ingroup mcast
 * \related v1l
 * \brief Casts a \c v1l vector into a \c m1l vector-mask.
 * \details Casts a \c v1l vector into a \c m1l vector-mask.
 * \details May be faster than m1l_cvt_v1l(v1l a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v1l \c vec:
 *  - \c `v1l_and(a, vec)`
 *  - \c `v1l_mask_move(m1l_cast_v1l(a), vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m1l m1l_cast_v1l(v1l a);
/**
 * \ingroup mcast
 * \related v2d
 * \brief Casts a \c v2d vector into a \c m2d vector-mask.
 * \details Casts a \c v2d vector into a \c m2d vector-mask.
 * \details May be faster than m2d_cvt_v2d(v2d a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v2d \c vec:
 *  - \c `v2d_and(a, vec)`
 *  - \c `v2d_mask_move(m2d_cast_v2d(a), vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m2d m2d_cast_v2d(v2d a);
/**
 * \ingroup mcast
 * \related v2f
 * \brief Casts a \c v2f vector into a \c m2f vector-mask.
 * \details Casts a \c v2f vector into a \c m2f vector-mask.
 * \details May be faster than m2f_cvt_v2f(v2f a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v2f \c vec:
 *  - \c `v2f_and(a, vec)`
 *  - \c `v2f_mask_move(m2f_cast_v2f(a), vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m2f m2f_cast_v2f(v2f a);
/**
 * \ingroup mcast
 * \related v2i
 * \brief Casts a \c v2i vector into a \c m2i vector-mask.
 * \details Casts a \c v2i vector into a \c m2i vector-mask.
 * \details May be faster than m2i_cvt_v2i(v2i a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v2i \c vec:
 *  - \c `v2i_and(a, vec)`
 *  - \c `v2i_mask_move(m2i_cast_v2i(a), vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m2i m2i_cast_v2i(v2i a);
/**
 * \ingroup mcast
 * \related v2l
 * \brief Casts a \c v2l vector into a \c m2l vector-mask.
 * \details Casts a \c v2l vector into a \c m2l vector-mask.
 * \details May be faster than m2l_cvt_v2l(v2l a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v2l \c vec:
 *  - \c `v2l_and(a, vec)`
 *  - \c `v2l_mask_move(m2l_cast_v2l(a), vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m2l m2l_cast_v2l(v2l a);
/**
 * \ingroup mcast
 * \related v4d
 * \brief Casts a \c v4d vector into a \c m4d vector-mask.
 * \details Casts a \c v4d vector into a \c m4d vector-mask.
 * \details May be faster than m4d_cvt_v4d(v4d a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v4d \c vec:
 *  - \c `v4d_and(a, vec)`
 *  - \c `v4d_mask_move(m4d_cast_v4d(a), vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m4d m4d_cast_v4d(v4d a);
/**
 * \ingroup mcast
 * \related v4f
 * \brief Casts a \c v4f vector into a \c m4f vector-mask.
 * \details Casts a \c v4f vector into a \c m4f vector-mask.
 * \details May be faster than m4f_cvt_v4f(v4f a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v4f \c vec:
 *  - \c `v4f_and(a, vec)`
 *  - \c `v4f_mask_move(m4f_cast_v4f(a), vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m4f m4f_cast_v4f(v4f a);
/**
 * \ingroup mcast
 * \related v4i
 * \brief Casts a \c v4i vector into a \c m4i vector-mask.
 * \details Casts a \c v4i vector into a \c m4i vector-mask.
 * \details May be faster than m4i_cvt_v4i(v4i a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v4i \c vec:
 *  - \c `v4i_and(a, vec)`
 *  - \c `v4i_mask_move(m4i_cast_v4i(a), vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m4i m4i_cast_v4i(v4i a);
/**
 * \ingroup mcast
 * \related v4l
 * \brief Casts a \c v4l vector into a \c m4l vector-mask.
 * \details Casts a \c v4l vector into a \c m4l vector-mask.
 * \details May be faster than m4l_cvt_v4l(v4l a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v4l \c vec:
 *  - \c `v4l_and(a, vec)`
 *  - \c `v4l_mask_move(m4l_cast_v4l(a), vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m4l m4l_cast_v4l(v4l a);
/**
 * \ingroup mcast
 * \related v8d
 * \brief Casts a \c v8d vector into a \c m8d vector-mask.
 * \details Casts a \c v8d vector into a \c m8d vector-mask.
 * \details May be faster than m8d_cvt_v8d(v8d a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v8d \c vec:
 *  - \c `v8d_and(a, vec)`
 *  - \c `v8d_mask_move(m8d_cast_v8d(a), vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m8d m8d_cast_v8d(v8d a);
/**
 * \ingroup mcast
 * \related v8f
 * \brief Casts a \c v8f vector into a \c m8f vector-mask.
 * \details Casts a \c v8f vector into a \c m8f vector-mask.
 * \details May be faster than m8f_cvt_v8f(v8f a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v8f \c vec:
 *  - \c `v8f_and(a, vec)`
 *  - \c `v8f_mask_move(m8f_cast_v8f(a), vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m8f m8f_cast_v8f(v8f a);
/**
 * \ingroup mcast
 * \related v8i
 * \brief Casts a \c v8i vector into a \c m8i vector-mask.
 * \details Casts a \c v8i vector into a \c m8i vector-mask.
 * \details May be faster than m8i_cvt_v8i(v8i a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v8i \c vec:
 *  - \c `v8i_and(a, vec)`
 *  - \c `v8i_mask_move(m8i_cast_v8i(a), vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m8i m8i_cast_v8i(v8i a);
/**
 * \ingroup mcast
 * \related v8l
 * \brief Casts a \c v8l vector into a \c m8l vector-mask.
 * \details Casts a \c v8l vector into a \c m8l vector-mask.
 * \details May be faster than m8l_cvt_v8l(v8l a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFFFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v8l \c vec:
 *  - \c `v8l_and(a, vec)`
 *  - \c `v8l_mask_move(m8l_cast_v8l(a), vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if dst.bits[i:i+63] == 0xFFFFFFFFFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+63] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m8l m8l_cast_v8l(v8l a);
/**
 * \ingroup mcast
 * \related v16f
 * \brief Casts a \c v16f vector into a \c m16f vector-mask.
 * \details Casts a \c v16f vector into a \c m16f vector-mask.
 * \details May be faster than m16f_cvt_v16f(v16f a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v16f \c vec:
 *  - \c `v16f_and(a, vec)`
 *  - \c `v16f_mask_move(m16f_cast_v16f(a), vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m16f m16f_cast_v16f(v16f a);
/**
 * \ingroup mcast
 * \related v16i
 * \brief Casts a \c v16i vector into a \c m16i vector-mask.
 * \details Casts a \c v16i vector into a \c m16i vector-mask.
 * \details May be faster than m16i_cvt_v16i(v16i a) if \c a can act as a mask
 *  (ie: every elements are either 0 or 0xFFFFFFFF).
 *  Undefined behaviors otherwise.
 * \details If \c a can act as a mask, the following statements are equivalent for every vector \c v16i \c vec:
 *  - \c `v16i_and(a, vec)`
 *  - \c `v16i_mask_move(m16i_cast_v16i(a), vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if dst.bits[i:i+31] == 0xFFFFFFFF
    mask[j] := 1
  else if dst.bits[i:i+31] == 0
    mask[j] := 0
  endif
endfor
\endimpl
 * \param a the vector to cast
 * \returns vector-mask
 */
m16i m16i_cast_v16i(v16i a);
/**
 * \ingroup mcast
 * \related v1d
 * \brief Casts a \c m1d vector-mask into a \c v1d vector.
 * \details Casts a \c m1d vector-mask into a \c v1d vector.
 * \details May be faster than m1d_cvt_v1d(v1d a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v1d \c vec:
 *  - \c `v1d_and(v1d_cast_m1d(a), vec)`
 *  - \c `v1d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v1d v1d_cast_m1d(m1d a);
/**
 * \ingroup mcast
 * \related v1f
 * \brief Casts a \c m1f vector-mask into a \c v1f vector.
 * \details Casts a \c m1f vector-mask into a \c v1f vector.
 * \details May be faster than m1f_cvt_v1f(v1f a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v1f \c vec:
 *  - \c `v1f_and(v1f_cast_m1f(a), vec)`
 *  - \c `v1f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v1f v1f_cast_m1f(m1f a);
/**
 * \ingroup mcast
 * \related v1i
 * \brief Casts a \c m1i vector-mask into a \c v1i vector.
 * \details Casts a \c m1i vector-mask into a \c v1i vector.
 * \details May be faster than m1i_cvt_v1i(v1i a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v1i \c vec:
 *  - \c `v1i_and(v1i_cast_m1i(a), vec)`
 *  - \c `v1i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v1i v1i_cast_m1i(m1i a);
/**
 * \ingroup mcast
 * \related v1l
 * \brief Casts a \c m1l vector-mask into a \c v1l vector.
 * \details Casts a \c m1l vector-mask into a \c v1l vector.
 * \details May be faster than m1l_cvt_v1l(v1l a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v1l \c vec:
 *  - \c `v1l_and(v1l_cast_m1l(a), vec)`
 *  - \c `v1l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v1l v1l_cast_m1l(m1l a);
/**
 * \ingroup mcast
 * \related v2d
 * \brief Casts a \c m2d vector-mask into a \c v2d vector.
 * \details Casts a \c m2d vector-mask into a \c v2d vector.
 * \details May be faster than m2d_cvt_v2d(v2d a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v2d \c vec:
 *  - \c `v2d_and(v2d_cast_m2d(a), vec)`
 *  - \c `v2d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v2d v2d_cast_m2d(m2d a);
/**
 * \ingroup mcast
 * \related v2f
 * \brief Casts a \c m2f vector-mask into a \c v2f vector.
 * \details Casts a \c m2f vector-mask into a \c v2f vector.
 * \details May be faster than m2f_cvt_v2f(v2f a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v2f \c vec:
 *  - \c `v2f_and(v2f_cast_m2f(a), vec)`
 *  - \c `v2f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v2f v2f_cast_m2f(m2f a);
/**
 * \ingroup mcast
 * \related v2i
 * \brief Casts a \c m2i vector-mask into a \c v2i vector.
 * \details Casts a \c m2i vector-mask into a \c v2i vector.
 * \details May be faster than m2i_cvt_v2i(v2i a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v2i \c vec:
 *  - \c `v2i_and(v2i_cast_m2i(a), vec)`
 *  - \c `v2i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v2i v2i_cast_m2i(m2i a);
/**
 * \ingroup mcast
 * \related v2l
 * \brief Casts a \c m2l vector-mask into a \c v2l vector.
 * \details Casts a \c m2l vector-mask into a \c v2l vector.
 * \details May be faster than m2l_cvt_v2l(v2l a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v2l \c vec:
 *  - \c `v2l_and(v2l_cast_m2l(a), vec)`
 *  - \c `v2l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v2l v2l_cast_m2l(m2l a);
/**
 * \ingroup mcast
 * \related v4d
 * \brief Casts a \c m4d vector-mask into a \c v4d vector.
 * \details Casts a \c m4d vector-mask into a \c v4d vector.
 * \details May be faster than m4d_cvt_v4d(v4d a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v4d \c vec:
 *  - \c `v4d_and(v4d_cast_m4d(a), vec)`
 *  - \c `v4d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v4d v4d_cast_m4d(m4d a);
/**
 * \ingroup mcast
 * \related v4f
 * \brief Casts a \c m4f vector-mask into a \c v4f vector.
 * \details Casts a \c m4f vector-mask into a \c v4f vector.
 * \details May be faster than m4f_cvt_v4f(v4f a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v4f \c vec:
 *  - \c `v4f_and(v4f_cast_m4f(a), vec)`
 *  - \c `v4f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v4f v4f_cast_m4f(m4f a);
/**
 * \ingroup mcast
 * \related v4i
 * \brief Casts a \c m4i vector-mask into a \c v4i vector.
 * \details Casts a \c m4i vector-mask into a \c v4i vector.
 * \details May be faster than m4i_cvt_v4i(v4i a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v4i \c vec:
 *  - \c `v4i_and(v4i_cast_m4i(a), vec)`
 *  - \c `v4i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v4i v4i_cast_m4i(m4i a);
/**
 * \ingroup mcast
 * \related v4l
 * \brief Casts a \c m4l vector-mask into a \c v4l vector.
 * \details Casts a \c m4l vector-mask into a \c v4l vector.
 * \details May be faster than m4l_cvt_v4l(v4l a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v4l \c vec:
 *  - \c `v4l_and(v4l_cast_m4l(a), vec)`
 *  - \c `v4l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v4l v4l_cast_m4l(m4l a);
/**
 * \ingroup mcast
 * \related v8d
 * \brief Casts a \c m8d vector-mask into a \c v8d vector.
 * \details Casts a \c m8d vector-mask into a \c v8d vector.
 * \details May be faster than m8d_cvt_v8d(v8d a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v8d \c vec:
 *  - \c `v8d_and(v8d_cast_m8d(a), vec)`
 *  - \c `v8d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v8d v8d_cast_m8d(m8d a);
/**
 * \ingroup mcast
 * \related v8f
 * \brief Casts a \c m8f vector-mask into a \c v8f vector.
 * \details Casts a \c m8f vector-mask into a \c v8f vector.
 * \details May be faster than m8f_cvt_v8f(v8f a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v8f \c vec:
 *  - \c `v8f_and(v8f_cast_m8f(a), vec)`
 *  - \c `v8f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v8f v8f_cast_m8f(m8f a);
/**
 * \ingroup mcast
 * \related v8i
 * \brief Casts a \c m8i vector-mask into a \c v8i vector.
 * \details Casts a \c m8i vector-mask into a \c v8i vector.
 * \details May be faster than m8i_cvt_v8i(v8i a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v8i \c vec:
 *  - \c `v8i_and(v8i_cast_m8i(a), vec)`
 *  - \c `v8i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v8i v8i_cast_m8i(m8i a);
/**
 * \ingroup mcast
 * \related v8l
 * \brief Casts a \c m8l vector-mask into a \c v8l vector.
 * \details Casts a \c m8l vector-mask into a \c v8l vector.
 * \details May be faster than m8l_cvt_v8l(v8l a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v8l \c vec:
 *  - \c `v8l_and(v8l_cast_m8l(a), vec)`
 *  - \c `v8l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v8l v8l_cast_m8l(m8l a);
/**
 * \ingroup mcast
 * \related v16f
 * \brief Casts a \c m16f vector-mask into a \c v16f vector.
 * \details Casts a \c m16f vector-mask into a \c v16f vector.
 * \details May be faster than m16f_cvt_v16f(v16f a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v16f \c vec:
 *  - \c `v16f_and(v16f_cast_m16f(a), vec)`
 *  - \c `v16f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v16f v16f_cast_m16f(m16f a);
/**
 * \ingroup mcast
 * \related v16i
 * \brief Casts a \c m16i vector-mask into a \c v16i vector.
 * \details Casts a \c m16i vector-mask into a \c v16i vector.
 * \details May be faster than m16i_cvt_v16i(v16i a). Undefined behaviors when the mask is not set properly (undefined).
 * \details The following statements are equivalent for every vector \c v16i \c vec:
 *  - \c `v16i_and(v16i_cast_m16i(a), vec)`
 *  - \c `v16i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to cast
 * \returns vector
 */
v16i v16i_cast_m16i(m16i a);


/* CONVERTS */
/** \defgroup convert conversion functions
 * Functions for converting vectors
 */

/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v1d vector into a \c v1d vector.
 * \details Converts a \c v1d vector into a \c v1d vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v1d vector into a \c v1f vector.
 * \details Converts a \c v1d vector into a \c v1f vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v1d vector into a \c v1i vector.
 * \details Converts a \c v1d vector into a \c v1i vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v1d vector into a \c v1l vector.
 * \details Converts a \c v1d vector into a \c v1l vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v1d vector into a \c v2d vector.
 * \details Converts a \c v1d vector into a \c v2d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v1d vector into a \c v2f vector.
 * \details Converts a \c v1d vector into a \c v2f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v1d vector into a \c v2i vector.
 * \details Converts a \c v1d vector into a \c v2i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v1d vector into a \c v2l vector.
 * \details Converts a \c v1d vector into a \c v2l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v1d vector into a \c v4d vector.
 * \details Converts a \c v1d vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v1d vector into a \c v4f vector.
 * \details Converts a \c v1d vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v1d vector into a \c v4i vector.
 * \details Converts a \c v1d vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v1d vector into a \c v4l vector.
 * \details Converts a \c v1d vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v1d vector into a \c v8d vector.
 * \details Converts a \c v1d vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v1d vector into a \c v8f vector.
 * \details Converts a \c v1d vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v1d vector into a \c v8i vector.
 * \details Converts a \c v1d vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v1d vector into a \c v8l vector.
 * \details Converts a \c v1d vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v1d vector into a \c v16f vector.
 * \details Converts a \c v1d vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v1d vector into a \c v16i vector.
 * \details Converts a \c v1d vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v1d(v1d a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v1f vector into a \c v1d vector.
 * \details Converts a \c v1f vector into a \c v1d vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v1f vector into a \c v1f vector.
 * \details Converts a \c v1f vector into a \c v1f vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v1f vector into a \c v1i vector.
 * \details Converts a \c v1f vector into a \c v1i vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v1f vector into a \c v1l vector.
 * \details Converts a \c v1f vector into a \c v1l vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v1f vector into a \c v2d vector.
 * \details Converts a \c v1f vector into a \c v2d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v1f vector into a \c v2f vector.
 * \details Converts a \c v1f vector into a \c v2f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v1f vector into a \c v2i vector.
 * \details Converts a \c v1f vector into a \c v2i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v1f vector into a \c v2l vector.
 * \details Converts a \c v1f vector into a \c v2l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v1f vector into a \c v4d vector.
 * \details Converts a \c v1f vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v1f vector into a \c v4f vector.
 * \details Converts a \c v1f vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v1f vector into a \c v4i vector.
 * \details Converts a \c v1f vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v1f vector into a \c v4l vector.
 * \details Converts a \c v1f vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v1f vector into a \c v8d vector.
 * \details Converts a \c v1f vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v1f vector into a \c v8f vector.
 * \details Converts a \c v1f vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v1f vector into a \c v8i vector.
 * \details Converts a \c v1f vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v1f vector into a \c v8l vector.
 * \details Converts a \c v1f vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v1f vector into a \c v16f vector.
 * \details Converts a \c v1f vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v1f vector into a \c v16i vector.
 * \details Converts a \c v1f vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v1f(v1f a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v1i vector into a \c v1d vector.
 * \details Converts a \c v1i vector into a \c v1d vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v1i vector into a \c v1f vector.
 * \details Converts a \c v1i vector into a \c v1f vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v1i vector into a \c v1i vector.
 * \details Converts a \c v1i vector into a \c v1i vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v1i vector into a \c v1l vector.
 * \details Converts a \c v1i vector into a \c v1l vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v1i vector into a \c v2d vector.
 * \details Converts a \c v1i vector into a \c v2d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v1i vector into a \c v2f vector.
 * \details Converts a \c v1i vector into a \c v2f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v1i vector into a \c v2i vector.
 * \details Converts a \c v1i vector into a \c v2i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v1i vector into a \c v2l vector.
 * \details Converts a \c v1i vector into a \c v2l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v1i vector into a \c v4d vector.
 * \details Converts a \c v1i vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v1i vector into a \c v4f vector.
 * \details Converts a \c v1i vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v1i vector into a \c v4i vector.
 * \details Converts a \c v1i vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v1i vector into a \c v4l vector.
 * \details Converts a \c v1i vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v1i vector into a \c v8d vector.
 * \details Converts a \c v1i vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v1i vector into a \c v8f vector.
 * \details Converts a \c v1i vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v1i vector into a \c v8i vector.
 * \details Converts a \c v1i vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v1i vector into a \c v8l vector.
 * \details Converts a \c v1i vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v1i vector into a \c v16f vector.
 * \details Converts a \c v1i vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v1i vector into a \c v16i vector.
 * \details Converts a \c v1i vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v1i(v1i a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v1l vector into a \c v1d vector.
 * \details Converts a \c v1l vector into a \c v1d vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v1l vector into a \c v1f vector.
 * \details Converts a \c v1l vector into a \c v1f vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v1l vector into a \c v1i vector.
 * \details Converts a \c v1l vector into a \c v1i vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v1l vector into a \c v1l vector.
 * \details Converts a \c v1l vector into a \c v1l vector.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v1l vector into a \c v2d vector.
 * \details Converts a \c v1l vector into a \c v2d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v1l vector into a \c v2f vector.
 * \details Converts a \c v1l vector into a \c v2f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v1l vector into a \c v2i vector.
 * \details Converts a \c v1l vector into a \c v2i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v1l vector into a \c v2l vector.
 * \details Converts a \c v1l vector into a \c v2l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v1l vector into a \c v4d vector.
 * \details Converts a \c v1l vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v1l vector into a \c v4f vector.
 * \details Converts a \c v1l vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v1l vector into a \c v4i vector.
 * \details Converts a \c v1l vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v1l vector into a \c v4l vector.
 * \details Converts a \c v1l vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v1l vector into a \c v8d vector.
 * \details Converts a \c v1l vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v1l vector into a \c v8f vector.
 * \details Converts a \c v1l vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v1l vector into a \c v8i vector.
 * \details Converts a \c v1l vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v1l vector into a \c v8l vector.
 * \details Converts a \c v1l vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v1l vector into a \c v16f vector.
 * \details Converts a \c v1l vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v1l vector into a \c v16i vector.
 * \details Converts a \c v1l vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v1l(v1l a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v2d vector into a \c v1d vector.
 * \details Converts a \c v2d vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v2d vector into a \c v1f vector.
 * \details Converts a \c v2d vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v2d vector into a \c v1i vector.
 * \details Converts a \c v2d vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v2d vector into a \c v1l vector.
 * \details Converts a \c v2d vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v2d vector into a \c v2d vector.
 * \details Converts a \c v2d vector into a \c v2d vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v2d vector into a \c v2f vector.
 * \details Converts a \c v2d vector into a \c v2f vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v2d vector into a \c v2i vector.
 * \details Converts a \c v2d vector into a \c v2i vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v2d vector into a \c v2l vector.
 * \details Converts a \c v2d vector into a \c v2l vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v2d vector into a \c v4d vector.
 * \details Converts a \c v2d vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v2d vector into a \c v4f vector.
 * \details Converts a \c v2d vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v2d vector into a \c v4i vector.
 * \details Converts a \c v2d vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v2d vector into a \c v4l vector.
 * \details Converts a \c v2d vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v2d vector into a \c v8d vector.
 * \details Converts a \c v2d vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v2d vector into a \c v8f vector.
 * \details Converts a \c v2d vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v2d vector into a \c v8i vector.
 * \details Converts a \c v2d vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v2d vector into a \c v8l vector.
 * \details Converts a \c v2d vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v2d vector into a \c v16f vector.
 * \details Converts a \c v2d vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v2d vector into a \c v16i vector.
 * \details Converts a \c v2d vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v2d(v2d a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v2f vector into a \c v1d vector.
 * \details Converts a \c v2f vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v2f vector into a \c v1f vector.
 * \details Converts a \c v2f vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v2f vector into a \c v1i vector.
 * \details Converts a \c v2f vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v2f vector into a \c v1l vector.
 * \details Converts a \c v2f vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v2f vector into a \c v2d vector.
 * \details Converts a \c v2f vector into a \c v2d vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v2f vector into a \c v2f vector.
 * \details Converts a \c v2f vector into a \c v2f vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v2f vector into a \c v2i vector.
 * \details Converts a \c v2f vector into a \c v2i vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v2f vector into a \c v2l vector.
 * \details Converts a \c v2f vector into a \c v2l vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v2f vector into a \c v4d vector.
 * \details Converts a \c v2f vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v2f vector into a \c v4f vector.
 * \details Converts a \c v2f vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v2f vector into a \c v4i vector.
 * \details Converts a \c v2f vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v2f vector into a \c v4l vector.
 * \details Converts a \c v2f vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v2f vector into a \c v8d vector.
 * \details Converts a \c v2f vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v2f vector into a \c v8f vector.
 * \details Converts a \c v2f vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v2f vector into a \c v8i vector.
 * \details Converts a \c v2f vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v2f vector into a \c v8l vector.
 * \details Converts a \c v2f vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v2f vector into a \c v16f vector.
 * \details Converts a \c v2f vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v2f vector into a \c v16i vector.
 * \details Converts a \c v2f vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v2f(v2f a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v2i vector into a \c v1d vector.
 * \details Converts a \c v2i vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v2i vector into a \c v1f vector.
 * \details Converts a \c v2i vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v2i vector into a \c v1i vector.
 * \details Converts a \c v2i vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v2i vector into a \c v1l vector.
 * \details Converts a \c v2i vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v2i vector into a \c v2d vector.
 * \details Converts a \c v2i vector into a \c v2d vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v2i vector into a \c v2f vector.
 * \details Converts a \c v2i vector into a \c v2f vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v2i vector into a \c v2i vector.
 * \details Converts a \c v2i vector into a \c v2i vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v2i vector into a \c v2l vector.
 * \details Converts a \c v2i vector into a \c v2l vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v2i vector into a \c v4d vector.
 * \details Converts a \c v2i vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v2i vector into a \c v4f vector.
 * \details Converts a \c v2i vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v2i vector into a \c v4i vector.
 * \details Converts a \c v2i vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v2i vector into a \c v4l vector.
 * \details Converts a \c v2i vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v2i vector into a \c v8d vector.
 * \details Converts a \c v2i vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v2i vector into a \c v8f vector.
 * \details Converts a \c v2i vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v2i vector into a \c v8i vector.
 * \details Converts a \c v2i vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v2i vector into a \c v8l vector.
 * \details Converts a \c v2i vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v2i vector into a \c v16f vector.
 * \details Converts a \c v2i vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v2i vector into a \c v16i vector.
 * \details Converts a \c v2i vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v2i(v2i a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v2l vector into a \c v1d vector.
 * \details Converts a \c v2l vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v2l vector into a \c v1f vector.
 * \details Converts a \c v2l vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v2l vector into a \c v1i vector.
 * \details Converts a \c v2l vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v2l vector into a \c v1l vector.
 * \details Converts a \c v2l vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v2l vector into a \c v2d vector.
 * \details Converts a \c v2l vector into a \c v2d vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v2l vector into a \c v2f vector.
 * \details Converts a \c v2l vector into a \c v2f vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v2l vector into a \c v2i vector.
 * \details Converts a \c v2l vector into a \c v2i vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v2l vector into a \c v2l vector.
 * \details Converts a \c v2l vector into a \c v2l vector.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v2l vector into a \c v4d vector.
 * \details Converts a \c v2l vector into a \c v4d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v2l vector into a \c v4f vector.
 * \details Converts a \c v2l vector into a \c v4f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v2l vector into a \c v4i vector.
 * \details Converts a \c v2l vector into a \c v4i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v2l vector into a \c v4l vector.
 * \details Converts a \c v2l vector into a \c v4l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v2l vector into a \c v8d vector.
 * \details Converts a \c v2l vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v2l vector into a \c v8f vector.
 * \details Converts a \c v2l vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v2l vector into a \c v8i vector.
 * \details Converts a \c v2l vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v2l vector into a \c v8l vector.
 * \details Converts a \c v2l vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v2l vector into a \c v16f vector.
 * \details Converts a \c v2l vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v2l vector into a \c v16i vector.
 * \details Converts a \c v2l vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v2l(v2l a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v4d vector into a \c v1d vector.
 * \details Converts a \c v4d vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v4d vector into a \c v1f vector.
 * \details Converts a \c v4d vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v4d vector into a \c v1i vector.
 * \details Converts a \c v4d vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v4d vector into a \c v1l vector.
 * \details Converts a \c v4d vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v4d vector into a \c v2d vector.
 * \details Converts a \c v4d vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v4d vector into a \c v2f vector.
 * \details Converts a \c v4d vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v4d vector into a \c v2i vector.
 * \details Converts a \c v4d vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v4d vector into a \c v2l vector.
 * \details Converts a \c v4d vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v4d vector into a \c v4d vector.
 * \details Converts a \c v4d vector into a \c v4d vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v4d vector into a \c v4f vector.
 * \details Converts a \c v4d vector into a \c v4f vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v4d vector into a \c v4i vector.
 * \details Converts a \c v4d vector into a \c v4i vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v4d vector into a \c v4l vector.
 * \details Converts a \c v4d vector into a \c v4l vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v4d vector into a \c v8d vector.
 * \details Converts a \c v4d vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v4d vector into a \c v8f vector.
 * \details Converts a \c v4d vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v4d vector into a \c v8i vector.
 * \details Converts a \c v4d vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v4d vector into a \c v8l vector.
 * \details Converts a \c v4d vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v4d vector into a \c v16f vector.
 * \details Converts a \c v4d vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v4d vector into a \c v16i vector.
 * \details Converts a \c v4d vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v4d(v4d a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v4f vector into a \c v1d vector.
 * \details Converts a \c v4f vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v4f vector into a \c v1f vector.
 * \details Converts a \c v4f vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v4f vector into a \c v1i vector.
 * \details Converts a \c v4f vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v4f vector into a \c v1l vector.
 * \details Converts a \c v4f vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v4f vector into a \c v2d vector.
 * \details Converts a \c v4f vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v4f vector into a \c v2f vector.
 * \details Converts a \c v4f vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v4f vector into a \c v2i vector.
 * \details Converts a \c v4f vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v4f vector into a \c v2l vector.
 * \details Converts a \c v4f vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v4f vector into a \c v4d vector.
 * \details Converts a \c v4f vector into a \c v4d vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v4f vector into a \c v4f vector.
 * \details Converts a \c v4f vector into a \c v4f vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v4f vector into a \c v4i vector.
 * \details Converts a \c v4f vector into a \c v4i vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v4f vector into a \c v4l vector.
 * \details Converts a \c v4f vector into a \c v4l vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v4f vector into a \c v8d vector.
 * \details Converts a \c v4f vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v4f vector into a \c v8f vector.
 * \details Converts a \c v4f vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v4f vector into a \c v8i vector.
 * \details Converts a \c v4f vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v4f vector into a \c v8l vector.
 * \details Converts a \c v4f vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v4f vector into a \c v16f vector.
 * \details Converts a \c v4f vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v4f vector into a \c v16i vector.
 * \details Converts a \c v4f vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v4f(v4f a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v4i vector into a \c v1d vector.
 * \details Converts a \c v4i vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v4i vector into a \c v1f vector.
 * \details Converts a \c v4i vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v4i vector into a \c v1i vector.
 * \details Converts a \c v4i vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v4i vector into a \c v1l vector.
 * \details Converts a \c v4i vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v4i vector into a \c v2d vector.
 * \details Converts a \c v4i vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v4i vector into a \c v2f vector.
 * \details Converts a \c v4i vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v4i vector into a \c v2i vector.
 * \details Converts a \c v4i vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v4i vector into a \c v2l vector.
 * \details Converts a \c v4i vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v4i vector into a \c v4d vector.
 * \details Converts a \c v4i vector into a \c v4d vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v4i vector into a \c v4f vector.
 * \details Converts a \c v4i vector into a \c v4f vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v4i vector into a \c v4i vector.
 * \details Converts a \c v4i vector into a \c v4i vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v4i vector into a \c v4l vector.
 * \details Converts a \c v4i vector into a \c v4l vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v4i vector into a \c v8d vector.
 * \details Converts a \c v4i vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v4i vector into a \c v8f vector.
 * \details Converts a \c v4i vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v4i vector into a \c v8i vector.
 * \details Converts a \c v4i vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v4i vector into a \c v8l vector.
 * \details Converts a \c v4i vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v4i vector into a \c v16f vector.
 * \details Converts a \c v4i vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v4i vector into a \c v16i vector.
 * \details Converts a \c v4i vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v4i(v4i a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v4l vector into a \c v1d vector.
 * \details Converts a \c v4l vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v4l vector into a \c v1f vector.
 * \details Converts a \c v4l vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v4l vector into a \c v1i vector.
 * \details Converts a \c v4l vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v4l vector into a \c v1l vector.
 * \details Converts a \c v4l vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v4l vector into a \c v2d vector.
 * \details Converts a \c v4l vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v4l vector into a \c v2f vector.
 * \details Converts a \c v4l vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v4l vector into a \c v2i vector.
 * \details Converts a \c v4l vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v4l vector into a \c v2l vector.
 * \details Converts a \c v4l vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v4l vector into a \c v4d vector.
 * \details Converts a \c v4l vector into a \c v4d vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v4l vector into a \c v4f vector.
 * \details Converts a \c v4l vector into a \c v4f vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v4l vector into a \c v4i vector.
 * \details Converts a \c v4l vector into a \c v4i vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v4l vector into a \c v4l vector.
 * \details Converts a \c v4l vector into a \c v4l vector.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v4l vector into a \c v8d vector.
 * \details Converts a \c v4l vector into a \c v8d vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v4l vector into a \c v8f vector.
 * \details Converts a \c v4l vector into a \c v8f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v4l vector into a \c v8i vector.
 * \details Converts a \c v4l vector into a \c v8i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v4l vector into a \c v8l vector.
 * \details Converts a \c v4l vector into a \c v8l vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v4l vector into a \c v16f vector.
 * \details Converts a \c v4l vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v4l vector into a \c v16i vector.
 * \details Converts a \c v4l vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v4l(v4l a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v8d vector into a \c v1d vector.
 * \details Converts a \c v8d vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v8d vector into a \c v1f vector.
 * \details Converts a \c v8d vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v8d vector into a \c v1i vector.
 * \details Converts a \c v8d vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v8d vector into a \c v1l vector.
 * \details Converts a \c v8d vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v8d vector into a \c v2d vector.
 * \details Converts a \c v8d vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v8d vector into a \c v2f vector.
 * \details Converts a \c v8d vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v8d vector into a \c v2i vector.
 * \details Converts a \c v8d vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v8d vector into a \c v2l vector.
 * \details Converts a \c v8d vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v8d vector into a \c v4d vector.
 * \details Converts a \c v8d vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v8d vector into a \c v4f vector.
 * \details Converts a \c v8d vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v8d vector into a \c v4i vector.
 * \details Converts a \c v8d vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v8d vector into a \c v4l vector.
 * \details Converts a \c v8d vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v8d vector into a \c v8d vector.
 * \details Converts a \c v8d vector into a \c v8d vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v8d vector into a \c v8f vector.
 * \details Converts a \c v8d vector into a \c v8f vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v8d vector into a \c v8i vector.
 * \details Converts a \c v8d vector into a \c v8i vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v8d vector into a \c v8l vector.
 * \details Converts a \c v8d vector into a \c v8l vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v8d vector into a \c v16f vector.
 * \details Converts a \c v8d vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v8d vector into a \c v16i vector.
 * \details Converts a \c v8d vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__double__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v8d(v8d a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v8f vector into a \c v1d vector.
 * \details Converts a \c v8f vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v8f vector into a \c v1f vector.
 * \details Converts a \c v8f vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v8f vector into a \c v1i vector.
 * \details Converts a \c v8f vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v8f vector into a \c v1l vector.
 * \details Converts a \c v8f vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v8f vector into a \c v2d vector.
 * \details Converts a \c v8f vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v8f vector into a \c v2f vector.
 * \details Converts a \c v8f vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v8f vector into a \c v2i vector.
 * \details Converts a \c v8f vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v8f vector into a \c v2l vector.
 * \details Converts a \c v8f vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v8f vector into a \c v4d vector.
 * \details Converts a \c v8f vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v8f vector into a \c v4f vector.
 * \details Converts a \c v8f vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v8f vector into a \c v4i vector.
 * \details Converts a \c v8f vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v8f vector into a \c v4l vector.
 * \details Converts a \c v8f vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v8f vector into a \c v8d vector.
 * \details Converts a \c v8f vector into a \c v8d vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v8f vector into a \c v8f vector.
 * \details Converts a \c v8f vector into a \c v8f vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v8f vector into a \c v8i vector.
 * \details Converts a \c v8f vector into a \c v8i vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v8f vector into a \c v8l vector.
 * \details Converts a \c v8f vector into a \c v8l vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v8f vector into a \c v16f vector.
 * \details Converts a \c v8f vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v8f vector into a \c v16i vector.
 * \details Converts a \c v8f vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v8f(v8f a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v8i vector into a \c v1d vector.
 * \details Converts a \c v8i vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v8i vector into a \c v1f vector.
 * \details Converts a \c v8i vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v8i vector into a \c v1i vector.
 * \details Converts a \c v8i vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v8i vector into a \c v1l vector.
 * \details Converts a \c v8i vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v8i vector into a \c v2d vector.
 * \details Converts a \c v8i vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v8i vector into a \c v2f vector.
 * \details Converts a \c v8i vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v8i vector into a \c v2i vector.
 * \details Converts a \c v8i vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v8i vector into a \c v2l vector.
 * \details Converts a \c v8i vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v8i vector into a \c v4d vector.
 * \details Converts a \c v8i vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v8i vector into a \c v4f vector.
 * \details Converts a \c v8i vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v8i vector into a \c v4i vector.
 * \details Converts a \c v8i vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v8i vector into a \c v4l vector.
 * \details Converts a \c v8i vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v8i vector into a \c v8d vector.
 * \details Converts a \c v8i vector into a \c v8d vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v8i vector into a \c v8f vector.
 * \details Converts a \c v8i vector into a \c v8f vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v8i vector into a \c v8i vector.
 * \details Converts a \c v8i vector into a \c v8i vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v8i vector into a \c v8l vector.
 * \details Converts a \c v8i vector into a \c v8l vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v8i vector into a \c v16f vector.
 * \details Converts a \c v8i vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v8i vector into a \c v16i vector.
 * \details Converts a \c v8i vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v8i(v8i a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v8l vector into a \c v1d vector.
 * \details Converts a \c v8l vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v8l vector into a \c v1f vector.
 * \details Converts a \c v8l vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v8l vector into a \c v1i vector.
 * \details Converts a \c v8l vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v8l vector into a \c v1l vector.
 * \details Converts a \c v8l vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v8l vector into a \c v2d vector.
 * \details Converts a \c v8l vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v8l vector into a \c v2f vector.
 * \details Converts a \c v8l vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v8l vector into a \c v2i vector.
 * \details Converts a \c v8l vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v8l vector into a \c v2l vector.
 * \details Converts a \c v8l vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v8l vector into a \c v4d vector.
 * \details Converts a \c v8l vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v8l vector into a \c v4f vector.
 * \details Converts a \c v8l vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v8l vector into a \c v4i vector.
 * \details Converts a \c v8l vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v8l vector into a \c v4l vector.
 * \details Converts a \c v8l vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v8l vector into a \c v8d vector.
 * \details Converts a \c v8l vector into a \c v8d vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v8l vector into a \c v8f vector.
 * \details Converts a \c v8l vector into a \c v8f vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v8l vector into a \c v8i vector.
 * \details Converts a \c v8l vector into a \c v8i vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v8l vector into a \c v8l vector.
 * \details Converts a \c v8l vector into a \c v8l vector.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v8l vector into a \c v16f vector.
 * \details Converts a \c v8l vector into a \c v16f vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v8l vector into a \c v16i vector.
 * \details Converts a \c v8l vector into a \c v16i vector.
 *  The upper values of the result are undefined.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int64_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v8l(v8l a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v16f vector into a \c v1d vector.
 * \details Converts a \c v16f vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v16f vector into a \c v1f vector.
 * \details Converts a \c v16f vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v16f vector into a \c v1i vector.
 * \details Converts a \c v16f vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v16f vector into a \c v1l vector.
 * \details Converts a \c v16f vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v16f vector into a \c v2d vector.
 * \details Converts a \c v16f vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v16f vector into a \c v2f vector.
 * \details Converts a \c v16f vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v16f vector into a \c v2i vector.
 * \details Converts a \c v16f vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v16f vector into a \c v2l vector.
 * \details Converts a \c v16f vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v16f vector into a \c v4d vector.
 * \details Converts a \c v16f vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v16f vector into a \c v4f vector.
 * \details Converts a \c v16f vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v16f vector into a \c v4i vector.
 * \details Converts a \c v16f vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v16f vector into a \c v4l vector.
 * \details Converts a \c v16f vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v16f vector into a \c v8d vector.
 * \details Converts a \c v16f vector into a \c v8d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v16f vector into a \c v8f vector.
 * \details Converts a \c v16f vector into a \c v8f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v16f vector into a \c v8i vector.
 * \details Converts a \c v16f vector into a \c v8i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v16f vector into a \c v8l vector.
 * \details Converts a \c v16f vector into a \c v8l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__float__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v16f vector into a \c v16f vector.
 * \details Converts a \c v16f vector into a \c v16f vector.
 * \impl
for i from 0 to 15
  dst[i] := CONVERT_FROM__float__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v16f vector into a \c v16i vector.
 * \details Converts a \c v16f vector into a \c v16i vector.
 * \impl
for i from 0 to 15
  dst[i] := CONVERT_FROM__float__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v16f(v16f a);
/**
 * \ingroup convert
 * \related v1d
 * \brief Converts a \c v16i vector into a \c v1d vector.
 * \details Converts a \c v16i vector into a \c v1d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1d v1d_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v1f
 * \brief Converts a \c v16i vector into a \c v1f vector.
 * \details Converts a \c v16i vector into a \c v1f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1f v1f_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v1i
 * \brief Converts a \c v16i vector into a \c v1i vector.
 * \details Converts a \c v16i vector into a \c v1i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1i v1i_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v1l
 * \brief Converts a \c v16i vector into a \c v1l vector.
 * \details Converts a \c v16i vector into a \c v1l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 0
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v1l v1l_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v2d
 * \brief Converts a \c v16i vector into a \c v2d vector.
 * \details Converts a \c v16i vector into a \c v2d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2d v2d_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v2f
 * \brief Converts a \c v16i vector into a \c v2f vector.
 * \details Converts a \c v16i vector into a \c v2f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2f v2f_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v2i
 * \brief Converts a \c v16i vector into a \c v2i vector.
 * \details Converts a \c v16i vector into a \c v2i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2i v2i_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v2l
 * \brief Converts a \c v16i vector into a \c v2l vector.
 * \details Converts a \c v16i vector into a \c v2l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 1
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v2l v2l_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v4d
 * \brief Converts a \c v16i vector into a \c v4d vector.
 * \details Converts a \c v16i vector into a \c v4d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4d v4d_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v4f
 * \brief Converts a \c v16i vector into a \c v4f vector.
 * \details Converts a \c v16i vector into a \c v4f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4f v4f_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v4i
 * \brief Converts a \c v16i vector into a \c v4i vector.
 * \details Converts a \c v16i vector into a \c v4i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4i v4i_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v4l
 * \brief Converts a \c v16i vector into a \c v4l vector.
 * \details Converts a \c v16i vector into a \c v4l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 3
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v4l v4l_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v8d
 * \brief Converts a \c v16i vector into a \c v8d vector.
 * \details Converts a \c v16i vector into a \c v8d vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__double(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8d v8d_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v8f
 * \brief Converts a \c v16i vector into a \c v8f vector.
 * \details Converts a \c v16i vector into a \c v8f vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8f v8f_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v8i
 * \brief Converts a \c v16i vector into a \c v8i vector.
 * \details Converts a \c v16i vector into a \c v8i vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8i v8i_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v8l
 * \brief Converts a \c v16i vector into a \c v8l vector.
 * \details Converts a \c v16i vector into a \c v8l vector.
 *  The upper values of the input are discarded.
 * \impl
for i from 0 to 7
  dst[i] := CONVERT_FROM__int32_t__TO__int64_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v8l v8l_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v16f
 * \brief Converts a \c v16i vector into a \c v16f vector.
 * \details Converts a \c v16i vector into a \c v16f vector.
 * \impl
for i from 0 to 15
  dst[i] := CONVERT_FROM__int32_t__TO__float(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16f v16f_cvt_v16i(v16i a);
/**
 * \ingroup convert
 * \related v16i
 * \brief Converts a \c v16i vector into a \c v16i vector.
 * \details Converts a \c v16i vector into a \c v16i vector.
 * \impl
for i from 0 to 15
  dst[i] := CONVERT_FROM__int32_t__TO__int32_t(a[i])
endfor
\endimpl
 * \param a the vector to convert
 * \returns the converted vecter
 */
v16i v16i_cvt_v16i(v16i a);

/** \defgroup sconvert scalar conversion functions
 * Functions for converting vectors into scalar
 */

/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v1d vector into \c double.
 * \details Converts the first value of a \c v1d vector into \c double.
 * \impl
dst := CONVERT_FROM__double__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v1d(v1d a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v1d vector into \c float.
 * \details Converts the first value of a \c v1d vector into \c float.
 * \impl
dst := CONVERT_FROM__double__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v1d(v1d a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v1d vector into \c int32_t.
 * \details Converts the first value of a \c v1d vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__double__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v1d(v1d a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v1d vector into \c int64_t.
 * \details Converts the first value of a \c v1d vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__double__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v1d(v1d a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v1f vector into \c double.
 * \details Converts the first value of a \c v1f vector into \c double.
 * \impl
dst := CONVERT_FROM__float__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v1f(v1f a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v1f vector into \c float.
 * \details Converts the first value of a \c v1f vector into \c float.
 * \impl
dst := CONVERT_FROM__float__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v1f(v1f a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v1f vector into \c int32_t.
 * \details Converts the first value of a \c v1f vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__float__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v1f(v1f a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v1f vector into \c int64_t.
 * \details Converts the first value of a \c v1f vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__float__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v1f(v1f a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v1i vector into \c double.
 * \details Converts the first value of a \c v1i vector into \c double.
 * \impl
dst := CONVERT_FROM__int32_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v1i(v1i a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v1i vector into \c float.
 * \details Converts the first value of a \c v1i vector into \c float.
 * \impl
dst := CONVERT_FROM__int32_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v1i(v1i a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v1i vector into \c int32_t.
 * \details Converts the first value of a \c v1i vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v1i(v1i a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v1i vector into \c int64_t.
 * \details Converts the first value of a \c v1i vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v1i(v1i a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v1l vector into \c double.
 * \details Converts the first value of a \c v1l vector into \c double.
 * \impl
dst := CONVERT_FROM__int64_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v1l(v1l a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v1l vector into \c float.
 * \details Converts the first value of a \c v1l vector into \c float.
 * \impl
dst := CONVERT_FROM__int64_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v1l(v1l a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v1l vector into \c int32_t.
 * \details Converts the first value of a \c v1l vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v1l(v1l a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v1l vector into \c int64_t.
 * \details Converts the first value of a \c v1l vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v1l(v1l a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v2d vector into \c double.
 * \details Converts the first value of a \c v2d vector into \c double.
 * \impl
dst := CONVERT_FROM__double__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v2d(v2d a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v2d vector into \c float.
 * \details Converts the first value of a \c v2d vector into \c float.
 * \impl
dst := CONVERT_FROM__double__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v2d(v2d a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v2d vector into \c int32_t.
 * \details Converts the first value of a \c v2d vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__double__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v2d(v2d a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v2d vector into \c int64_t.
 * \details Converts the first value of a \c v2d vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__double__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v2d(v2d a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v2f vector into \c double.
 * \details Converts the first value of a \c v2f vector into \c double.
 * \impl
dst := CONVERT_FROM__float__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v2f(v2f a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v2f vector into \c float.
 * \details Converts the first value of a \c v2f vector into \c float.
 * \impl
dst := CONVERT_FROM__float__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v2f(v2f a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v2f vector into \c int32_t.
 * \details Converts the first value of a \c v2f vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__float__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v2f(v2f a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v2f vector into \c int64_t.
 * \details Converts the first value of a \c v2f vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__float__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v2f(v2f a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v2i vector into \c double.
 * \details Converts the first value of a \c v2i vector into \c double.
 * \impl
dst := CONVERT_FROM__int32_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v2i(v2i a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v2i vector into \c float.
 * \details Converts the first value of a \c v2i vector into \c float.
 * \impl
dst := CONVERT_FROM__int32_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v2i(v2i a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v2i vector into \c int32_t.
 * \details Converts the first value of a \c v2i vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v2i(v2i a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v2i vector into \c int64_t.
 * \details Converts the first value of a \c v2i vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v2i(v2i a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v2l vector into \c double.
 * \details Converts the first value of a \c v2l vector into \c double.
 * \impl
dst := CONVERT_FROM__int64_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v2l(v2l a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v2l vector into \c float.
 * \details Converts the first value of a \c v2l vector into \c float.
 * \impl
dst := CONVERT_FROM__int64_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v2l(v2l a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v2l vector into \c int32_t.
 * \details Converts the first value of a \c v2l vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v2l(v2l a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v2l vector into \c int64_t.
 * \details Converts the first value of a \c v2l vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v2l(v2l a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v4d vector into \c double.
 * \details Converts the first value of a \c v4d vector into \c double.
 * \impl
dst := CONVERT_FROM__double__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v4d(v4d a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v4d vector into \c float.
 * \details Converts the first value of a \c v4d vector into \c float.
 * \impl
dst := CONVERT_FROM__double__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v4d(v4d a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v4d vector into \c int32_t.
 * \details Converts the first value of a \c v4d vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__double__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v4d(v4d a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v4d vector into \c int64_t.
 * \details Converts the first value of a \c v4d vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__double__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v4d(v4d a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v4f vector into \c double.
 * \details Converts the first value of a \c v4f vector into \c double.
 * \impl
dst := CONVERT_FROM__float__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v4f(v4f a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v4f vector into \c float.
 * \details Converts the first value of a \c v4f vector into \c float.
 * \impl
dst := CONVERT_FROM__float__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v4f(v4f a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v4f vector into \c int32_t.
 * \details Converts the first value of a \c v4f vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__float__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v4f(v4f a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v4f vector into \c int64_t.
 * \details Converts the first value of a \c v4f vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__float__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v4f(v4f a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v4i vector into \c double.
 * \details Converts the first value of a \c v4i vector into \c double.
 * \impl
dst := CONVERT_FROM__int32_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v4i(v4i a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v4i vector into \c float.
 * \details Converts the first value of a \c v4i vector into \c float.
 * \impl
dst := CONVERT_FROM__int32_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v4i(v4i a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v4i vector into \c int32_t.
 * \details Converts the first value of a \c v4i vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v4i(v4i a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v4i vector into \c int64_t.
 * \details Converts the first value of a \c v4i vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v4i(v4i a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v4l vector into \c double.
 * \details Converts the first value of a \c v4l vector into \c double.
 * \impl
dst := CONVERT_FROM__int64_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v4l(v4l a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v4l vector into \c float.
 * \details Converts the first value of a \c v4l vector into \c float.
 * \impl
dst := CONVERT_FROM__int64_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v4l(v4l a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v4l vector into \c int32_t.
 * \details Converts the first value of a \c v4l vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v4l(v4l a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v4l vector into \c int64_t.
 * \details Converts the first value of a \c v4l vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v4l(v4l a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v8d vector into \c double.
 * \details Converts the first value of a \c v8d vector into \c double.
 * \impl
dst := CONVERT_FROM__double__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v8d(v8d a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v8d vector into \c float.
 * \details Converts the first value of a \c v8d vector into \c float.
 * \impl
dst := CONVERT_FROM__double__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v8d(v8d a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v8d vector into \c int32_t.
 * \details Converts the first value of a \c v8d vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__double__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v8d(v8d a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v8d vector into \c int64_t.
 * \details Converts the first value of a \c v8d vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__double__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v8d(v8d a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v8f vector into \c double.
 * \details Converts the first value of a \c v8f vector into \c double.
 * \impl
dst := CONVERT_FROM__float__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v8f(v8f a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v8f vector into \c float.
 * \details Converts the first value of a \c v8f vector into \c float.
 * \impl
dst := CONVERT_FROM__float__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v8f(v8f a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v8f vector into \c int32_t.
 * \details Converts the first value of a \c v8f vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__float__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v8f(v8f a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v8f vector into \c int64_t.
 * \details Converts the first value of a \c v8f vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__float__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v8f(v8f a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v8i vector into \c double.
 * \details Converts the first value of a \c v8i vector into \c double.
 * \impl
dst := CONVERT_FROM__int32_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v8i(v8i a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v8i vector into \c float.
 * \details Converts the first value of a \c v8i vector into \c float.
 * \impl
dst := CONVERT_FROM__int32_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v8i(v8i a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v8i vector into \c int32_t.
 * \details Converts the first value of a \c v8i vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v8i(v8i a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v8i vector into \c int64_t.
 * \details Converts the first value of a \c v8i vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v8i(v8i a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v8l vector into \c double.
 * \details Converts the first value of a \c v8l vector into \c double.
 * \impl
dst := CONVERT_FROM__int64_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v8l(v8l a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v8l vector into \c float.
 * \details Converts the first value of a \c v8l vector into \c float.
 * \impl
dst := CONVERT_FROM__int64_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v8l(v8l a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v8l vector into \c int32_t.
 * \details Converts the first value of a \c v8l vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v8l(v8l a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v8l vector into \c int64_t.
 * \details Converts the first value of a \c v8l vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int64_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v8l(v8l a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v16f vector into \c double.
 * \details Converts the first value of a \c v16f vector into \c double.
 * \impl
dst := CONVERT_FROM__float__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v16f(v16f a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v16f vector into \c float.
 * \details Converts the first value of a \c v16f vector into \c float.
 * \impl
dst := CONVERT_FROM__float__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v16f(v16f a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v16f vector into \c int32_t.
 * \details Converts the first value of a \c v16f vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__float__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v16f(v16f a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v16f vector into \c int64_t.
 * \details Converts the first value of a \c v16f vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__float__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v16f(v16f a);
/**
 * \ingroup sconvert
 * \related v1d
 * \brief Converts the first value of a \c v16i vector into \c double.
 * \details Converts the first value of a \c v16i vector into \c double.
 * \impl
dst := CONVERT_FROM__int32_t__TO__double(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
double sd_cvt_v16i(v16i a);
/**
 * \ingroup sconvert
 * \related v1f
 * \brief Converts the first value of a \c v16i vector into \c float.
 * \details Converts the first value of a \c v16i vector into \c float.
 * \impl
dst := CONVERT_FROM__int32_t__TO__float(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
float sf_cvt_v16i(v16i a);
/**
 * \ingroup sconvert
 * \related v1i
 * \brief Converts the first value of a \c v16i vector into \c int32_t.
 * \details Converts the first value of a \c v16i vector into \c int32_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int32_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int32_t si_cvt_v16i(v16i a);
/**
 * \ingroup sconvert
 * \related v1l
 * \brief Converts the first value of a \c v16i vector into \c int64_t.
 * \details Converts the first value of a \c v16i vector into \c int64_t.
 * \impl
dst := CONVERT_FROM__int32_t__TO__int64_t(a[0])
\endimpl
 * \param a the vector to convert
 * \returns scalar
 */
int64_t sl_cvt_v16i(v16i a);

/** \defgroup mconvert mask conversion functions
 * \ingroup maskop
 * Functions for converting vectors into and/or from mask-vectors
 */

/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c v1d vector into a \c m1d vector-mask.
 * \details Converts a \c v1d vector into a \c m1d vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 0
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m1d m1d_cvt_v1d(v1d a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c v1f vector into a \c m1f vector-mask.
 * \details Converts a \c v1f vector into a \c m1f vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 0
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m1f m1f_cvt_v1f(v1f a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c v1i vector into a \c m1i vector-mask.
 * \details Converts a \c v1i vector into a \c m1i vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 0
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m1i m1i_cvt_v1i(v1i a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c v1l vector into a \c m1l vector-mask.
 * \details Converts a \c v1l vector into a \c m1l vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 0
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m1l m1l_cvt_v1l(v1l a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c v2d vector into a \c m2d vector-mask.
 * \details Converts a \c v2d vector into a \c m2d vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 1
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m2d m2d_cvt_v2d(v2d a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c v2f vector into a \c m2f vector-mask.
 * \details Converts a \c v2f vector into a \c m2f vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 1
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m2f m2f_cvt_v2f(v2f a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c v2i vector into a \c m2i vector-mask.
 * \details Converts a \c v2i vector into a \c m2i vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 1
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m2i m2i_cvt_v2i(v2i a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c v2l vector into a \c m2l vector-mask.
 * \details Converts a \c v2l vector into a \c m2l vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 1
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m2l m2l_cvt_v2l(v2l a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c v4d vector into a \c m4d vector-mask.
 * \details Converts a \c v4d vector into a \c m4d vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 3
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m4d m4d_cvt_v4d(v4d a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c v4f vector into a \c m4f vector-mask.
 * \details Converts a \c v4f vector into a \c m4f vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 3
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m4f m4f_cvt_v4f(v4f a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c v4i vector into a \c m4i vector-mask.
 * \details Converts a \c v4i vector into a \c m4i vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 3
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m4i m4i_cvt_v4i(v4i a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c v4l vector into a \c m4l vector-mask.
 * \details Converts a \c v4l vector into a \c m4l vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 3
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m4l m4l_cvt_v4l(v4l a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c v8d vector into a \c m8d vector-mask.
 * \details Converts a \c v8d vector into a \c m8d vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 7
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m8d m8d_cvt_v8d(v8d a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c v8f vector into a \c m8f vector-mask.
 * \details Converts a \c v8f vector into a \c m8f vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 7
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m8f m8f_cvt_v8f(v8f a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c v8i vector into a \c m8i vector-mask.
 * \details Converts a \c v8i vector into a \c m8i vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 7
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m8i m8i_cvt_v8i(v8i a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c v8l vector into a \c m8l vector-mask.
 * \details Converts a \c v8l vector into a \c m8l vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 7
  i := j*64
  dst[j] := a.bits[i+63]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m8l m8l_cvt_v8l(v8l a);
/**
 * \ingroup mconvert
 * \related v16f
 * \brief Converts a \c v16f vector into a \c m16f vector-mask.
 * \details Converts a \c v16f vector into a \c m16f vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 15
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m16f m16f_cvt_v16f(v16f a);
/**
 * \ingroup mconvert
 * \related v16i
 * \brief Converts a \c v16i vector into a \c m16i vector-mask.
 * \details Converts a \c v16i vector into a \c m16i vector-mask. Sets dst[i] if the Most Significant Bit of a[i] is set.
 * \impl
for j from 0 to 15
  i := j*32
  dst[j] := a.bits[i+31]
endfor
\endimpl
 * \param a the vector to convert
 * \returns vector-mask
 */
m16i m16i_cvt_v16i(v16i a);
/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c m1d vector-mask into a \c v1d vector.
 * \details Converts a \c m1d vector-mask into a \c v1d vector.
 * \details The following statements are equivalent for every vector \c v1d \c vec:
 *  - \c `v1d_and(v1d_cvt_m1d(a), vec)`
 *  - \c `v1d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v1d v1d_cvt_m1d(m1d a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c m1f vector-mask into a \c v1f vector.
 * \details Converts a \c m1f vector-mask into a \c v1f vector.
 * \details The following statements are equivalent for every vector \c v1f \c vec:
 *  - \c `v1f_and(v1f_cvt_m1f(a), vec)`
 *  - \c `v1f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v1f v1f_cvt_m1f(m1f a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c m1i vector-mask into a \c v1i vector.
 * \details Converts a \c m1i vector-mask into a \c v1i vector.
 * \details The following statements are equivalent for every vector \c v1i \c vec:
 *  - \c `v1i_and(v1i_cvt_m1i(a), vec)`
 *  - \c `v1i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v1i v1i_cvt_m1i(m1i a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c m1l vector-mask into a \c v1l vector.
 * \details Converts a \c m1l vector-mask into a \c v1l vector.
 * \details The following statements are equivalent for every vector \c v1l \c vec:
 *  - \c `v1l_and(v1l_cvt_m1l(a), vec)`
 *  - \c `v1l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 0
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v1l v1l_cvt_m1l(m1l a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c m2d vector-mask into a \c v2d vector.
 * \details Converts a \c m2d vector-mask into a \c v2d vector.
 * \details The following statements are equivalent for every vector \c v2d \c vec:
 *  - \c `v2d_and(v2d_cvt_m2d(a), vec)`
 *  - \c `v2d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v2d v2d_cvt_m2d(m2d a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c m2f vector-mask into a \c v2f vector.
 * \details Converts a \c m2f vector-mask into a \c v2f vector.
 * \details The following statements are equivalent for every vector \c v2f \c vec:
 *  - \c `v2f_and(v2f_cvt_m2f(a), vec)`
 *  - \c `v2f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v2f v2f_cvt_m2f(m2f a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c m2i vector-mask into a \c v2i vector.
 * \details Converts a \c m2i vector-mask into a \c v2i vector.
 * \details The following statements are equivalent for every vector \c v2i \c vec:
 *  - \c `v2i_and(v2i_cvt_m2i(a), vec)`
 *  - \c `v2i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v2i v2i_cvt_m2i(m2i a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c m2l vector-mask into a \c v2l vector.
 * \details Converts a \c m2l vector-mask into a \c v2l vector.
 * \details The following statements are equivalent for every vector \c v2l \c vec:
 *  - \c `v2l_and(v2l_cvt_m2l(a), vec)`
 *  - \c `v2l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 1
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v2l v2l_cvt_m2l(m2l a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c m4d vector-mask into a \c v4d vector.
 * \details Converts a \c m4d vector-mask into a \c v4d vector.
 * \details The following statements are equivalent for every vector \c v4d \c vec:
 *  - \c `v4d_and(v4d_cvt_m4d(a), vec)`
 *  - \c `v4d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v4d v4d_cvt_m4d(m4d a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c m4f vector-mask into a \c v4f vector.
 * \details Converts a \c m4f vector-mask into a \c v4f vector.
 * \details The following statements are equivalent for every vector \c v4f \c vec:
 *  - \c `v4f_and(v4f_cvt_m4f(a), vec)`
 *  - \c `v4f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v4f v4f_cvt_m4f(m4f a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c m4i vector-mask into a \c v4i vector.
 * \details Converts a \c m4i vector-mask into a \c v4i vector.
 * \details The following statements are equivalent for every vector \c v4i \c vec:
 *  - \c `v4i_and(v4i_cvt_m4i(a), vec)`
 *  - \c `v4i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v4i v4i_cvt_m4i(m4i a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c m4l vector-mask into a \c v4l vector.
 * \details Converts a \c m4l vector-mask into a \c v4l vector.
 * \details The following statements are equivalent for every vector \c v4l \c vec:
 *  - \c `v4l_and(v4l_cvt_m4l(a), vec)`
 *  - \c `v4l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 3
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v4l v4l_cvt_m4l(m4l a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c m8d vector-mask into a \c v8d vector.
 * \details Converts a \c m8d vector-mask into a \c v8d vector.
 * \details The following statements are equivalent for every vector \c v8d \c vec:
 *  - \c `v8d_and(v8d_cvt_m8d(a), vec)`
 *  - \c `v8d_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v8d v8d_cvt_m8d(m8d a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c m8f vector-mask into a \c v8f vector.
 * \details Converts a \c m8f vector-mask into a \c v8f vector.
 * \details The following statements are equivalent for every vector \c v8f \c vec:
 *  - \c `v8f_and(v8f_cvt_m8f(a), vec)`
 *  - \c `v8f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v8f v8f_cvt_m8f(m8f a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c m8i vector-mask into a \c v8i vector.
 * \details Converts a \c m8i vector-mask into a \c v8i vector.
 * \details The following statements are equivalent for every vector \c v8i \c vec:
 *  - \c `v8i_and(v8i_cvt_m8i(a), vec)`
 *  - \c `v8i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v8i v8i_cvt_m8i(m8i a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c m8l vector-mask into a \c v8l vector.
 * \details Converts a \c m8l vector-mask into a \c v8l vector.
 * \details The following statements are equivalent for every vector \c v8l \c vec:
 *  - \c `v8l_and(v8l_cvt_m8l(a), vec)`
 *  - \c `v8l_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 7
  i := j*64
  if mask[j]
    dst.bits[i:i+63] := 0xFFFFFFFFFFFFFFFF
  else
    dst.bits[i:i+63] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v8l v8l_cvt_m8l(m8l a);
/**
 * \ingroup mconvert
 * \related v16f
 * \brief Converts a \c m16f vector-mask into a \c v16f vector.
 * \details Converts a \c m16f vector-mask into a \c v16f vector.
 * \details The following statements are equivalent for every vector \c v16f \c vec:
 *  - \c `v16f_and(v16f_cvt_m16f(a), vec)`
 *  - \c `v16f_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v16f v16f_cvt_m16f(m16f a);
/**
 * \ingroup mconvert
 * \related v16i
 * \brief Converts a \c m16i vector-mask into a \c v16i vector.
 * \details Converts a \c m16i vector-mask into a \c v16i vector.
 * \details The following statements are equivalent for every vector \c v16i \c vec:
 *  - \c `v16i_and(v16i_cvt_m16i(a), vec)`
 *  - \c `v16i_mask_move(a, vec)`
 *
 * \impl
for j from 0 to 15
  i := j*32
  if mask[j]
    dst.bits[i:i+31] := 0xFFFFFFFF
  else
    dst.bits[i:i+31] := 0
  endif
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns vector
 */
v16i v16i_cvt_m16i(m16i a);

/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c m1d vector-mask into a \c m1d vector-mask.
 * \details Converts a \c m1d vector-mask into a \c m1d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1d m1d_cvt_m1d(m1d a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c m1d vector-mask into a \c m1f vector-mask.
 * \details Converts a \c m1d vector-mask into a \c m1f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1f m1f_cvt_m1d(m1d a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c m1d vector-mask into a \c m1i vector-mask.
 * \details Converts a \c m1d vector-mask into a \c m1i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1i m1i_cvt_m1d(m1d a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c m1d vector-mask into a \c m1l vector-mask.
 * \details Converts a \c m1d vector-mask into a \c m1l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1l m1l_cvt_m1d(m1d a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c m2d vector-mask into a \c m2d vector-mask.
 * \details Converts a \c m2d vector-mask into a \c m2d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2d m2d_cvt_m2d(m2d a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c m2d vector-mask into a \c m2f vector-mask.
 * \details Converts a \c m2d vector-mask into a \c m2f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2f m2f_cvt_m2d(m2d a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c m2d vector-mask into a \c m2i vector-mask.
 * \details Converts a \c m2d vector-mask into a \c m2i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2i m2i_cvt_m2d(m2d a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c m2d vector-mask into a \c m2l vector-mask.
 * \details Converts a \c m2d vector-mask into a \c m2l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2l m2l_cvt_m2d(m2d a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c m4d vector-mask into a \c m4d vector-mask.
 * \details Converts a \c m4d vector-mask into a \c m4d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4d m4d_cvt_m4d(m4d a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c m4d vector-mask into a \c m4f vector-mask.
 * \details Converts a \c m4d vector-mask into a \c m4f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4f m4f_cvt_m4d(m4d a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c m4d vector-mask into a \c m4i vector-mask.
 * \details Converts a \c m4d vector-mask into a \c m4i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4i m4i_cvt_m4d(m4d a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c m4d vector-mask into a \c m4l vector-mask.
 * \details Converts a \c m4d vector-mask into a \c m4l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4l m4l_cvt_m4d(m4d a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c m8d vector-mask into a \c m8d vector-mask.
 * \details Converts a \c m8d vector-mask into a \c m8d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8d m8d_cvt_m8d(m8d a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c m8d vector-mask into a \c m8f vector-mask.
 * \details Converts a \c m8d vector-mask into a \c m8f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8f m8f_cvt_m8d(m8d a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c m8d vector-mask into a \c m8i vector-mask.
 * \details Converts a \c m8d vector-mask into a \c m8i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8i m8i_cvt_m8d(m8d a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c m8d vector-mask into a \c m8l vector-mask.
 * \details Converts a \c m8d vector-mask into a \c m8l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8l m8l_cvt_m8d(m8d a);
/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c m1f vector-mask into a \c m1d vector-mask.
 * \details Converts a \c m1f vector-mask into a \c m1d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1d m1d_cvt_m1f(m1f a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c m1f vector-mask into a \c m1f vector-mask.
 * \details Converts a \c m1f vector-mask into a \c m1f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1f m1f_cvt_m1f(m1f a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c m1f vector-mask into a \c m1i vector-mask.
 * \details Converts a \c m1f vector-mask into a \c m1i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1i m1i_cvt_m1f(m1f a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c m1f vector-mask into a \c m1l vector-mask.
 * \details Converts a \c m1f vector-mask into a \c m1l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1l m1l_cvt_m1f(m1f a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c m2f vector-mask into a \c m2d vector-mask.
 * \details Converts a \c m2f vector-mask into a \c m2d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2d m2d_cvt_m2f(m2f a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c m2f vector-mask into a \c m2f vector-mask.
 * \details Converts a \c m2f vector-mask into a \c m2f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2f m2f_cvt_m2f(m2f a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c m2f vector-mask into a \c m2i vector-mask.
 * \details Converts a \c m2f vector-mask into a \c m2i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2i m2i_cvt_m2f(m2f a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c m2f vector-mask into a \c m2l vector-mask.
 * \details Converts a \c m2f vector-mask into a \c m2l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2l m2l_cvt_m2f(m2f a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c m4f vector-mask into a \c m4d vector-mask.
 * \details Converts a \c m4f vector-mask into a \c m4d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4d m4d_cvt_m4f(m4f a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c m4f vector-mask into a \c m4f vector-mask.
 * \details Converts a \c m4f vector-mask into a \c m4f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4f m4f_cvt_m4f(m4f a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c m4f vector-mask into a \c m4i vector-mask.
 * \details Converts a \c m4f vector-mask into a \c m4i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4i m4i_cvt_m4f(m4f a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c m4f vector-mask into a \c m4l vector-mask.
 * \details Converts a \c m4f vector-mask into a \c m4l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4l m4l_cvt_m4f(m4f a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c m8f vector-mask into a \c m8d vector-mask.
 * \details Converts a \c m8f vector-mask into a \c m8d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8d m8d_cvt_m8f(m8f a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c m8f vector-mask into a \c m8f vector-mask.
 * \details Converts a \c m8f vector-mask into a \c m8f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8f m8f_cvt_m8f(m8f a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c m8f vector-mask into a \c m8i vector-mask.
 * \details Converts a \c m8f vector-mask into a \c m8i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8i m8i_cvt_m8f(m8f a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c m8f vector-mask into a \c m8l vector-mask.
 * \details Converts a \c m8f vector-mask into a \c m8l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8l m8l_cvt_m8f(m8f a);
/**
 * \ingroup mconvert
 * \related v16f
 * \brief Converts a \c m16f vector-mask into a \c m16f vector-mask.
 * \details Converts a \c m16f vector-mask into a \c m16f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 15
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m16f m16f_cvt_m16f(m16f a);
/**
 * \ingroup mconvert
 * \related v16i
 * \brief Converts a \c m16f vector-mask into a \c m16i vector-mask.
 * \details Converts a \c m16f vector-mask into a \c m16i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 15
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m16i m16i_cvt_m16f(m16f a);
/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c m1i vector-mask into a \c m1d vector-mask.
 * \details Converts a \c m1i vector-mask into a \c m1d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1d m1d_cvt_m1i(m1i a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c m1i vector-mask into a \c m1f vector-mask.
 * \details Converts a \c m1i vector-mask into a \c m1f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1f m1f_cvt_m1i(m1i a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c m1i vector-mask into a \c m1i vector-mask.
 * \details Converts a \c m1i vector-mask into a \c m1i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1i m1i_cvt_m1i(m1i a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c m1i vector-mask into a \c m1l vector-mask.
 * \details Converts a \c m1i vector-mask into a \c m1l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1l m1l_cvt_m1i(m1i a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c m2i vector-mask into a \c m2d vector-mask.
 * \details Converts a \c m2i vector-mask into a \c m2d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2d m2d_cvt_m2i(m2i a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c m2i vector-mask into a \c m2f vector-mask.
 * \details Converts a \c m2i vector-mask into a \c m2f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2f m2f_cvt_m2i(m2i a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c m2i vector-mask into a \c m2i vector-mask.
 * \details Converts a \c m2i vector-mask into a \c m2i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2i m2i_cvt_m2i(m2i a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c m2i vector-mask into a \c m2l vector-mask.
 * \details Converts a \c m2i vector-mask into a \c m2l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2l m2l_cvt_m2i(m2i a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c m4i vector-mask into a \c m4d vector-mask.
 * \details Converts a \c m4i vector-mask into a \c m4d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4d m4d_cvt_m4i(m4i a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c m4i vector-mask into a \c m4f vector-mask.
 * \details Converts a \c m4i vector-mask into a \c m4f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4f m4f_cvt_m4i(m4i a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c m4i vector-mask into a \c m4i vector-mask.
 * \details Converts a \c m4i vector-mask into a \c m4i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4i m4i_cvt_m4i(m4i a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c m4i vector-mask into a \c m4l vector-mask.
 * \details Converts a \c m4i vector-mask into a \c m4l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4l m4l_cvt_m4i(m4i a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c m8i vector-mask into a \c m8d vector-mask.
 * \details Converts a \c m8i vector-mask into a \c m8d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8d m8d_cvt_m8i(m8i a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c m8i vector-mask into a \c m8f vector-mask.
 * \details Converts a \c m8i vector-mask into a \c m8f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8f m8f_cvt_m8i(m8i a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c m8i vector-mask into a \c m8i vector-mask.
 * \details Converts a \c m8i vector-mask into a \c m8i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8i m8i_cvt_m8i(m8i a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c m8i vector-mask into a \c m8l vector-mask.
 * \details Converts a \c m8i vector-mask into a \c m8l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8l m8l_cvt_m8i(m8i a);
/**
 * \ingroup mconvert
 * \related v16f
 * \brief Converts a \c m16i vector-mask into a \c m16f vector-mask.
 * \details Converts a \c m16i vector-mask into a \c m16f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 15
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m16f m16f_cvt_m16i(m16i a);
/**
 * \ingroup mconvert
 * \related v16i
 * \brief Converts a \c m16i vector-mask into a \c m16i vector-mask.
 * \details Converts a \c m16i vector-mask into a \c m16i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 15
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m16i m16i_cvt_m16i(m16i a);
/**
 * \ingroup mconvert
 * \related v1d
 * \brief Converts a \c m1l vector-mask into a \c m1d vector-mask.
 * \details Converts a \c m1l vector-mask into a \c m1d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1d m1d_cvt_m1l(m1l a);
/**
 * \ingroup mconvert
 * \related v1f
 * \brief Converts a \c m1l vector-mask into a \c m1f vector-mask.
 * \details Converts a \c m1l vector-mask into a \c m1f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1f m1f_cvt_m1l(m1l a);
/**
 * \ingroup mconvert
 * \related v1i
 * \brief Converts a \c m1l vector-mask into a \c m1i vector-mask.
 * \details Converts a \c m1l vector-mask into a \c m1i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1i m1i_cvt_m1l(m1l a);
/**
 * \ingroup mconvert
 * \related v1l
 * \brief Converts a \c m1l vector-mask into a \c m1l vector-mask.
 * \details Converts a \c m1l vector-mask into a \c m1l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 0
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m1l m1l_cvt_m1l(m1l a);
/**
 * \ingroup mconvert
 * \related v2d
 * \brief Converts a \c m2l vector-mask into a \c m2d vector-mask.
 * \details Converts a \c m2l vector-mask into a \c m2d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2d m2d_cvt_m2l(m2l a);
/**
 * \ingroup mconvert
 * \related v2f
 * \brief Converts a \c m2l vector-mask into a \c m2f vector-mask.
 * \details Converts a \c m2l vector-mask into a \c m2f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2f m2f_cvt_m2l(m2l a);
/**
 * \ingroup mconvert
 * \related v2i
 * \brief Converts a \c m2l vector-mask into a \c m2i vector-mask.
 * \details Converts a \c m2l vector-mask into a \c m2i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2i m2i_cvt_m2l(m2l a);
/**
 * \ingroup mconvert
 * \related v2l
 * \brief Converts a \c m2l vector-mask into a \c m2l vector-mask.
 * \details Converts a \c m2l vector-mask into a \c m2l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 1
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m2l m2l_cvt_m2l(m2l a);
/**
 * \ingroup mconvert
 * \related v4d
 * \brief Converts a \c m4l vector-mask into a \c m4d vector-mask.
 * \details Converts a \c m4l vector-mask into a \c m4d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4d m4d_cvt_m4l(m4l a);
/**
 * \ingroup mconvert
 * \related v4f
 * \brief Converts a \c m4l vector-mask into a \c m4f vector-mask.
 * \details Converts a \c m4l vector-mask into a \c m4f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4f m4f_cvt_m4l(m4l a);
/**
 * \ingroup mconvert
 * \related v4i
 * \brief Converts a \c m4l vector-mask into a \c m4i vector-mask.
 * \details Converts a \c m4l vector-mask into a \c m4i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4i m4i_cvt_m4l(m4l a);
/**
 * \ingroup mconvert
 * \related v4l
 * \brief Converts a \c m4l vector-mask into a \c m4l vector-mask.
 * \details Converts a \c m4l vector-mask into a \c m4l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 3
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m4l m4l_cvt_m4l(m4l a);
/**
 * \ingroup mconvert
 * \related v8d
 * \brief Converts a \c m8l vector-mask into a \c m8d vector-mask.
 * \details Converts a \c m8l vector-mask into a \c m8d vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8d m8d_cvt_m8l(m8l a);
/**
 * \ingroup mconvert
 * \related v8f
 * \brief Converts a \c m8l vector-mask into a \c m8f vector-mask.
 * \details Converts a \c m8l vector-mask into a \c m8f vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8f m8f_cvt_m8l(m8l a);
/**
 * \ingroup mconvert
 * \related v8i
 * \brief Converts a \c m8l vector-mask into a \c m8i vector-mask.
 * \details Converts a \c m8l vector-mask into a \c m8i vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8i m8i_cvt_m8l(m8l a);
/**
 * \ingroup mconvert
 * \related v8l
 * \brief Converts a \c m8l vector-mask into a \c m8l vector-mask.
 * \details Converts a \c m8l vector-mask into a \c m8l vector-mask. 
 *  The input vector-mask and the output vector-mask mask the same elements.
 * \impl
for i from 0 to 7
  dst[i] := a[i]
endfor
\endimpl
 * \param a the vector-mask to convert
 * \returns the converted vector-mask
 */
m8l m8l_cvt_m8l(m8l a);

/* compatible CONVERTS */

//#endif //PINTS_DOC_H